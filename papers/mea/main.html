<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2023 (Released January 1, 2023) -->
<HTML lang="en">
<HEAD>
<TITLE>MEA</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2023">

<LINK REL="STYLESHEET" HREF="main.css">

</HEAD>

<BODY >

    <DIV class="CENTER">
<BR>
<BR>
<BR>
<BR>
</DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN  CLASS="textbf">MEA</SPAN>
</SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE">
<BR>
<BR>
        <SPAN CLASS="XXLARGE">Ein symmetrischer Blockverschlüsselungsalgorithmus
</SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE">
<BR>
<BR>
<BR>
<BR>
</SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN  CLASS="textbf">Michael Engel</SPAN>
</SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"></SPAN></SPAN></SPAN><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE">
            Autor:     </SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"> Michael Engel</SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"></SPAN></SPAN></SPAN></TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"> 
            Datum:     </SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"> 06.04.2022
        </SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"></SPAN></SPAN></SPAN></TD>
</TR>
</TABLE><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE">
</SPAN></SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE">
</SPAN></SPAN></SPAN></DIV>


<P>


<P>

<H1><A ID="SECTION00100000000000000000">
Abstract</A>
</H1>

<P>
Der Blockverschlüsselungsalgorithmus MEA ist ein dynamischer symmetrischer Verschlüsseulgsalgorithmus. Er setzt auf ein dynamisches
Netzwerk und eine höhere Blockgröße als AES [#!AES:1!#], die die Sicherheit und den Algorithmus mit seiner größeren Blockgröße effizienter für 64-Bit CPUs macht. Der Algorithmus hat
eine dynamische SPN-ähnliche[#!AES:1!#] Struktur mit vergrößerten MDS-Matrizen und vier neue S-Boxen. Zudem werden verschiedenste Transformationen angewendet, damit es zur einer
besseren Obfuskation kommt. Die Schlüssellänge und die Blockgröße des Algorithmus sind äquivalent mit einer Größe von 512 Bits, was durch die Verminderung der Varietäten des Algorithmus zur einer Verminderung von
Schwachstellen führt. Außerdem wird eine neue Schlüsselerzeugung benutzt, die sehr schnell und effizient im Vergleich zu andern Schlüsselerzeugungen ist. Zudem wird ein Permutationsalgorithmus angewandt, der schnell und sicher eine
Permutation der Funktionen in Abhängigkeit vom Schlüssel erzeugt. Die Rundenanzahl vom MEA ist höher im Vergleich zu AES [#!AES:1!#], was die Sicherheit verbessern sollte.
Aktuell sind keine effizienten und effektiven Angriffe oder Schwachstellen vom MEA bekannt, weswegen MEA zur Zeit als sehr sicher einzustufen ist. Der Blockverschlüsselungsalgorithmus MEA ist auch
für Hardware-bassierte Aufgaben gedacht, da er leicht auf spezielle Hardware implementierbar ist. Die unten gegebene Implementierung ist auf Schnelligkeit ausgelegt, weswegen sie in der Programmiersprache C verfasst wurde.

<P>
<BR>

<H2><A ID="SECTION00200000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A ID="tex2html34"
  HREF="main.html#SECTION00100000000000000000">Abstract</A>
<LI><A ID="tex2html35"
  HREF="main.html#SECTION00300000000000000000">Symbole und Definitionen</A>
<LI><A ID="tex2html36"
  HREF="main.html#SECTION00400000000000000000">Generelles</A>
<UL>
<LI><A ID="tex2html37"
  HREF="main.html#SECTION00410000000000000000">Input und Output</A>
</UL>
<BR>
<LI><A ID="tex2html38"
  HREF="main.html#SECTION00500000000000000000">Verschlüsselung</A>
<UL>
<LI><A ID="tex2html39"
  HREF="main.html#SECTION00510000000000000000">Algorithmus</A>
<LI><A ID="tex2html40"
  HREF="main.html#SECTION00520000000000000000">Die horizontale Permutation <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN></A>
<LI><A ID="tex2html41"
  HREF="main.html#SECTION00530000000000000000">Das bijektive nicht lineare mapping <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img77.svg"
 ALT="$\Omega_l$"></SPAN></A>
<LI><A ID="tex2html42"
  HREF="main.html#SECTION00540000000000000000">Die vertikale Permutation <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN></A>
<LI><A ID="tex2html43"
  HREF="main.html#SECTION00550000000000000000">Die lineare Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img80.svg"
 ALT="$\pi_l$"></SPAN></A>
<LI><A ID="tex2html44"
  HREF="main.html#SECTION00560000000000000000">Die dimensionale Permutation <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img63.svg"
 ALT="$\chi_l^{(h)}$"></SPAN></A>
<LI><A ID="tex2html45"
  HREF="main.html#SECTION00570000000000000000">Die Modulo 2 Addition (XOR-Operation) <!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></A>
</UL>
<BR>
<LI><A ID="tex2html46"
  HREF="main.html#SECTION00600000000000000000">Entschlüsselung</A>
<UL>
<LI><A ID="tex2html47"
  HREF="main.html#SECTION00610000000000000000">Algorithmus</A>
<LI><A ID="tex2html48"
  HREF="main.html#SECTION00620000000000000000">Die Inverse der horizontalen Permutation <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.76ex; vertical-align: -0.45ex; " SRC="img135.svg"
 ALT="$\hat{\vartheta_l}$"></SPAN></A>
<LI><A ID="tex2html49"
  HREF="main.html#SECTION00630000000000000000">Das bijektive nicht lineare mapping <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img136.svg"
 ALT="$\hat{\Omega_l}$"></SPAN></A>
<LI><A ID="tex2html50"
  HREF="main.html#SECTION00640000000000000000">Die Inverse der vertikalen Permutation <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img138.svg"
 ALT="$\hat{\Gamma_l}$"></SPAN></A>
<LI><A ID="tex2html51"
  HREF="main.html#SECTION00650000000000000000">Die Inverse der linearen Transformation <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img139.svg"
 ALT="$\hat{\pi_l}$"></SPAN></A>
<LI><A ID="tex2html52"
  HREF="main.html#SECTION00660000000000000000">Die Inverse der dimensionalen Permutation <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img157.svg"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN></A>
</UL>
<BR>
<LI><A ID="tex2html53"
  HREF="main.html#SECTION00700000000000000000">Rundenschlüssel Erzeugung</A>
<LI><A ID="tex2html54"
  HREF="main.html#SECTION00800000000000000000">Sequenz Shuffle Funktion <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img180.svg"
 ALT="$\Psi^{(K_z)}$"></SPAN></A>
<LI><A ID="tex2html55"
  HREF="main.html#SECTION00900000000000000000">Weiteres</A>
<UL>
<LI><A ID="tex2html56"
  HREF="main.html#SECTION00910000000000000000">S-Boxen   <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN> und -<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN></A>
</UL>
<BR>
<LI><A ID="tex2html57"
  HREF="main.html#SECTION001000000000000000000">Implementierung in der Programmiersprache C</A>
<UL>
<LI><A ID="tex2html58"
  HREF="main.html#SECTION001010000000000000000">Code</A>
<UL>
<LI><A ID="tex2html59"
  HREF="main.html#SECTION001011000000000000000">mea.h</A>
<LI><A ID="tex2html60"
  HREF="main.html#SECTION001012000000000000000">tables.h</A>
<LI><A ID="tex2html61"
  HREF="main.html#SECTION001013000000000000000">tables.c</A>
<LI><A ID="tex2html62"
  HREF="main.html#SECTION001014000000000000000">mea.c</A>
<LI><A ID="tex2html63"
  HREF="main.html#SECTION001015000000000000000">main.c</A>
</UL></UL></UL>
<!--End of Table of Contents-->

<P>
<P>

<H1><A ID="SECTION00300000000000000000">
Symbole und Definitionen</A>
</H1>

<P>
Die follgenden Symbole und Definitionen werden benutzt im MEA.

<P>
<BR>
<BR>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">0x</TD>
<TD CLASS="LEFT">- Prefix für Nummern im Hexadezimalsystem;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img1.svg"
 ALT="$\eta(x)$"></SPAN></TD>
<TD CLASS="LEFT">- das irreduzible Polynom <!-- MATH
 $x^8+x^4+x^3+x^2+1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.20ex; vertical-align: -0.27ex; " SRC="img2.svg"
 ALT="$x^8+x^4+x^3+x^2+1$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN></TD>
<TD CLASS="LEFT">- ein endlicher Körper mit dem irreduziblen Polynom <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img1.svg"
 ALT="$\eta(x)$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN></TD>
<TD CLASS="LEFT">- die Blockgröße vom MEA, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN> = 512;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img5.svg"
 ALT="$k$"></SPAN></TD>
<TD CLASS="LEFT">- die Schlüsselgröße vom MEA, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img5.svg"
 ALT="$k$"></SPAN> = 512;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img6.svg"
 ALT="$r$"></SPAN></TD>
<TD CLASS="LEFT">- die Anzahl der Reihen in der State-Matrix, <!-- MATH
 $r \in \{4,8\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img7.svg"
 ALT="$r \in \{4,8\}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img8.svg"
 ALT="$s$"></SPAN></TD>
<TD CLASS="LEFT">- die Anzahl der Spalten in der State-Matrix, <!-- MATH
 $s \in \{4,8\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img9.svg"
 ALT="$s \in \{4,8\}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN></TD>
<TD CLASS="LEFT">- der Schlüssel mit Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img5.svg"
 ALT="$k$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img11.svg"
 ALT="$V_d$"></SPAN></TD>
<TD CLASS="LEFT">- d-Dimensionaler Vektorraum im <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img12.svg"
 ALT="$GF(2)$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.41ex; " SRC="img13.svg"
 ALT="$d \geq 1$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.74ex; vertical-align: -0.29ex; " SRC="img14.svg"
 ALT="$\oplus$"></SPAN></TD>
<TD CLASS="LEFT">- die binäre exklusiv ODER Verknüpfung;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.55ex; vertical-align: -0.18ex; " SRC="img15.svg"
 ALT="$\ggg$"></SPAN></TD>
<TD CLASS="LEFT">- die rechts shift Operation mit einer konstanten Länge;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.55ex; vertical-align: -0.18ex; " SRC="img16.svg"
 ALT="$\lll$"></SPAN></TD>
<TD CLASS="LEFT">- die links shift Operation mit einer konstanten Länge;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN></TD>
<TD CLASS="LEFT">- die symmetrische Verschlüsselungstransformation,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">dass mapping von <!-- MATH
 $V_l \mapsto V_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img18.svg"
 ALT="$V_l \mapsto V_l$"></SPAN>, abhängig von <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN></TD>
<TD CLASS="LEFT">- die symmetrische Entschlüsselungstransformation,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">dass mapping von <!-- MATH
 $V_l \mapsto V_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img18.svg"
 ALT="$V_l \mapsto V_l$"></SPAN>, abhängig von <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\tau\odot\nu$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.74ex; vertical-align: -0.29ex; " SRC="img20.svg"
 ALT="$\tau\odot\nu$"></SPAN></TD>
<TD CLASS="LEFT">- sequentieller Ablauf der  der Transformationen <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img21.svg"
 ALT="$\tau$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">und <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img22.svg"
 ALT="$\nu$"></SPAN>, (<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img22.svg"
 ALT="$\nu$"></SPAN> wird zuerst angewandt);</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img23.svg"
 ALT="$\tau\vert\nu$"></SPAN></TD>
<TD CLASS="LEFT">- Ablauf der Transformationen <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img21.svg"
 ALT="$\tau$"></SPAN> oder <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img22.svg"
 ALT="$\nu$"></SPAN> (jede wird einmal ausgeführt),</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Permutation generiert duch die Sequenz-Shuffle Funktion <!-- MATH
 $\Psi^{K_k}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.09ex; vertical-align: -0.10ex; " SRC="img24.svg"
 ALT="$\Psi^{K_k}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\mu||\lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img25.svg"
 ALT="$\mu\vert\vert\lambda$"></SPAN></TD>
<TD CLASS="LEFT">- Ablauf der Packete <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.64ex; vertical-align: -0.55ex; " SRC="img26.svg"
 ALT="$\mu$"></SPAN> oder <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img27.svg"
 ALT="$\lambda$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.64ex; vertical-align: -0.55ex; " SRC="img26.svg"
 ALT="$\mu$"></SPAN> wird bei</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $i \mod{2} = 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img28.svg"
 ALT="$i \mod{2} = 0$"></SPAN> ausgeführt, abhängig von der Hauptrundenzahl <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.71ex; vertical-align: -0.10ex; " SRC="img29.svg"
 ALT="$i$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">ansonnsten wird <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img27.svg"
 ALT="$\lambda$"></SPAN> ausgeführt;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\mu \doteq\lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.40ex; vertical-align: -0.55ex; " SRC="img30.svg"
 ALT="$\mu \doteq\lambda$"></SPAN></TD>
<TD CLASS="LEFT">Substitution der Elemente <!-- MATH
 $\mu \& \lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img31.svg"
 ALT="$\mu \&amp; \lambda$"></SPAN>,   <!-- MATH
 $\mu \mapsto \lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img32.svg"
 ALT="$\mu \mapsto \lambda$"></SPAN> und <!-- MATH
 $\lambda \mapsto \mu$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img33.svg"
 ALT="$\lambda \mapsto \mu$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img34.svg"
 ALT="$n$"></SPAN></TD>
<TD CLASS="LEFT">- die jeweilige Anzahl der Iterationen in den Transformationen</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> und <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img35.svg"
 ALT="$n = 36$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.75ex; " SRC="img36.svg"
 ALT="$mea_{l,k}$"></SPAN></TD>
<TD CLASS="LEFT">Applikation der Transformationen <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> und <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\prod\limits_{i=c}^n\tau^{(i)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 5.50ex; vertical-align: -2.32ex; " SRC="img37.svg"
 ALT="$\prod\limits_{i=c}^n\tau^{(i)}$"></SPAN></TD>
<TD CLASS="LEFT">- sequentieller Ablauf der Transformationen <!-- MATH
 $\tau^{(c)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img38.svg"
 ALT="$\tau^{(c)}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $\tau^{(c+1)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img39.svg"
 ALT="$\tau^{(c+1)}$"></SPAN>, <!-- MATH
 $\tau^{(c+2)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img40.svg"
 ALT="$\tau^{(c+2)}$"></SPAN>, ...,  <!-- MATH
 $\tau^{(n)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img41.svg"
 ALT="$\tau^{(n)}$"></SPAN>, (<!-- MATH
 $\tau^{(c)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img38.svg"
 ALT="$\tau^{(c)}$"></SPAN> wird zuerst angewandt);</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<H1><A ID="SECTION00400000000000000000">
Generelles</A>
</H1>

<P>
Die Verschlüsselungstransformation ist das mapping von <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN>: <!-- MATH
 $V_d \mapsto V_d$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img42.svg"
 ALT="$V_d \mapsto V_d$"></SPAN>, dass
vom Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img43.svg"
 ALT="$K \in V_k$"></SPAN> abhängig ist, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img44.svg"
 ALT="$l = 512$"></SPAN> und <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img45.svg"
 ALT="$k = 512$"></SPAN>, also <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img46.svg"
 ALT="$l = k$"></SPAN>. <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> ist definiert
als eine Reihenfolge von <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img34.svg"
 ALT="$n$"></SPAN> Paketen, jeweils bestehend aus <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.65ex; " SRC="img47.svg"
 ALT="$\sqrt{n}$"></SPAN> Funktionen, wobei bei <!-- MATH
 $\frac{n}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.57ex; vertical-align: -0.90ex; " SRC="img48.svg"
 ALT="$\frac{n}{2}$"></SPAN> Paketen,
falls <!-- MATH
 $i_i \in \{0,1,2,3,...,35\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img49.svg"
 ALT="$i_i \in \{0,1,2,3,...,35\}$"></SPAN>, <!-- MATH
 $i_i \mod 2 = 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img50.svg"
 ALT="$i_i \mod 2 = 0$"></SPAN> (die Rundenzahl), die Reihenfolge der Funktionen im Paket konstant ist. Ansonnsten ist bei <!-- MATH
 $i_i \mod 2 \neq 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img51.svg"
 ALT="$i_i \mod 2 \neq 0$"></SPAN>
die Reihenfolge eine nicht vorhersehbare Permutation der <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.65ex; " SRC="img47.svg"
 ALT="$\sqrt{n}$"></SPAN> Funktionen in einem dynamischen Paket, die in Abhängigkeit von <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> generiert wird. 
Die jeweiligen Funktionen nehmen eine  <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.27ex; vertical-align: -0.10ex; " SRC="img52.svg"
 ALT="$r * s$"></SPAN> Matrix im <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN> als Input, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img53.svg"
 ALT="$r = 8$"></SPAN> und <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img54.svg"
 ALT="$s = 8$"></SPAN> und <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img55.svg"
 ALT="$x \in V_l$"></SPAN>.
Die <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.27ex; vertical-align: -0.10ex; " SRC="img52.svg"
 ALT="$r * s$"></SPAN> Matrix ist der Cihper State. Die Entschlüsselungstransformation <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN> in Abhängigkeit von <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img56.svg"
 ALT="$K$"></SPAN> ist das inversive
mapping von <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> mit allen Inversiven der Funktionen.
<BR>
Alle Parameter, die <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.75ex; " SRC="img36.svg"
 ALT="$mea_{l,k}$"></SPAN> definieren, sind in Tabelle 1 angegeben.
<DIV class="CENTER">
MEA
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">Blockgröße</TD>
<TD CLASS="LEFT">Rundenanzahl</TD>
<TD CLASS="LEFT">Schlüssellänge</TD>
<TD CLASS="CENTER">Anzahl der Reihen</TD>
<TD CLASS="LEFT">Anzahl der Spalten</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">512</TD>
<TD CLASS="LEFT">36</TD>
<TD CLASS="LEFT">512</TD>
<TD CLASS="CENTER">8 <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.48ex; vertical-align: -0.10ex; " SRC="img57.svg"
 ALT="$\lor$"></SPAN> 4</TD>
<TD CLASS="LEFT">8 <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.48ex; vertical-align: -0.10ex; " SRC="img57.svg"
 ALT="$\lor$"></SPAN> 4</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
</TR>
</TABLE>
<BR>
</DIV>
Tabelle 1

<P>

<H1><A ID="SECTION00410000000000000000">
Input und Output</A>
</H1>

<P>
Die Transformationprozesse nehmen als Input einen Block der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN>, egal ob bei der Verschlüsselung oder Entschlüsselung und geben
am Ende der Transformationen einen Block mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN> als Output. Die State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN> wird  repräsentiert durch <!-- MATH
 ${(s_{a,d,h})}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img59.svg"
 ALT="${(s_{a,d,h})}$"></SPAN>,
wobei <!-- MATH
 ${(s_{a,d,h})} \in V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img60.svg"
 ALT="${(s_{a,d,h})} \in V_8$"></SPAN> (bei <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN> und <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img63.svg"
 ALT="$\chi_l^{(h)}$"></SPAN>) , <!-- MATH
 $a = \overline{0, r-1}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img64.svg"
 ALT="$a = \overline{0, r-1}$"></SPAN>, <!-- MATH
 $d = \overline{0, s-1}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img65.svg"
 ALT="$d = \overline{0, s-1}$"></SPAN> und falls <!-- MATH
 $r = 4,s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.14ex; vertical-align: -0.55ex; " SRC="img66.svg"
 ALT="$r = 4,s = 4$"></SPAN> ist, 
ist <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>. Ansonnsten ist <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img68.svg"
 ALT="$h = 1$"></SPAN> . Die State-Matrix wird befüllt mit den Input Bytes <!-- MATH
 $B_1,B_2,B_4,\dots, B_{l/8}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.52ex; vertical-align: -0.85ex; " SRC="img69.svg"
 ALT="$B_1,B_2,B_4,\dots, B_{l/8}$"></SPAN> in der Row-Major Order,
dass heißt, dass als erstes die erste Reihe sequentiell von links nach rechts befüllt wird und danach die darunterliegende Reihe, bis
alle Reihen der Matrix voll sind. Falls die Input Nachricht <!-- MATH
 $P \mod{64} \neq 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img70.svg"
 ALT="$P \mod{64} \neq 0$"></SPAN> (in Bytes) ist, muss ein Padding Algorithmus<A ID="tex2html1"
  HREF="footnode.html#foot92"><SUP><IMG  ALT="[*]" SRC="footnote.png"></SUP></A> 
angewendet werden, damit die Nachricht in Bytes <!-- MATH
 $P \mod{64} = 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img71.svg"
 ALT="$P \mod{64} = 0$"></SPAN> erfüllt.

<P>

<H1><A ID="SECTION00500000000000000000">
Verschlüsselung</A>
</H1>

<P>

<H1><A ID="SECTION00510000000000000000">
Algorithmus</A>
</H1>

<P>
Der Verschlüsselungsalgortihmus <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> ist wie folgt definiert:
<P><!-- MATH
 \begin{displaymath}
E_{l,k}^{(K_k)} = \prod\limits_{i=0}^{\sqrt{n}-1}\prod\limits_{t=0}^{\sqrt{n}-1} (\kappa_l^{(K_z)} \odot \chi_{l}^{(\frac{t}{2})} \odot \pi_l \odot \Gamma_l \odot \Omega_l \odot \vartheta_l
)||( \kappa_l^{(K_z)} \odot (\vartheta_l | \Omega_l | \Gamma_l | \pi_l | \chi_{l}^{(\frac{t+1}{2})} | \kappa_l^{(K_z)} )\Psi^{(K_z)}) ,
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 7.64ex; vertical-align: -3.02ex; " SRC="img72.svg"
 ALT="$\displaystyle E_{l,k}^{(K_k)} = \prod\limits_{i=0}^{\sqrt{n}-1}\prod\limits_{t=...
...\pi_l \vert \chi_{l}^{(\frac{t+1}{2})} \vert \kappa_l^{(K_z)} )\Psi^{(K_z)}) , $">
</DIV><P></P>
wo <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> der Schlüssel mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img5.svg"
 ALT="$k$"></SPAN> ist,
<BR><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN></TD>
<TD CLASS="LEFT">- die horizentale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img77.svg"
 ALT="$\Omega_l$"></SPAN></TD>
<TD CLASS="LEFT">- das bijektive nicht lineare mapping der S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN>, <!-- MATH
 $b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img79.svg"
 ALT="$b \in \{0,1,2,3\}$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">mit den State-Matrix Vektoren,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN></TD>
<TD CLASS="LEFT">- die vertikale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img80.svg"
 ALT="$\pi_l$"></SPAN></TD>
<TD CLASS="LEFT">- die lineare Transformation des Cipher-State über das endliche Feld <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\chi_{l}^{(\frac{t+1}{2})}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.64ex; vertical-align: -0.74ex; " SRC="img81.svg"
 ALT="$\chi_{l}^{(\frac{t+1}{2})}$"></SPAN></TD>
<TD CLASS="LEFT">- die dimensionale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.90ex; vertical-align: -0.90ex; " SRC="img82.svg"
 ALT="$h = \frac{t+1}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\chi_{l}^{(\frac{t}{2})}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.58ex; vertical-align: -0.74ex; " SRC="img83.svg"
 ALT="$\chi_{l}^{(\frac{t}{2})}$"></SPAN></TD>
<TD CLASS="LEFT">- die dimensionale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h  = \frac{t}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.85ex; vertical-align: -0.90ex; " SRC="img84.svg"
 ALT="$h = \frac{t}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\kappa_l ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operation) mit den Rundenschlüssel</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $K_l^{(K_z)}, z = i\times6+t$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img86.svg"
 ALT="$K_l^{(K_z)}, z = i\times6+t$"></SPAN> und mit der State-Matrix ist.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
<BR>
In den Funktionen <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN>, <!-- MATH
 $\chi_{l}^{((t+1)/2)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img87.svg"
 ALT="$\chi_{l}^{((t+1)/2)}$"></SPAN> und <!-- MATH
 $\chi_{l}^{(t/2)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img88.svg"
 ALT="$\chi_{l}^{(t/2)}$"></SPAN>, mit dem Input <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img55.svg"
 ALT="$x \in V_l$"></SPAN>,
werden die Permutationen in einer dreidimensionalen <!-- MATH
 $4 \times 4 \times 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img89.svg"
 ALT="$4 \times 4 \times 4$"></SPAN> State-Matrix ausgeführt(<!-- MATH
 $r = 4, s = 4, h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img90.svg"
 ALT="$r = 4, s = 4, h = \overline{0,3}$"></SPAN>), um eine bessere Obfuskation zu erziehlen. 
Anonnsten wird immer eine zweidimensionale <!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matrix benutzt (<!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img92.svg"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>). Als Rückgabe aller Funktionen wird eine zweidimensionale 
<!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matirx ausgegeben.

<P>

<H1><A ID="SECTION00520000000000000000">
Die horizontale Permutation <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN></A>
</H1>

<P>
Die horizontale Permutation <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN> ist eine horizontale rechts shift Operation, die jede Reihe der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img93.svg"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.14ex; vertical-align: -0.55ex; " SRC="img66.svg"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img94.svg"
 ALT="$\zeta_r$"></SPAN> Positionen in einer Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img95.svg"
 ALT="$r_h$"></SPAN> nach rechts bewegt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img94.svg"
 ALT="$\zeta_r$"></SPAN> ist abhängig von der 
Reihennummer <!-- MATH
 $r_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img96.svg"
 ALT="$r_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_r = \frac{r\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.97ex; vertical-align: -0.90ex; " SRC="img97.svg"
 ALT="$\zeta_r = \frac{r\times l}{512}$"></SPAN> beschrieben werden. So wird
jede Reihe in jeder der vier Dimensionen um die Anzahl der Reihenzahl der Reihe nach rechts verschoben. So wird zum Beispiel jedes Element der Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.45ex; " SRC="img98.svg"
 ALT="$r_h = 2$"></SPAN>
(in der dritten Reihe) um 2 Position nach rechts verschoben. Die Elemente, die rechts aus der Reihe gehen, werden wieder links angehangen. Dieser Prozess
wird für jeder der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{13} & x_{10} & x_{11}& x_{12}\\
    x_{22} & x_{23} & x_{20}& x_{21}\\
    x_{31} & x_{32} & x_{33}& x_{30}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.94ex; vertical-align: -5.41ex; " SRC="img99.svg"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{23} &amp; x_{20}&amp; x_{21}\\
x_{31} &amp; x_{32} &amp; x_{33}&amp; x_{30}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00530000000000000000">
Das bijektive nicht lineare mapping <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img77.svg"
 ALT="$\Omega_l$"></SPAN></A>
</H1>

<P>
Die bijektive nicht lineare mapping Funktion <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img77.svg"
 ALT="$\Omega_l$"></SPAN> implementiert die S-Box Layer. Hier wird jedes Element <!-- MATH
 $s_{a,d,h} \in
 V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img100.svg"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img92.svg"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>, der State-Matrix mit <!-- MATH
 $\beta_r \mod4(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img101.svg"
 ALT="$\beta_r \mod4(s_{a,d,h})$"></SPAN>, wo <!-- MATH
 $\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img102.svg"
 ALT="$\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$"></SPAN>
substituiert. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN> sind Substitutionsboxen, die unten angegeben sind. Zum Beispiel wird <!-- MATH
 $s_{a,d,h} =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.75ex; " SRC="img103.svg"
 ALT="$s_{a,d,h} =$"></SPAN> 0x33 zu <!-- MATH
 $\beta_0(0x33) = 0xf7$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img104.svg"
 ALT="$\beta_0(0x33) = 0xf7$"></SPAN>
bei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img105.svg"
 ALT="$\beta_0$"></SPAN>. Es können auch andere S-Boxen benutzt werden, solange sie sicher sind und in der beschriebenen Fuktionsweise funktionieren. Die
angegebenen S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN> wurden mit Hilfe des Papers [#!SBOX:1!#] generiert.

<P>

<H1><A ID="SECTION00540000000000000000">
Die vertikale Permutation <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN></A>
</H1>

<P>
Die vertikale Permutation <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN> ist eine vertikale down shift Operation, die jede Spalte der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img93.svg"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.14ex; vertical-align: -0.55ex; " SRC="img66.svg"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img106.svg"
 ALT="$\zeta_s$"></SPAN> Positionen in einer Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img107.svg"
 ALT="$s_h$"></SPAN> nach unten bewegt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img106.svg"
 ALT="$\zeta_s$"></SPAN> ist abhängig von der 
Spaltennummer <!-- MATH
 $s_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img108.svg"
 ALT="$s_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_s = \frac{s\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.97ex; vertical-align: -0.90ex; " SRC="img109.svg"
 ALT="$\zeta_s = \frac{s\times l}{512}$"></SPAN> beschrieben werden.
Jede Spalte in jeder der vier Dimensionen wird um die Anzahl der  der Spalten nach unten verschoben. So wird zum Beispiel jedes Element der Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.45ex; " SRC="img110.svg"
 ALT="$s_h = 3$"></SPAN>
(in der vierten Spalte) um 3 Positionen nach unten verschoben. Die Elemente, die unten aus der Spalte gehen, werden wieder oben angehangen. Dieser Prozess
wird für jeder der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{31} & x_{22}& x_{13}\\
    x_{10} & x_{01} & x_{32}& x_{23}\\
    x_{20} & x_{11} & x_{02}& x_{33}\\
    x_{30} & x_{21} & x_{12}& x_{03}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.94ex; vertical-align: -5.41ex; " SRC="img111.svg"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{11} &amp; x_{02}&amp; x_{33}\\
x_{30} &amp; x_{21} &amp; x_{12}&amp; x_{03}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00550000000000000000">
Die lineare Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img80.svg"
 ALT="$\pi_l$"></SPAN></A>
</H1>

<P>
In der linearen Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img80.svg"
 ALT="$\pi_l$"></SPAN> wird jedes Element <!-- MATH
 $s_{a,d,h} \in V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img100.svg"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN> der State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8; h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img112.svg"
 ALT="$r = 8, s = 8; h = 1$"></SPAN> ist, als
ein Element des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN> mit dem irreduziblen Polynom <!-- MATH
 $\eta(x) = x^8+x^4+x^3+x^2+1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img113.svg"
 ALT="$\eta(x) = x^8+x^4+x^3+x^2+1$"></SPAN> dargestellt. Jedes neue Element der neuen
resultierenden Matrix <!-- MATH
 $T = (t_{a,d})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img114.svg"
 ALT="$T = (t_{a,d})$"></SPAN> wird in dem <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN> mit der folgenden Gleichung berechnet:
<P><!-- MATH
 \begin{displaymath}
(t_{a,d}) = (q \ggg a) \otimes S_d
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img115.svg"
 ALT="$\displaystyle (t_{a,d}) = (q \ggg a) \otimes S_d$">
</DIV><P></P>
<BR><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.23ex; vertical-align: -0.55ex; " SRC="img116.svg"
 ALT="$Q$"></SPAN> ist hier die MDS-Matrix (maximum distance separable)<A ID="tex2html2"
  HREF="footnode.html#foot249"><SUP><IMG  ALT="[*]" SRC="footnote.png"></SUP></A> <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.64ex; vertical-align: -0.55ex; " SRC="img117.svg"
 ALT="$q =$"></SPAN>( 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01), die eine Matrix ist, mit
bestimmten MDS Eigentschaften, die die Diffusion des Algorithmus stärkt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img118.svg"
 ALT="$S_d$"></SPAN> ist die d. Spalte der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matrix <!-- MATH
 $S = (s_{a,d,h}), r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img119.svg"
 ALT="$S = (s_{a,d,h}), r = 8, s = 8, h = 1$"></SPAN>. Der Vektor <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.64ex; vertical-align: -0.55ex; " SRC="img120.svg"
 ALT="$q$"></SPAN> besteht
aus Elementen des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN>, die in jeder Reihe um <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img121.svg"
 ALT="$a$"></SPAN> Einheiten, die Reihenzahl nach rechts verschoben werden. Am Ende der Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img80.svg"
 ALT="$\pi_l$"></SPAN> resultiert eine
neue <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matrix.

<P>

<H1><A ID="SECTION00560000000000000000">
Die dimensionale Permutation <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img63.svg"
 ALT="$\chi_l^{(h)}$"></SPAN></A>
</H1>

<P>
In der dimensionalen Permutation <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img63.svg"
 ALT="$\chi_l^{(h)}$"></SPAN>, abhängig vom Parameter <!-- MATH
 $h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img122.svg"
 ALT="$h \in \{0,1,2,3\}$"></SPAN>, wird die Dimension h in der <!-- MATH
 $4\times4\times4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img89.svg"
 ALT="$4 \times 4 \times 4$"></SPAN>
State-Matrix <!-- MATH
 $S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.80ex; vertical-align: -0.75ex; " SRC="img123.svg"
 ALT="$S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$"></SPAN>, einmal um 90 Grad nach links gedreht. So wird die Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img124.svg"
 ALT="$S_{a,h}$"></SPAN> zur Spalte 
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img125.svg"
 ALT="$S_{d,h}$"></SPAN>, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img126.svg"
 ALT="$S_{a_0,h}$"></SPAN> nach <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img127.svg"
 ALT="$S_{d_3,h}$"></SPAN> verschoben wird. Bei dem konstanten Packet <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.64ex; vertical-align: -0.55ex; " SRC="img26.svg"
 ALT="$\mu$"></SPAN> wird die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img128.svg"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.85ex; vertical-align: -0.90ex; " SRC="img84.svg"
 ALT="$h = \frac{t}{2}$"></SPAN> berechnet, bei der dann
die dimensionale Permutation angewendet wird. Bei dem variablen Packet <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img27.svg"
 ALT="$\lambda$"></SPAN> wird die Diemension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img128.svg"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.90ex; vertical-align: -0.90ex; " SRC="img82.svg"
 ALT="$h = \frac{t+1}{2}$"></SPAN> berechnet. Durch diese Gleichungen werden
nicht immer die gleichen Dimensionen im Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN> permutiert. Ein Beispiel für die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img129.svg"
 ALT="$h = 0$"></SPAN>:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{03} & x_{13} & x_{23}& x_{33}\\
    x_{02} & x_{12} & x_{22}& x_{32}\\
    x_{01} & x_{11} & x_{21}& x_{31}\\
    x_{00} & x_{10} & x_{20}& x_{30}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.94ex; vertical-align: -5.41ex; " SRC="img130.svg"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{11} &amp; x_{21}&amp; x_{31}\\
x_{00} &amp; x_{10} &amp; x_{20}&amp; x_{30}
\end{vmatrix}
$">
</DIV><P></P>

<P>

<H1><A ID="SECTION00570000000000000000">
Die Modulo 2 Addition (XOR-Operation) <!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></A>
</H1>

<P>
Die Funktion <!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN>, welche abhänngig vom Parameter <!-- MATH
 $K_z \in V_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img131.svg"
 ALT="$K_z \in V_l$"></SPAN> ist, hat als Argument die State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>
, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img55.svg"
 ALT="$x \in V_l$"></SPAN>. Der Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img132.svg"
 ALT="$K_z$"></SPAN>, wo <!-- MATH
 $z \in \{0,1,2,...,35\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img133.svg"
 ALT="$z \in \{0,1,2,...,35\}$"></SPAN> die aktuelle Runde ist, wird wie die State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, in einer Matrix
der Größe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> dargestellt. Dann wird der Schlüssel mit der State-Matrix mit Hilfe der XOR-Operation addiert. Das Ergebnis ist eine 
State-Matrix der Größe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN>, mit der dann weitere Funktionen ausgeführt werden.

<H1><A ID="SECTION00600000000000000000">
Entschlüsselung</A>
</H1>

<P>

<H1><A ID="SECTION00610000000000000000">
Algorithmus</A>
</H1>

<P>
Der Entschlüsselungsalgortihmus <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN> ist wie folgt definiert:
<P><!-- MATH
 \begin{displaymath}
D_{l,k}^{(K_k)} = \prod\limits_{i=\sqrt{n}-1}^{0}\prod\limits_{t=\sqrt{n}-1}^{0} (\hat{\vartheta_l} \odot \hat{\Omega_l} \odot \hat{\Gamma_l} \odot \hat{\pi_l} \odot \hat{\chi_{l}^{(\frac{t}{2})}} \odot \kappa_l ^{(K_z)}
)||(\hat{\vartheta_l} | \hat{\Omega_l} | \hat{\Gamma_l} | \hat{\pi_l} | \hat{\chi_{l}^{(\frac{t+1}{2})}} | \kappa_l^{(K_z)} ) \Psi^{(K_z)} \odot \kappa_l^{(K_z)}) ,
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 7.82ex; vertical-align: -3.61ex; " SRC="img134.svg"
 ALT="$\displaystyle D_{l,k}^{(K_k)} = \prod\limits_{i=\sqrt{n}-1}^{0}\prod\limits_{t=...
...rac{t+1}{2})}} \vert \kappa_l^{(K_z)} ) \Psi^{(K_z)} \odot \kappa_l^{(K_z)}) , $">
</DIV><P></P>
wo <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> der Schlüssel mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img5.svg"
 ALT="$k$"></SPAN> ist,
<BR><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.76ex; vertical-align: -0.45ex; " SRC="img135.svg"
 ALT="$\hat{\vartheta_l}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der horizentalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img136.svg"
 ALT="$\hat{\Omega_l}$"></SPAN></TD>
<TD CLASS="LEFT">- das bijektive nicht lineare mapping der S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img137.svg"
 ALT="$-\beta_b$"></SPAN>, <!-- MATH
 $b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img79.svg"
 ALT="$b \in \{0,1,2,3\}$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">mit den State-Matrix Vektoren,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img138.svg"
 ALT="$\hat{\Gamma_l}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der vertikalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">dem Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img139.svg"
 ALT="$\hat{\pi_l}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der linearen Transformation des Cipher-State über das</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">endliche Feld <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\chi_{l}^{(\frac{t+1}{2})}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 4.25ex; vertical-align: -0.74ex; " SRC="img140.svg"
 ALT="$\hat{\chi_{l}^{(\frac{t+1}{2})}}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der dimensionalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.90ex; vertical-align: -0.90ex; " SRC="img82.svg"
 ALT="$h = \frac{t+1}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\chi_{l}^{(\frac{t}{2})}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 4.19ex; vertical-align: -0.74ex; " SRC="img141.svg"
 ALT="$\hat{\chi_{l}^{(\frac{t}{2})}}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der dimensionalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img73.svg"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img74.svg"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h = \frac{h}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.97ex; vertical-align: -0.90ex; " SRC="img142.svg"
 ALT="$h = \frac{h}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\kappa_l ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operation) mit den Rundenschlüssel</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $K_l^{(K_z)}, z = i\times6+t$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img86.svg"
 ALT="$K_l^{(K_z)}, z = i\times6+t$"></SPAN> und mit der State-Matrix ist .</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
Wie bei der Verschlüsselung, wird bei den Funktionen <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.76ex; vertical-align: -0.45ex; " SRC="img135.svg"
 ALT="$\hat{\vartheta_l}$"></SPAN>, <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img138.svg"
 ALT="$\hat{\Gamma_l}$"></SPAN>, <!-- MATH
 $\hat{\chi_{l}^{((t+1)/2)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img143.svg"
 ALT="$\hat{\chi_{l}^{((t+1)/2)}}$"></SPAN> und <!-- MATH
 $\hat{\chi_{l}^{(t/2)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img144.svg"
 ALT="$\hat{\chi_{l}^{(t/2)}}$"></SPAN>, mit dem Input <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img55.svg"
 ALT="$x \in V_l$"></SPAN>, die Inverse der Permutationen in einer dreidimensionalen <!-- MATH
 $4 \times 4 \times 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img89.svg"
 ALT="$4 \times 4 \times 4$"></SPAN> State-Matrix ausgeführt (<!-- MATH
 $r = 4, s = 4, h = \overline{0,3},$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img145.svg"
 ALT="$r = 4, s = 4, h = \overline{0,3},$"></SPAN>), um eine bessere Obfuskation zu erzielen. 
Ansonsten wird immer eine zweidimensionale <!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matrix benutzt (<!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img92.svg"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>). Als Rückgabe aller Funktionen wird eine zweidimensionale 
<!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matirx ausgegeben.

<P>

<H1><A ID="SECTION00620000000000000000">
Die Inverse der horizontalen Permutation <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.76ex; vertical-align: -0.45ex; " SRC="img135.svg"
 ALT="$\hat{\vartheta_l}$"></SPAN></A>
</H1>

<P>
Die Inverse der horizontalen Permutation <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.76ex; vertical-align: -0.45ex; " SRC="img135.svg"
 ALT="$\hat{\vartheta_l}$"></SPAN> ist eine horizontale links shift Operation, die jede Reihe der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img93.svg"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.14ex; vertical-align: -0.55ex; " SRC="img66.svg"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img94.svg"
 ALT="$\zeta_r$"></SPAN> Positionen in einer Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img95.svg"
 ALT="$r_h$"></SPAN> nach links bewegt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img94.svg"
 ALT="$\zeta_r$"></SPAN> ist abhängig von der 
Reihennummer <!-- MATH
 $r_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img96.svg"
 ALT="$r_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_r = \frac{r\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.97ex; vertical-align: -0.90ex; " SRC="img97.svg"
 ALT="$\zeta_r = \frac{r\times l}{512}$"></SPAN> berechnet werden. So wird
jede Reihe in jeder der vier Dimensionen um die Anzahl der Reihenzahl der Reihe nach links verschoben. Zum Beispiel wird jedes Element der Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.45ex; " SRC="img98.svg"
 ALT="$r_h = 2$"></SPAN>
(in der dritten Reihe) um 2 Positionen nach links verschoben. Die Elemente, die links aus der Reihe gehen, werden wieder rechts angehangen. Dieser Prozess
wird für jeder der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{11} & x_{12} & x_{13}& x_{10}\\
    x_{22} & x_{23} & x_{20}& x_{21}\\
    x_{33} & x_{30} & x_{31}& x_{32}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.94ex; vertical-align: -5.41ex; " SRC="img146.svg"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{23} &amp; x_{20}&amp; x_{21}\\
x_{33} &amp; x_{30} &amp; x_{31}&amp; x_{32}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00630000000000000000">
Das bijektive nicht lineare mapping <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img136.svg"
 ALT="$\hat{\Omega_l}$"></SPAN></A>
</H1>

<P>
Die bijektive nicht lineare mapping Funktion <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img136.svg"
 ALT="$\hat{\Omega_l}$"></SPAN> ist die Inverse der S-Box Layer. Hier wird jedes Element <!-- MATH
 $s_{a,d,h} \in
 V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img100.svg"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img92.svg"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>, der State-Matrix mit <!-- MATH
 $-\beta_r \mod4(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img147.svg"
 ALT="$-\beta_r \mod4(s_{a,d,h})$"></SPAN>, wo <!-- MATH
 $-\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img148.svg"
 ALT="$-\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$"></SPAN>
substituiert. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img137.svg"
 ALT="$-\beta_b$"></SPAN> sind die inversen Substitutionsboxen, die unten angegeben sind. Zum Beispiel wird <!-- MATH
 $s_{a,d,h} =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.84ex; vertical-align: -0.75ex; " SRC="img103.svg"
 ALT="$s_{a,d,h} =$"></SPAN> 0xf7 zu <!-- MATH
 $-\beta_0(0xf7) = 0x33$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img149.svg"
 ALT="$-\beta_0(0xf7) = 0x33$"></SPAN>
bei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img150.svg"
 ALT="$-\beta_0$"></SPAN>. Es können auch andere S-Boxen benutzt werden, solange sie die korrekten Inversen der S-Boxen sind.

<P>

<H1><A ID="SECTION00640000000000000000">
Die Inverse der vertikalen Permutation <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img138.svg"
 ALT="$\hat{\Gamma_l}$"></SPAN></A>
</H1>

<P>
Die Inverse der vertikalen Permutation <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img138.svg"
 ALT="$\hat{\Gamma_l}$"></SPAN> ist eine vertikale up shift Operation, die jede Spalte der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img93.svg"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.14ex; vertical-align: -0.55ex; " SRC="img66.svg"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img106.svg"
 ALT="$\zeta_s$"></SPAN> Positionen in einer Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img107.svg"
 ALT="$s_h$"></SPAN> nach oben verschiebt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img106.svg"
 ALT="$\zeta_s$"></SPAN> ist abhängig von der 
Spaltennummer <!-- MATH
 $s_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img108.svg"
 ALT="$s_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img4.svg"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_s = \frac{s\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.97ex; vertical-align: -0.90ex; " SRC="img109.svg"
 ALT="$\zeta_s = \frac{s\times l}{512}$"></SPAN> beschrieben werden. So wird
jede Spalte in jeder der drei Dimensionen um die Anzahl der Spaltenzahl der Spalten nach oben verschoben. Zum Beispiel wird jedes Element der Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.45ex; " SRC="img110.svg"
 ALT="$s_h = 3$"></SPAN>
(in der vierten Spalte) um 3 Positionen nach oben verschoben. Die Elemente, die oben aus der Spalte gehen, werden wieder unten angehangen. Dieser Prozess
wird für jede der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{11} & x_{22}& x_{33}\\
    x_{10} & x_{21} & x_{32}& x_{03}\\
    x_{20} & x_{31} & x_{02}& x_{13}\\
    x_{30} & x_{01} & x_{12}& x_{23}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.94ex; vertical-align: -5.41ex; " SRC="img151.svg"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{31} &amp; x_{02}&amp; x_{13}\\
x_{30} &amp; x_{01} &amp; x_{12}&amp; x_{23}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00650000000000000000">
Die Inverse der linearen Transformation <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img139.svg"
 ALT="$\hat{\pi_l}$"></SPAN></A>
</H1>

<P>
In der Inverse der linearen Transformation <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img139.svg"
 ALT="$\hat{\pi_l}$"></SPAN> wird jedes Element <!-- MATH
 $s_{a,d,h} \in V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img100.svg"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN> der State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img92.svg"
 ALT="$r = 8, s = 8, h = 1$"></SPAN> ist, als
ein Element des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN> mit dem irreduziblen Polynom <!-- MATH
 $\eta(x) = x^8+x^4+x^3+x^2+1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img113.svg"
 ALT="$\eta(x) = x^8+x^4+x^3+x^2+1$"></SPAN> dargestellt. Jedes neue Element der neuen
resultierenden Matrix <!-- MATH
 $\hat{T} = (\hat{t}_{a,d})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.75ex; " SRC="img152.svg"
 ALT="$\hat{T} = (\hat{t}_{a,d})$"></SPAN> wird in dem <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN> mit der folgenden Gleichung berechnet:
<P><!-- MATH
 \begin{displaymath}
(\hat{t}_{a,d}) = (\hat{q} \lll a) \otimes S_d
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 2.88ex; vertical-align: -0.75ex; " SRC="img153.svg"
 ALT="$\displaystyle (\hat{t}_{a,d}) = (\hat{q} \lll a) \otimes S_d$">
</DIV><P></P>
<BR><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.84ex; vertical-align: -0.55ex; " SRC="img154.svg"
 ALT="$\hat{Q}$"></SPAN> ist hier die Inverse MDS-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img155.svg"
 ALT="$\hat{q} =$"></SPAN>(0x2f,0x49,0xd7,0xca,0xad,0x95,0x76,0xa8), die auch die MDS Eigenschaften besitzt.
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img118.svg"
 ALT="$S_d$"></SPAN> ist die d. Spalte der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matrix <!-- MATH
 $S = (s_{a,d,h}), r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img119.svg"
 ALT="$S = (s_{a,d,h}), r = 8, s = 8, h = 1$"></SPAN>. Der Vektor <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img156.svg"
 ALT="$\hat{q}$"></SPAN> besteht
 nur aus Elementen des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.61ex; vertical-align: -0.68ex; " SRC="img3.svg"
 ALT="$GF(2^8)$"></SPAN>, die in jeder Reihe um <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img121.svg"
 ALT="$a$"></SPAN> Einheiten, die Reihenzahl nach rechts verschoben werden. Am Ende der Inverse resultiert eine
neue <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN> State-Matrix.

<P>

<H1><A ID="SECTION00660000000000000000">
Die Inverse der dimensionalen Permutation <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img157.svg"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN></A>
</H1>

<P>
In der Inverse der dimensionalen Permutation <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img157.svg"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN>, abhängig vom Parameter <!-- MATH
 $h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img122.svg"
 ALT="$h \in \{0,1,2,3\}$"></SPAN>, wird die Dimension h in der <!-- MATH
 $4\times4\times4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img89.svg"
 ALT="$4 \times 4 \times 4$"></SPAN>
State-Matirx <!-- MATH
 $S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.80ex; vertical-align: -0.75ex; " SRC="img123.svg"
 ALT="$S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$"></SPAN>, zurück 90 Grad nach rechts gedreht. So wird wird die Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img125.svg"
 ALT="$S_{d,h}$"></SPAN> zur Reihe 
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img124.svg"
 ALT="$S_{a,h}$"></SPAN>, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img158.svg"
 ALT="$S_{d_0,h}$"></SPAN> nach <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.42ex; vertical-align: -0.75ex; " SRC="img159.svg"
 ALT="$S_{a_3,h}$"></SPAN> verschoben wird. Bei dem konstanten Packet <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.64ex; vertical-align: -0.55ex; " SRC="img26.svg"
 ALT="$\mu$"></SPAN> , wird die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img128.svg"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.85ex; vertical-align: -0.90ex; " SRC="img84.svg"
 ALT="$h = \frac{t}{2}$"></SPAN> berechnet, bei der dann
die Inverse der dimensionalen Permutation angewendet wird. Bei den variablen Packeten <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img27.svg"
 ALT="$\lambda$"></SPAN> wird die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img128.svg"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.90ex; vertical-align: -0.90ex; " SRC="img82.svg"
 ALT="$h = \frac{t+1}{2}$"></SPAN> berechnet. Durch diese Gleichungen 
wird die korrekte Inverse der dimensionalen Permutation berechnet. Ein Beispiel für die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img129.svg"
 ALT="$h = 0$"></SPAN>:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{30} & x_{20} & x_{10}& x_{00}\\
    x_{31} & x_{21} & x_{11}& x_{01}\\
    x_{32} & x_{22} & x_{12}& x_{02}\\
    x_{33} & x_{23} & x_{13}& x_{03}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.94ex; vertical-align: -5.41ex; " SRC="img160.svg"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{22} &amp; x_{12}&amp; x_{02}\\
x_{33} &amp; x_{23} &amp; x_{13}&amp; x_{03}
\end{vmatrix}
$">
</DIV><P></P>

<P>

<H1><A ID="SECTION00700000000000000000">
Rundenschlüssel Erzeugung</A>
</H1>

<P>
Die Rundenschlüssel <!-- MATH
 $K_z, z \in \{0,1,2,...,35\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img161.svg"
 ALT="$K_z, z \in \{0,1,2,...,35\}$"></SPAN> haben die gleiche Größe wie die Blocklänge <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img162.svg"
 ALT="$l, l = k$"></SPAN>. In der Funktion <!-- MATH
 $\kappa_l ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN>  werden die Rundenschlüssel in der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.88ex; vertical-align: -0.29ex; " SRC="img91.svg"
 ALT="$8 \times 8$"></SPAN>
State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.78ex; vertical-align: -0.10ex; " SRC="img58.svg"
 ALT="$S$"></SPAN> mit der XOR-Operation zusammenaddiert. Da es aber nicht sicher wäre, für jede Runde der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img35.svg"
 ALT="$n = 36$"></SPAN> Runden den gleichen
Schlüssel zu benutzen, werden 36 Rundenschlüssel mit der folgenden Gleichung <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img163.svg"
 ALT="$G^{(K_k)}$"></SPAN> erzeugt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img163.svg"
 ALT="$G^{(K_k)}$"></SPAN> ist abhängig von dem Master-Schlüssel
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> und von dem temporären Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img164.svg"
 ALT="$\alpha$"></SPAN>, der bei der ersten Runde <!-- MATH
 $\alpha = K_k$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img165.svg"
 ALT="$\alpha = K_k$"></SPAN> ist, und bei den restlichen 35 Schlüssel,
<!-- MATH
 $\alpha = K_{-z}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.28ex; vertical-align: -0.61ex; " SRC="img166.svg"
 ALT="$\alpha = K_{-z}$"></SPAN> ist, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.28ex; vertical-align: -0.61ex; " SRC="img167.svg"
 ALT="$K_{-z}$"></SPAN> der vorherige Rundenschlüssl ist. Somit ist <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img163.svg"
 ALT="$G^{(K_k)}$"></SPAN>:

<P>
<P><!-- MATH
 \begin{displaymath}
G^{(K_k)} = \hat{\kappa_k^{(\alpha)}} \odot \digamma_k \odot \Gamma_k \odot \Omega_k^{(rh)} \odot \kappa_k^{(\alpha)},
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img168.svg"
 ALT="$\displaystyle G^{(K_k)} = \hat{\kappa_k^{(\alpha)}} \odot \digamma_k \odot \Gamma_k \odot \Omega_k^{(rh)} \odot \kappa_k^{(\alpha)}, $">
</DIV><P></P>
<BR>
wo <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> der Master-Schlüssel mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img5.svg"
 ALT="$k$"></SPAN> ist,
<BR><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><!-- MATH
 $\kappa_k ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img169.svg"
 ALT="$\kappa_k ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operaton) mit dem Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img164.svg"
 ALT="$\alpha$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">und der RCON Konstanten <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img170.svg"
 ALT="$m$"></SPAN> = 0xc6e8e5ed7b352d4 ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\kappa_k ^{(K_z)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img171.svg"
 ALT="$\hat{\kappa_k ^{(K_z)}}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operaton) mit dem Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img164.svg"
 ALT="$\alpha$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">und den Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img132.svg"
 ALT="$K_z$"></SPAN> ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\Omega_k^{(rh)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img172.svg"
 ALT="$\Omega_k^{(rh)}$"></SPAN></TD>
<TD CLASS="LEFT">- das bijektive nicht lineare mapping der S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN>, <!-- MATH
 $b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img79.svg"
 ALT="$b \in \{0,1,2,3\}$"></SPAN>, mit der</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">konstanten Reihenfolge <!-- MATH
 $rh = \{1,0,3,2,3,0,1,2\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="img173.svg"
 ALT="$rh = \{1,0,3,2,3,0,1,2\}$"></SPAN>, statt einer sequenziellen</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Reihenfolge wie bei der Verschlüsselung, mit den Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img132.svg"
 ALT="$K_z$"></SPAN> ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img174.svg"
 ALT="$\Gamma_k$"></SPAN></TD>
<TD CLASS="LEFT">- die vertikale Permutation der Elemente <!-- MATH
 $(k_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img175.svg"
 ALT="$(k_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(k_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img176.svg"
 ALT="${(k_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img132.svg"
 ALT="$K_z$"></SPAN> ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\digamma_k$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.89ex; vertical-align: -0.45ex; " SRC="img177.svg"
 ALT="$\digamma_k$"></SPAN></TD>
<TD CLASS="LEFT">- die dimensionale Permutation der Elemente <!-- MATH
 $(k_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.58ex; vertical-align: -0.75ex; " SRC="img175.svg"
 ALT="$(k_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(k_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img176.svg"
 ALT="${(k_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img75.svg"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img76.svg"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.55ex; " SRC="img67.svg"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img132.svg"
 ALT="$K_z$"></SPAN>, hier aber die Dimensionen h in der Reihenfolge,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $h = 2 \mapsto h = 3$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img178.svg"
 ALT="$h = 2 \mapsto h = 3$"></SPAN> und <!-- MATH
 $h = 3 \mapsto h = 2$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.10ex; " SRC="img179.svg"
 ALT="$h = 3 \mapsto h = 2$"></SPAN> gewechselt wird.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
Die Funktion <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img163.svg"
 ALT="$G^{(K_k)}$"></SPAN>muss dann <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.19ex; vertical-align: -0.10ex; " SRC="img34.svg"
 ALT="$n$"></SPAN> mal ausführt werden, damit man die benötigte Anzahl von Rundenschlüssel erzeugt. Es wurde
bewusst ein recht leicht zu berechnener Algorithmus für die Rundenschlüssel-Erzeugung entwickelt, da dieser Algorithmus auf die
nicht Vorhersehbarkeit des Master-Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> setzt und es somit nicht nötig und effizient wäre, einen komplexen Algorithmus für die
Rundenschlüssel-Erzeugung zu entwickeln und anzuwenden.

<P>

<H1><A ID="SECTION00800000000000000000">
Sequenz Shuffle Funktion <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img180.svg"
 ALT="$\Psi^{(K_z)}$"></SPAN></A>
</H1>

<P>
Da MEA nicht wie AES [#!AES:1!#] ein konstantes kryptographisches Netzwerk wie das SPN [#!AES:1!#] benutzt, muss eine dynamische Reihenfolge für jedes
dynamische Packet generiert werden. Diese Reihenfolge ist abhängig vom Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN>, doch sollte sie nicht vorhersehbar ohne den Schlüssel
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> sein. Aus diesem Grund wird der Permutations Algorithmus <!-- MATH
 $\Psi^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img181.svg"
 ALT="$\Psi^{(K_k)}$"></SPAN> angewandt, der abhängig von den Rundenschlüsseln <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img132.svg"
 ALT="$K_z$"></SPAN> ist,
die vom Masterschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img10.svg"
 ALT="$K_k$"></SPAN> mit der vorher beschriebenen Funktion <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img163.svg"
 ALT="$G^{(K_k)}$"></SPAN> generiert wurden. Zuerst werden <!-- MATH
 $\frac{n}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.57ex; vertical-align: -0.90ex; " SRC="img48.svg"
 ALT="$\frac{n}{2}$"></SPAN> Arrays mit jeweils 6 Elementen
generiert, die jeweils sequentziell mit 0 bis 5 aufgefüllt werden. Dies ist die Startreihenfolge <!-- MATH
 $Rt_{\sqrt{n}} \in R_{\frac{n}{2}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -1.05ex; " SRC="img182.svg"
 ALT="$Rt_{\sqrt{n}} \in R_{\frac{n}{2}}$"></SPAN>, wobei
<!-- MATH
 $Rt_{\sqrt{n}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.59ex; vertical-align: -0.92ex; " SRC="img183.svg"
 ALT="$Rt_{\sqrt{n}}$"></SPAN> das t. Element von <!-- MATH
 $R_{\frac{n}{2}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -1.05ex; " SRC="img184.svg"
 ALT="$R_{\frac{n}{2}}$"></SPAN> ist. <!-- MATH
 $t \in \{0,1,2,...,\frac{n}{2}-1\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.90ex; " SRC="img185.svg"
 ALT="$t \in \{0,1,2,...,\frac{n}{2}-1\}$"></SPAN>. <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img180.svg"
 ALT="$\Psi^{(K_z)}$"></SPAN> ist wie folgt definiert:

<P>
<P><!-- MATH
 \begin{displaymath}
\Psi^{(K_z)} = \prod\limits_{i=0}^{\sqrt{n}-1} \prod\limits_{t=0}^{\frac{n}{2}} \prod\limits_{z=0}^{\sqrt{n}-2} Rt_{(\iota_{K_{(i+t)}}^{(z)})} \doteq Rt_{(\iota_{K_{(i+t)}}^{(z+1)})},
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 7.76ex; vertical-align: -3.02ex; " SRC="img186.svg"
 ALT="$\displaystyle \Psi^{(K_z)} = \prod\limits_{i=0}^{\sqrt{n}-1} \prod\limits_{t=0}...
...t{n}-2} Rt_{(\iota_{K_{(i+t)}}^{(z)})} \doteq Rt_{(\iota_{K_{(i+t)}}^{(z+1)})},$">
</DIV><P></P>
wobei <!-- MATH
 $\iota_{K_{(i+t)}}^{(-z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -1.35ex; " SRC="img187.svg"
 ALT="$\iota_{K_{(i+t)}}^{(-z)}$"></SPAN> das x. Element von <!-- MATH
 $Rt_{\sqrt{n}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.59ex; vertical-align: -0.92ex; " SRC="img183.svg"
 ALT="$Rt_{\sqrt{n}}$"></SPAN> ist und mit Hilfe der Tabelle 2 in Ahbängigkeit vom Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.52ex; vertical-align: -0.85ex; " SRC="img188.svg"
 ALT="$K_{(i+t)}$"></SPAN> bestimmt wird. Bei der Funktion
<!-- MATH
 $\iota_{K_{(i+t)}}^{(-z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -1.35ex; " SRC="img187.svg"
 ALT="$\iota_{K_{(i+t)}}^{(-z)}$"></SPAN> wird geschaut, ob die Nummer <!-- MATH
 $-y \in K_{[-z]}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.52ex; vertical-align: -0.85ex; " SRC="img189.svg"
 ALT="$-y \in K_{[-z]}$"></SPAN>, im Rundenschlüssel <!-- MATH
 $K_{z} \in K_{z = i+t}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.28ex; vertical-align: -0.61ex; " SRC="img190.svg"
 ALT="$K_{z} \in K_{z = i+t}$"></SPAN>, kleiner als ein Wert ist und dann mit Hilfe der Tabelle 2 den größtmöglichen Wert zugewiesen wird. Das Resultat wird dann als Rückgabe gegeben.
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">Wert</TD>
<TD CLASS="LEFT">Resultat</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img191.svg"
 ALT="$\leq$"></SPAN> 0x2A</TD>
<TD CLASS="LEFT">0x00</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img191.svg"
 ALT="$\leq$"></SPAN> 0x54</TD>
<TD CLASS="LEFT">0x01</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img191.svg"
 ALT="$\leq$"></SPAN> 0x7E</TD>
<TD CLASS="LEFT">0x02</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img191.svg"
 ALT="$\leq$"></SPAN> 0xA8</TD>
<TD CLASS="LEFT">0x03</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img191.svg"
 ALT="$\leq$"></SPAN> 0xD2</TD>
<TD CLASS="LEFT">0x04</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img191.svg"
 ALT="$\leq$"></SPAN> 0xFF</TD>
<TD CLASS="LEFT">0x05</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">Wert</TD>
<TD CLASS="LEFT">Funktion</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x00</TD>
<TD CLASS="LEFT"><!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img61.svg"
 ALT="$\vartheta_l$"></SPAN> oder <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.76ex; vertical-align: -0.45ex; " SRC="img135.svg"
 ALT="$\hat{\vartheta_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x01</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img77.svg"
 ALT="$\Omega_l$"></SPAN> oder <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img136.svg"
 ALT="$\hat{\Omega_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x02</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.12ex; vertical-align: -0.45ex; " SRC="img62.svg"
 ALT="$\Gamma_l$"></SPAN> oder <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.73ex; vertical-align: -0.45ex; " SRC="img138.svg"
 ALT="$\hat{\Gamma_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x03</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.54ex; vertical-align: -0.45ex; " SRC="img80.svg"
 ALT="$\pi_l$"></SPAN> oder <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.15ex; vertical-align: -0.45ex; " SRC="img139.svg"
 ALT="$\hat{\pi_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x04</TD>
<TD CLASS="LEFT"><!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img63.svg"
 ALT="$\chi_l^{(h)}$"></SPAN> oder <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.79ex; vertical-align: -0.74ex; " SRC="img157.svg"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x05</TD>
<TD CLASS="LEFT"><!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.18ex; vertical-align: -0.74ex; " SRC="img85.svg"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
Tabelle 2        und            Tabelle 3
<BR>
<BR>
Dieser Prozess wird dann <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.60ex; vertical-align: -0.65ex; " SRC="img47.svg"
 ALT="$\sqrt{n}$"></SPAN>-mal wiederholt, damit eine sichere Permutation ensteht. Diese Permutation wird dann als
dynamische Reihenfolge <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.10ex; " SRC="img180.svg"
 ALT="$\Psi^{(K_z)}$"></SPAN> benutzt, die mit Hilfe der Tabelle 3 die jeweligen Funktionen in <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img17.svg"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> und <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.48ex; vertical-align: -1.04ex; " SRC="img19.svg"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN> ausführt.

<P>

<H1><A ID="SECTION00900000000000000000">
Weiteres</A>
</H1>

<P>

<H1><A ID="SECTION00910000000000000000">
S-Boxen   <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN> und -<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img78.svg"
 ALT="$\beta_b$"></SPAN></A>
</H1>
Die 8 Substitutionsboxen sind wie folgt definiert:
<BR>
<BR><SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img192.svg"
 ALT="$\beta_0 = $"></SPAN>
</SPAN><PRE>
{
    0xce, 0xbb, 0xeb, 0x92, 0xea, 0xcb, 0x13, 0xc1,
    0xe9, 0x3a, 0xd6, 0xb2, 0xd2, 0x90, 0x17, 0xf8,
    0x42, 0x15, 0x56, 0xb4, 0x65, 0x1c, 0x88, 0x43,
    0xc5, 0x5c, 0x36, 0xba, 0xf5, 0x57, 0x67, 0x8d,
    0x31, 0xf6, 0x64, 0x58, 0x9e, 0xf4, 0x22, 0xaa,
    0x75, 0x0f, 0x02, 0xb1, 0xdf, 0x6d, 0x73, 0x4d,
    0x7c, 0x26, 0x2e, 0xf7, 0x08, 0x5d, 0x44, 0x3e,
    0x9f, 0x14, 0xc8, 0xae, 0x54, 0x10, 0xd8, 0xbc,
    0x1a, 0x6b, 0x69, 0xf3, 0xbd, 0x33, 0xab, 0xfa,
    0xd1, 0x9b, 0x68, 0x4e, 0x16, 0x95, 0x91, 0xee,
    0x4c, 0x63, 0x8e, 0x5b, 0xcc, 0x3c, 0x19, 0xa1,
    0x81, 0x49, 0x7b, 0xd9, 0x6f, 0x37, 0x60, 0xca,
    0xe7, 0x2b, 0x48, 0xfd, 0x96, 0x45, 0xfc, 0x41,
    0x12, 0x0d, 0x79, 0xe5, 0x89, 0x8c, 0xe3, 0x20,
    0x30, 0xdc, 0xb7, 0x6c, 0x4a, 0xb5, 0x3f, 0x97,
    0xd4, 0x62, 0x2d, 0x06, 0xa4, 0xa5, 0x83, 0x5f,
    0x2a, 0xda, 0xc9, 0x00, 0x7e, 0xa2, 0x55, 0xbf,
    0x11, 0xd5, 0x9c, 0xcf, 0x0e, 0x0a, 0x3d, 0x51,
    0x7d, 0x93, 0x1b, 0xfe, 0xc4, 0x47, 0x09, 0x86,
    0x0b, 0x8f, 0x9d, 0x6a, 0x07, 0xb9, 0xb0, 0x98,
    0x18, 0x32, 0x71, 0x4b, 0xef, 0x3b, 0x70, 0xa0,
    0xe4, 0x40, 0xff, 0xc3, 0xa9, 0xe6, 0x78, 0xf9,
    0x8b, 0x46, 0x80, 0x1e, 0x38, 0xe1, 0xb8, 0xa8,
    0xe0, 0x0c, 0x23, 0x76, 0x1d, 0x25, 0x24, 0x05,
    0xf1, 0x6e, 0x94, 0x28, 0x9a, 0x84, 0xe8, 0xa3,
    0x4f, 0x77, 0xd3, 0x85, 0xe2, 0x52, 0xf2, 0x82,
    0x50, 0x7a, 0x2f, 0x74, 0x53, 0xb3, 0x61, 0xaf,
    0x39, 0x35, 0xde, 0xcd, 0x1f, 0x99, 0xac, 0xad,
    0x72, 0x2c, 0xdd, 0xd0, 0x87, 0xbe, 0x5e, 0xa6,
    0xec, 0x04, 0xc6, 0x03, 0x34, 0xfb, 0xdb, 0x59,
    0xb6, 0xc2, 0x01, 0xf0, 0x5a, 0xed, 0xa7, 0x66,
    0x21, 0x7f, 0x8a, 0x27, 0xc7, 0xc0, 0x29, 0xd7
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img193.svg"
 ALT="$\beta_1 = $"></SPAN>
</SPAN><PRE>
{
    0x14, 0x9d, 0xb9, 0xe7, 0x67, 0x4c, 0x50, 0x82,
    0xca, 0xe5, 0x1d, 0x31, 0x0a, 0xc6, 0xb2, 0x51,
    0xa2, 0xd8, 0x54, 0x90, 0xd0, 0xce, 0x2d, 0x7d,
    0xc7, 0x7e, 0xd7, 0x94, 0xdf, 0x83, 0x8e, 0x6c,
    0x66, 0xd2, 0x6f, 0x16, 0x1e, 0x76, 0xfe, 0xcc,
    0xaa, 0x5a, 0x8f, 0x17, 0xbd, 0x2c, 0xac, 0xea,
    0x7b, 0x65, 0xa9, 0x10, 0xc0, 0x92, 0xee, 0xbe,
    0x6a, 0x6e, 0x48, 0x96, 0x95, 0xe9, 0x32, 0xbc,
    0xa1, 0x42, 0xd5, 0xa7, 0x81, 0xb4, 0x5f, 0xe6,
    0xc2, 0x5d, 0xad, 0x3a, 0xb7, 0x0c, 0x8d, 0x01,
    0x98, 0xfd, 0x12, 0x02, 0x75, 0x13, 0x0f, 0x6b,
    0x22, 0xe2, 0xab, 0xf7, 0x7f, 0xba, 0x97, 0xd1,
    0x64, 0xd9, 0xc4, 0x59, 0xaf, 0x23, 0x33, 0x37,
    0xde, 0xae, 0x60, 0x05, 0x63, 0xa8, 0x52, 0xa5,
    0x4e, 0xe0, 0xdd, 0x71, 0xf2, 0x24, 0x34, 0x57,
    0x47, 0xa4, 0xb3, 0x9e, 0x2f, 0xc1, 0xb8, 0xcb,
    0x2b, 0xd4, 0x0d, 0x36, 0x91, 0x8b, 0x9c, 0x26,
    0x25, 0x61, 0xa3, 0xd6, 0xeb, 0x35, 0x53, 0xf4,
    0x2e, 0x88, 0x80, 0xe4, 0x30, 0xdb, 0xfc, 0x0e,
    0x77, 0x8c, 0x93, 0xa6, 0x78, 0x06, 0xe1, 0xec,
    0xf9, 0x03, 0xa0, 0x27, 0xda, 0xef, 0x5c, 0x00,
    0x7a, 0x45, 0xe8, 0x40, 0x1a, 0x4b, 0x5e, 0x73,
    0xc3, 0xff, 0xf5, 0xf3, 0xb0, 0xc5, 0x49, 0x21,
    0xfa, 0x11, 0x39, 0x84, 0x43, 0x38, 0x85, 0x07,
    0xf0, 0x79, 0x46, 0xf8, 0xe3, 0x1f, 0x09, 0xb6,
    0xcd, 0x55, 0x1c, 0x1b, 0xfb, 0x7c, 0xed, 0x6d,
    0x15, 0x56, 0x86, 0x20, 0x68, 0x4a, 0x41, 0x4f,
    0xd3, 0x99, 0x08, 0xf6, 0x3f, 0x89, 0x62, 0x04,
    0xcf, 0xc8, 0x69, 0x9f, 0x19, 0x5b, 0x44, 0x9b,
    0x87, 0xb1, 0x3d, 0xbb, 0xdc, 0x2a, 0xbf, 0x58,
    0x3c, 0x8a, 0x18, 0x3e, 0x72, 0x0b, 0x28, 0x4d,
    0xb5, 0x9a, 0xc9, 0x74, 0x29, 0xf1, 0x3b, 0x70
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img194.svg"
 ALT="$\beta_2 = $"></SPAN>
</SPAN><PRE>
{
    0x68, 0x8d, 0xca, 0x4d, 0x73, 0x4b, 0x4e, 0x2a,
    0xd4, 0x52, 0x26, 0xb3, 0x54, 0x1e, 0x19, 0x1f,
    0x22, 0x03, 0x46, 0x3d, 0x2d, 0x4a, 0x53, 0x83,
    0x13, 0x8a, 0xb7, 0xd5, 0x25, 0x79, 0xf5, 0xbd,
    0x58, 0x2f, 0x0d, 0x02, 0xed, 0x51, 0x9e, 0x11,
    0xf2, 0x3e, 0x55, 0x5e, 0xd1, 0x16, 0x3c, 0x66,
    0x70, 0x5d, 0xf3, 0x45, 0x40, 0xcc, 0xe8, 0x94,
    0x56, 0x08, 0xce, 0x1a, 0x3a, 0xd2, 0xe1, 0xdf,
    0xb5, 0x38, 0x6e, 0x0e, 0xe5, 0xf4, 0xf9, 0x86,
    0xe9, 0x4f, 0xd6, 0x85, 0x23, 0xcf, 0x32, 0x99,
    0x31, 0x14, 0xae, 0xee, 0xc8, 0x48, 0xd3, 0x30,
    0xa1, 0x92, 0x41, 0xb1, 0x18, 0xc4, 0x2c, 0x71,
    0x72, 0x44, 0x15, 0xfd, 0x37, 0xbe, 0x5f, 0xaa,
    0x9b, 0x88, 0xd8, 0xab, 0x89, 0x9c, 0xfa, 0x60,
    0xea, 0xbc, 0x62, 0x0c, 0x24, 0xa6, 0xa8, 0xec,
    0x67, 0x20, 0xdb, 0x7c, 0x28, 0xdd, 0xac, 0x5b,
    0x34, 0x7e, 0x10, 0xf1, 0x7b, 0x8f, 0x63, 0xa0,
    0x05, 0x9a, 0x43, 0x77, 0x21, 0xbf, 0x27, 0x09,
    0xc3, 0x9f, 0xb6, 0xd7, 0x29, 0xc2, 0xeb, 0xc0,
    0xa4, 0x8b, 0x8c, 0x1d, 0xfb, 0xff, 0xc1, 0xb2,
    0x97, 0x2e, 0xf8, 0x65, 0xf6, 0x75, 0x07, 0x04,
    0x49, 0x33, 0xe4, 0xd9, 0xb9, 0xd0, 0x42, 0xc7,
    0x6c, 0x90, 0x00, 0x8e, 0x6f, 0x50, 0x01, 0xc5,
    0xda, 0x47, 0x3f, 0xcd, 0x69, 0xa2, 0xe2, 0x7a,
    0xa7, 0xc6, 0x93, 0x0f, 0x0a, 0x06, 0xe6, 0x2b,
    0x96, 0xa3, 0x1c, 0xaf, 0x6a, 0x12, 0x84, 0x39,
    0xe7, 0xb0, 0x82, 0xf7, 0xfe, 0x9d, 0x87, 0x5c,
    0x81, 0x35, 0xde, 0xb4, 0xa5, 0xfc, 0x80, 0xef,
    0xcb, 0xbb, 0x6b, 0x76, 0xba, 0x5a, 0x7d, 0x78,
    0x0b, 0x95, 0xe3, 0xad, 0x74, 0x98, 0x3b, 0x36,
    0x64, 0x6d, 0xdc, 0xf0, 0x59, 0xa9, 0x4c, 0x17,
    0x7f, 0x91, 0xb8, 0xc9, 0x57, 0x1b, 0xe0, 0x61
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img195.svg"
 ALT="$\beta_3 = $"></SPAN>
</SPAN><PRE>
{
    0xa8, 0x43, 0x5f, 0x06, 0x6b, 0x75, 0x6c, 0x59,
    0x71, 0xdf, 0x87, 0x95, 0x17, 0xf0, 0xd8, 0x09,
    0x6d, 0xf3, 0x1d, 0xcb, 0xc9, 0x4d, 0x2c, 0xaf,
    0x79, 0xe0, 0x97, 0xfd, 0x6f, 0x4b, 0x45, 0x39,
    0x3e, 0xdd, 0xa3, 0x4f, 0xb4, 0xb6, 0x9a, 0x0e,
    0x1f, 0xbf, 0x15, 0xe1, 0x49, 0xd2, 0x93, 0xc6,
    0x92, 0x72, 0x9e, 0x61, 0xd1, 0x63, 0xfa, 0xee,
    0xf4, 0x19, 0xd5, 0xad, 0x58, 0xa4, 0xbb, 0xa1,
    0xdc, 0xf2, 0x83, 0x37, 0x42, 0xe4, 0x7a, 0x32,
    0x9c, 0xcc, 0xab, 0x4a, 0x8f, 0x6e, 0x04, 0x27,
    0x2e, 0xe7, 0xe2, 0x5a, 0x96, 0x16, 0x23, 0x2b,
    0xc2, 0x65, 0x66, 0x0f, 0xbc, 0xa9, 0x47, 0x41,
    0x34, 0x48, 0xfc, 0xb7, 0x6a, 0x88, 0xa5, 0x53,
    0x86, 0xf9, 0x5b, 0xdb, 0x38, 0x7b, 0xc3, 0x1e,
    0x22, 0x33, 0x24, 0x28, 0x36, 0xc7, 0xb2, 0x3b,
    0x8e, 0x77, 0xba, 0xf5, 0x14, 0x9f, 0x08, 0x55,
    0x9b, 0x4c, 0xfe, 0x60, 0x5c, 0xda, 0x18, 0x46,
    0xcd, 0x7d, 0x21, 0xb0, 0x3f, 0x1b, 0x89, 0xff,
    0xeb, 0x84, 0x69, 0x3a, 0x9d, 0xd7, 0xd3, 0x70,
    0x67, 0x40, 0xb5, 0xde, 0x5d, 0x30, 0x91, 0xb1,
    0x78, 0x11, 0x01, 0xe5, 0x00, 0x68, 0x98, 0xa0,
    0xc5, 0x02, 0xa6, 0x74, 0x2d, 0x0b, 0xa2, 0x76,
    0xb3, 0xbe, 0xce, 0xbd, 0xae, 0xe9, 0x8a, 0x31,
    0x1c, 0xec, 0xf1, 0x99, 0x94, 0xaa, 0xf6, 0x26,
    0x2f, 0xef, 0xe8, 0x8c, 0x35, 0x03, 0xd4, 0x7f,
    0xfb, 0x05, 0xc1, 0x5e, 0x90, 0x20, 0x3d, 0x82,
    0xf7, 0xea, 0x0a, 0x0d, 0x7e, 0xf8, 0x50, 0x1a,
    0xc4, 0x07, 0x57, 0xb8, 0x3c, 0x62, 0xe3, 0xc8,
    0xac, 0x52, 0x64, 0x10, 0xd0, 0xd9, 0x13, 0x0c,
    0x12, 0x29, 0x51, 0xb9, 0xcf, 0xd6, 0x73, 0x8d,
    0x81, 0x54, 0xc0, 0xed, 0x4e, 0x44, 0xa7, 0x2a,
    0x85, 0x25, 0xe6, 0xca, 0x7c, 0x8b, 0x56, 0x80
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_0 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img196.svg"
 ALT="$-\beta_0 = $"></SPAN>
</SPAN><PRE>
{
    0x83, 0xf2, 0x2a, 0xeb, 0xe9, 0xbf, 0x7b, 0x9c,
    0x34, 0x96, 0x8d, 0x98, 0xb9, 0x69, 0x8c, 0x29,
    0x3d, 0x88, 0x68, 0x06, 0x39, 0x11, 0x4c, 0x0e,
    0xa0, 0x56, 0x40, 0x92, 0x15, 0xbc, 0xb3, 0xdc,
    0x6f, 0xf8, 0x26, 0xba, 0xbe, 0xbd, 0x31, 0xfb,
    0xc3, 0xfe, 0x80, 0x61, 0xe1, 0x7a, 0x32, 0xd2,
    0x70, 0x20, 0xa1, 0x45, 0xec, 0xd9, 0x1a, 0x5d,
    0xb4, 0xd8, 0x09, 0xa5, 0x55, 0x8e, 0x37, 0x76,
    0xa9, 0x67, 0x10, 0x17, 0x36, 0x65, 0xb1, 0x95,
    0x62, 0x59, 0x74, 0xa3, 0x50, 0x2f, 0x4b, 0xc8,
    0xd0, 0x8f, 0xcd, 0xd4, 0x3c, 0x86, 0x12, 0x1d,
    0x23, 0xef, 0xf4, 0x53, 0x19, 0x35, 0xe6, 0x7f,
    0x5e, 0xd6, 0x79, 0x51, 0x22, 0x14, 0xf7, 0x1e,
    0x4a, 0x42, 0x9b, 0x41, 0x73, 0x2d, 0xc1, 0x5c,
    0xa6, 0xa2, 0xe0, 0x2e, 0xd3, 0x28, 0xbb, 0xc9,
    0xae, 0x6a, 0xd1, 0x5a, 0x30, 0x90, 0x84, 0xf9,
    0xb2, 0x58, 0xcf, 0x7e, 0xc5, 0xcb, 0x97, 0xe4,
    0x16, 0x6c, 0xfa, 0xb0, 0x6d, 0x1f, 0x52, 0x99,
    0x0d, 0x4e, 0x03, 0x91, 0xc2, 0x4d, 0x64, 0x77,
    0x9f, 0xdd, 0xc4, 0x49, 0x8a, 0x9a, 0x24, 0x38,
    0xa7, 0x57, 0x85, 0xc7, 0x7c, 0x7d, 0xe7, 0xf6,
    0xb7, 0xac, 0x27, 0x46, 0xde, 0xdf, 0x3b, 0xd7,
    0x9e, 0x2b, 0x0b, 0xd5, 0x13, 0x75, 0xf0, 0x72,
    0xb6, 0x9d, 0x1b, 0x01, 0x3f, 0x44, 0xe5, 0x87,
    0xfd, 0x07, 0xf1, 0xab, 0x94, 0x18, 0xea, 0xfc,
    0x3a, 0x82, 0x5f, 0x05, 0x54, 0xdb, 0x00, 0x8b,
    0xe3, 0x48, 0x0c, 0xca, 0x78, 0x89, 0x0a, 0xff,
    0x3e, 0x5b, 0x81, 0xee, 0x71, 0xe2, 0xda, 0x2c,
    0xb8, 0xb5, 0xcc, 0x6e, 0xa8, 0x6b, 0xad, 0x60,
    0xc6, 0x08, 0x04, 0x02, 0xe8, 0xf5, 0x4f, 0xa4,
    0xf3, 0xc0, 0xce, 0x43, 0x25, 0x1c, 0x21, 0x33,
    0x0f, 0xaf, 0x47, 0xed, 0x66, 0x63, 0x93, 0xaa
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_1 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img197.svg"
 ALT="$-\beta_1 = $"></SPAN>
</SPAN><PRE>
{
    0xa7, 0x4f, 0x53, 0xa1, 0xdf, 0x6b, 0x9d, 0xbf,
    0xda, 0xc6, 0x0c, 0xf5, 0x4d, 0x82, 0x97, 0x56,
    0x33, 0xb9, 0x52, 0x55, 0x00, 0xd0, 0x23, 0x2b,
    0xf2, 0xe4, 0xac, 0xcb, 0xca, 0x0a, 0x24, 0xc5,
    0xd3, 0xb7, 0x58, 0x65, 0x75, 0x88, 0x87, 0xa3,
    0xf6, 0xfc, 0xed, 0x80, 0x2d, 0x16, 0x90, 0x7c,
    0x94, 0x0b, 0x3e, 0x66, 0x76, 0x8d, 0x83, 0x67,
    0xbd, 0xba, 0x4b, 0xfe, 0xf0, 0xea, 0xf3, 0xdc,
    0xab, 0xd6, 0x41, 0xbc, 0xe6, 0xa9, 0xc2, 0x78,
    0x3a, 0xb6, 0xd5, 0xad, 0x05, 0xf7, 0x70, 0xd7,
    0x06, 0x0f, 0x6e, 0x8e, 0x12, 0xc9, 0xd1, 0x77,
    0xef, 0x63, 0x29, 0xe5, 0xa6, 0x49, 0xae, 0x46,
    0x6a, 0x89, 0xde, 0x6c, 0x60, 0x31, 0x20, 0x04,
    0xd4, 0xe2, 0x38, 0x57, 0x1f, 0xcf, 0x39, 0x22,
    0xff, 0x73, 0xf4, 0xaf, 0xfb, 0x54, 0x25, 0x98,
    0x9c, 0xc1, 0xa8, 0x30, 0xcd, 0x17, 0x19, 0x5c,
    0x92, 0x44, 0x07, 0x1d, 0xbb, 0xbe, 0xd2, 0xe8,
    0x91, 0xdd, 0xf1, 0x85, 0x99, 0x4e, 0x1e, 0x2a,
    0x13, 0x84, 0x35, 0x9a, 0x1b, 0x3c, 0x3b, 0x5e,
    0x50, 0xd9, 0xf9, 0xe7, 0x86, 0x01, 0x7b, 0xe3,
    0xa2, 0x40, 0x10, 0x8a, 0x79, 0x6f, 0x9b, 0x43,
    0x6d, 0x32, 0x28, 0x5a, 0x2e, 0x4a, 0x69, 0x64,
    0xb4, 0xe9, 0x0e, 0x7a, 0x45, 0xf8, 0xc7, 0x4c,
    0x7e, 0x02, 0x5d, 0xeb, 0x3f, 0x2c, 0x37, 0xee,
    0x34, 0x7d, 0x48, 0xb0, 0x62, 0xb5, 0x0d, 0x18,
    0xe1, 0xfa, 0x08, 0x7f, 0x27, 0xc8, 0x15, 0xe0,
    0x14, 0x5f, 0x21, 0xd8, 0x81, 0x42, 0x8b, 0x1a,
    0x11, 0x61, 0xa4, 0x95, 0xec, 0x72, 0x68, 0x1c,
    0x71, 0x9e, 0x59, 0xc4, 0x93, 0x09, 0x47, 0x03,
    0xaa, 0x3d, 0x2f, 0x8c, 0x9f, 0xce, 0x36, 0xa5,
    0xc0, 0xfd, 0x74, 0xb3, 0x8f, 0xb2, 0xdb, 0x5b,
    0xc3, 0xa0, 0xb8, 0xcc, 0x96, 0x51, 0x26, 0xb1
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_2 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img198.svg"
 ALT="$-\beta_2 = $"></SPAN>
</SPAN><PRE>
{
    0xb2, 0xb6, 0x23, 0x11, 0xa7, 0x88, 0xc5, 0xa6,
    0x39, 0x8f, 0xc4, 0xe8, 0x73, 0x22, 0x43, 0xc3,
    0x82, 0x27, 0xcd, 0x18, 0x51, 0x62, 0x2d, 0xf7,
    0x5c, 0x0e, 0x3b, 0xfd, 0xca, 0x9b, 0x0d, 0x0f,
    0x79, 0x8c, 0x10, 0x4c, 0x74, 0x1c, 0x0a, 0x8e,
    0x7c, 0x94, 0x07, 0xc7, 0x5e, 0x14, 0xa1, 0x21,
    0x57, 0x50, 0x4e, 0xa9, 0x80, 0xd9, 0xef, 0x64,
    0x41, 0xcf, 0x3c, 0xee, 0x2e, 0x13, 0x29, 0xba,
    0x34, 0x5a, 0xae, 0x8a, 0x61, 0x33, 0x12, 0xb9,
    0x55, 0xa8, 0x15, 0x05, 0xf6, 0x03, 0x06, 0x49,
    0xb5, 0x25, 0x09, 0x16, 0x0c, 0x2a, 0x38, 0xfc,
    0x20, 0xf4, 0xe5, 0x7f, 0xd7, 0x31, 0x2b, 0x66,
    0x6f, 0xff, 0x72, 0x86, 0xf0, 0xa3, 0x2f, 0x78,
    0x00, 0xbc, 0xcc, 0xe2, 0xb0, 0xf1, 0x42, 0xb4,
    0x30, 0x5f, 0x60, 0x04, 0xec, 0xa5, 0xe3, 0x8b,
    0xe7, 0x1d, 0xbf, 0x84, 0x7b, 0xe6, 0x81, 0xf8,
    0xde, 0xd8, 0xd2, 0x17, 0xce, 0x4b, 0x47, 0xd6,
    0x69, 0x6c, 0x19, 0x99, 0x9a, 0x01, 0xb3, 0x85,
    0xb1, 0xf9, 0x59, 0xc2, 0x37, 0xe9, 0xc8, 0xa0,
    0xed, 0x4f, 0x89, 0x68, 0x6d, 0xd5, 0x26, 0x91,
    0x87, 0x58, 0xbd, 0xc9, 0x98, 0xdc, 0x75, 0xc0,
    0x76, 0xf5, 0x67, 0x6b, 0x7e, 0xeb, 0x52, 0xcb,
    0xd1, 0x5b, 0x9f, 0x0b, 0xdb, 0x40, 0x92, 0x1a,
    0xfa, 0xac, 0xe4, 0xe1, 0x71, 0x1f, 0x65, 0x8d,
    0x97, 0x9e, 0x95, 0x90, 0x5d, 0xb7, 0xc1, 0xaf,
    0x54, 0xfb, 0x02, 0xe0, 0x35, 0xbb, 0x3a, 0x4d,
    0xad, 0x2c, 0x3d, 0x56, 0x08, 0x1b, 0x4a, 0x93,
    0x6a, 0xab, 0xb8, 0x7a, 0xf2, 0x7d, 0xda, 0x3f,
    0xfe, 0x3e, 0xbe, 0xea, 0xaa, 0x44, 0xc6, 0xd0,
    0x36, 0x48, 0x70, 0x96, 0x77, 0x24, 0x53, 0xdf,
    0xf3, 0x83, 0x28, 0x32, 0x45, 0x1e, 0xa4, 0xd3,
    0xa2, 0x46, 0x6e, 0x9c, 0xdd, 0x63, 0xd4, 0x9d
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_3 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="img199.svg"
 ALT="$-\beta_3 = $"></SPAN>
</SPAN><PRE>
{
    0xa4, 0xa2, 0xa9, 0xc5, 0x4e, 0xc9, 0x03, 0xd9,
    0x7e, 0x0f, 0xd2, 0xad, 0xe7, 0xd3, 0x27, 0x5b,
    0xe3, 0xa1, 0xe8, 0xe6, 0x7c, 0x2a, 0x55, 0x0c,
    0x86, 0x39, 0xd7, 0x8d, 0xb8, 0x12, 0x6f, 0x28,
    0xcd, 0x8a, 0x70, 0x56, 0x72, 0xf9, 0xbf, 0x4f,
    0x73, 0xe9, 0xf7, 0x57, 0x16, 0xac, 0x50, 0xc0,
    0x9d, 0xb7, 0x47, 0x71, 0x60, 0xc4, 0x74, 0x43,
    0x6c, 0x1f, 0x93, 0x77, 0xdc, 0xce, 0x20, 0x8c,
    0x99, 0x5f, 0x44, 0x01, 0xf5, 0x1e, 0x87, 0x5e,
    0x61, 0x2c, 0x4b, 0x1d, 0x81, 0x15, 0xf4, 0x23,
    0xd6, 0xea, 0xe1, 0x67, 0xf1, 0x7f, 0xfe, 0xda,
    0x3c, 0x07, 0x53, 0x6a, 0x84, 0x9c, 0xcb, 0x02,
    0x83, 0x33, 0xdd, 0x35, 0xe2, 0x59, 0x5a, 0x98,
    0xa5, 0x92, 0x64, 0x04, 0x06, 0x10, 0x4d, 0x1c,
    0x97, 0x08, 0x31, 0xee, 0xab, 0x05, 0xaf, 0x79,
    0xa0, 0x18, 0x46, 0x6d, 0xfc, 0x89, 0xd4, 0xc7,
    0xff, 0xf0, 0xcf, 0x42, 0x91, 0xf8, 0x68, 0x0a,
    0x65, 0x8e, 0xb6, 0xfd, 0xc3, 0xef, 0x78, 0x4c,
    0xcc, 0x9e, 0x30, 0x2e, 0xbc, 0x0b, 0x54, 0x1a,
    0xa6, 0xbb, 0x26, 0x80, 0x48, 0x94, 0x32, 0x7d,
    0xa7, 0x3f, 0xae, 0x22, 0x3d, 0x66, 0xaa, 0xf6,
    0x00, 0x5d, 0xbd, 0x4a, 0xe0, 0x3b, 0xb4, 0x17,
    0x8b, 0x9f, 0x76, 0xb0, 0x24, 0x9a, 0x25, 0x63,
    0xdb, 0xeb, 0x7a, 0x3e, 0x5c, 0xb3, 0xb1, 0x29,
    0xf2, 0xca, 0x58, 0x6e, 0xd8, 0xa8, 0x2f, 0x75,
    0xdf, 0x14, 0xfb, 0x13, 0x49, 0x88, 0xb2, 0xec,
    0xe4, 0x34, 0x2d, 0x96, 0xc6, 0x3a, 0xed, 0x95,
    0x0e, 0xe5, 0x85, 0x6b, 0x40, 0x21, 0x9b, 0x09,
    0x19, 0x2b, 0x52, 0xde, 0x45, 0xa3, 0xfa, 0x51,
    0xc2, 0xb5, 0xd1, 0x90, 0xb9, 0xf3, 0x37, 0xc1,
    0x0d, 0xba, 0x41, 0x11, 0x38, 0x7b, 0xbe, 0xd0,
    0xd5, 0x69, 0x36, 0xc8, 0x62, 0x1b, 0x82, 0x8f
}
</PRE><SPAN CLASS="SMALL"></SPAN>

<P>

<H1><A ID="SECTION001000000000000000000">
Implementierung in der Programmiersprache C</A>
</H1>

<P>

<H1><A ID="SECTION001010000000000000000">
Code</A>
</H1>

<P>

<H2><A ID="SECTION001011000000000000000">
mea.h</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA 
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   mea.h
    5 */  
    6 
    7 #ifndef MEA_H
    8 #define MEA_H
    9 
   10 #include &lt;stdint.h&gt;
   11 #include &lt;stddef.h&gt;
   12 
   13 #define MEA_SUB_ROUNDS  0x06
   14 #define MEA_M_ROUNDS    0x06
   15 
   16 #define MEA_NW_STATE    0x08 
   17 #define MEA_NW_KEY      0x08 
   18 
   19 #define MEA_MS_IN_DIM   0x10
   20 #define MEA_MS_DIM      0x03
   21 #define MEA_MS_ROW      0x04
   22 
   23 #define MEA_FNC_HRSR    0x00
   24 #define MEA_FNC_SBB     0x01
   25 #define MEA_FNC_VRSC    0x02
   26 #define MEA_FNC_MXCL    0x03
   27 #define MEA_FNC_DRT     0x04 
   28 #define MEA_FNC_XRK     0x05 
   29 
   30 
   31 #define BYTE_TO_M_STATE(table, n_row, n_col) table[(n_row) + (n_col)* sizeof(uint64_t)]
   32 #define RKCON 0xc6e8e5ed7b352d4
   33  
   34 
   35 struct mea_t {
   36     uint64_t* m_state;
   37     uint8_t **r_seq;
   38     uint64_t** r_keys;
   39 };
   40 typedef struct mea_t mea_t;
   41 
   42 mea_t* mea_init();
   43 int mea_del(mea_t* mea_ctx);
   44 
   45 void print_m_state(mea_t *mea_ctx);
   46 void del_print_m_state(mea_t *mea_ctx);
   47 
   48 
   49 int mea_dimRotate(mea_t *mea_ctx, uint8_t dim);
   50 int mea_invDimRotate(mea_t *mea_ctx, uint8_t dim);
   51 
   52 int mea_verShiftColumns(mea_t *mea_ctx);
   53 int mea_invVerShiftColumns(mea_t *mea_ctx);
   54 
   55 int mea_horShiftRows(mea_t *mea_ctx);
   56 int mea_invHorShiftRows(mea_t *mea_ctx);
   57 
   58 int mea_mixColumns(mea_t *mea_ctx);
   59 int mea_invMixColumns(mea_t *mea_ctx);
   60 
   61 int mea_subBytes(mea_t *mea_ctx);  
   62 int mea_invSubBytes(mea_t *mea_ctx);
   63 
   64 int mea_generateRKeys(mea_t *mea_ctx, uint64_t *mkey);
   65 int mea_rSeqGen(mea_t *mea_ctx);
   66 
   67 int mea_blockEncipher(mea_t *mea_ctx, uint64_t *plain, uint64_t *cipher);
   68 int mea_blockDecipher(mea_t *mea_ctx, uint64_t *cipher, uint64_t *plain);
   69 
   70 #endif
</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001012000000000000000">
tables.h</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   tables.h
    5 */  
    6 
    7 #ifndef TABLES_H 
    8 #define TABLES_H
    9 
   10 #include &lt;stdint.h&gt;
   11 
   12 extern uint8_t mds_matrix[8][8];
   13 extern uint8_t mds_inv_matrix[8][8];
   14 
   15 extern uint8_t mea_sbox[4][256];
   16 extern uint8_t mea_invSbox[4][256];
   17 
   18 #endif
</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001013000000000000000">
tables.c</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA
    3  *  autor   :   Michael engel
    4  *  datei   :   tables.c
    5 */  
    6 
    7 #include &lt;stdint.h&gt;
    8 
    9 #include "mea.h"
   10 
   11 uint8_t mds_matrix[8][8] = {
   12     { 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01},
   13     { 0x01, 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05},
   14     { 0x05, 0x01, 0x08, 0x06, 0x07, 0x04, 0x01, 0x01},
   15     { 0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04, 0x01},
   16     { 0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04},
   17     { 0x04, 0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07},
   18     { 0x07, 0x04, 0x01, 0x01, 0x05, 0x01, 0x08, 0x06},
   19     { 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01, 0x08}
   20 };
   21 
   22 uint8_t mds_inv_matrix[8][8] = {
   23     { 0x2f, 0x49, 0xd7, 0xca, 0xad, 0x95, 0x76, 0xa8},
   24     { 0xa8, 0x2f, 0x49, 0xd7, 0xca, 0xad, 0x95, 0x76},
   25     { 0x76, 0xa8, 0x2f, 0x49, 0xd7, 0xca, 0xad, 0x95},
   26     { 0x95, 0x76, 0xa8, 0x2f, 0x49, 0xd7, 0xca, 0xad},
   27     { 0xad, 0x95, 0x76, 0xa8, 0x2f, 0x49, 0xd7, 0xca},
   28     { 0xca, 0xad, 0x95, 0x76, 0xa8, 0x2f, 0x49, 0xd7},
   29     { 0xd7, 0xca, 0xad, 0x95, 0x76, 0xa8, 0x2f, 0x49},
   30     { 0x49, 0xd7, 0xca, 0xad, 0x95, 0x76, 0xa8, 0x2f}
   31 };
   32 
   33 uint8_t mea_sbox[4][256] = {
   34 {
   35     0xce, 0xbb, 0xeb, 0x92, 0xea, 0xcb, 0x13, 0xc1, 0xe9, 0x3a, 0xd6, 0xb2, 0xd2, 0x90, 0x17, 0xf8, 
   36     0x42, 0x15, 0x56, 0xb4, 0x65, 0x1c, 0x88, 0x43, 0xc5, 0x5c, 0x36, 0xba, 0xf5, 0x57, 0x67, 0x8d, 
   37     0x31, 0xf6, 0x64, 0x58, 0x9e, 0xf4, 0x22, 0xaa, 0x75, 0x0f, 0x02, 0xb1, 0xdf, 0x6d, 0x73, 0x4d, 
   38     0x7c, 0x26, 0x2e, 0xf7, 0x08, 0x5d, 0x44, 0x3e, 0x9f, 0x14, 0xc8, 0xae, 0x54, 0x10, 0xd8, 0xbc, 
   39     0x1a, 0x6b, 0x69, 0xf3, 0xbd, 0x33, 0xab, 0xfa, 0xd1, 0x9b, 0x68, 0x4e, 0x16, 0x95, 0x91, 0xee, 
   40     0x4c, 0x63, 0x8e, 0x5b, 0xcc, 0x3c, 0x19, 0xa1, 0x81, 0x49, 0x7b, 0xd9, 0x6f, 0x37, 0x60, 0xca, 
   41     0xe7, 0x2b, 0x48, 0xfd, 0x96, 0x45, 0xfc, 0x41, 0x12, 0x0d, 0x79, 0xe5, 0x89, 0x8c, 0xe3, 0x20, 
   42     0x30, 0xdc, 0xb7, 0x6c, 0x4a, 0xb5, 0x3f, 0x97, 0xd4, 0x62, 0x2d, 0x06, 0xa4, 0xa5, 0x83, 0x5f, 
   43     0x2a, 0xda, 0xc9, 0x00, 0x7e, 0xa2, 0x55, 0xbf, 0x11, 0xd5, 0x9c, 0xcf, 0x0e, 0x0a, 0x3d, 0x51, 
   44     0x7d, 0x93, 0x1b, 0xfe, 0xc4, 0x47, 0x09, 0x86, 0x0b, 0x8f, 0x9d, 0x6a, 0x07, 0xb9, 0xb0, 0x98, 
   45     0x18, 0x32, 0x71, 0x4b, 0xef, 0x3b, 0x70, 0xa0, 0xe4, 0x40, 0xff, 0xc3, 0xa9, 0xe6, 0x78, 0xf9, 
   46     0x8b, 0x46, 0x80, 0x1e, 0x38, 0xe1, 0xb8, 0xa8, 0xe0, 0x0c, 0x23, 0x76, 0x1d, 0x25, 0x24, 0x05, 
   47     0xf1, 0x6e, 0x94, 0x28, 0x9a, 0x84, 0xe8, 0xa3, 0x4f, 0x77, 0xd3, 0x85, 0xe2, 0x52, 0xf2, 0x82, 
   48     0x50, 0x7a, 0x2f, 0x74, 0x53, 0xb3, 0x61, 0xaf, 0x39, 0x35, 0xde, 0xcd, 0x1f, 0x99, 0xac, 0xad, 
   49     0x72, 0x2c, 0xdd, 0xd0, 0x87, 0xbe, 0x5e, 0xa6, 0xec, 0x04, 0xc6, 0x03, 0x34, 0xfb, 0xdb, 0x59, 
   50     0xb6, 0xc2, 0x01, 0xf0, 0x5a, 0xed, 0xa7, 0x66, 0x21, 0x7f, 0x8a, 0x27, 0xc7, 0xc0, 0x29, 0xd7 
   51 },
   52 {
   53     0x14, 0x9d, 0xb9, 0xe7, 0x67, 0x4c, 0x50, 0x82, 0xca, 0xe5, 0x1d, 0x31, 0x0a, 0xc6, 0xb2, 0x51,
   54     0xa2, 0xd8, 0x54, 0x90, 0xd0, 0xce, 0x2d, 0x7d, 0xc7, 0x7e, 0xd7, 0x94, 0xdf, 0x83, 0x8e, 0x6c,
   55     0x66, 0xd2, 0x6f, 0x16, 0x1e, 0x76, 0xfe, 0xcc, 0xaa, 0x5a, 0x8f, 0x17, 0xbd, 0x2c, 0xac, 0xea,
   56     0x7b, 0x65, 0xa9, 0x10, 0xc0, 0x92, 0xee, 0xbe, 0x6a, 0x6e, 0x48, 0x96, 0x95, 0xe9, 0x32, 0xbc,
   57     0xa1, 0x42, 0xd5, 0xa7, 0x81, 0xb4, 0x5f, 0xe6, 0xc2, 0x5d, 0xad, 0x3a, 0xb7, 0x0c, 0x8d, 0x01,
   58     0x98, 0xfd, 0x12, 0x02, 0x75, 0x13, 0x0f, 0x6b, 0x22, 0xe2, 0xab, 0xf7, 0x7f, 0xba, 0x97, 0xd1,
   59     0x64, 0xd9, 0xc4, 0x59, 0xaf, 0x23, 0x33, 0x37, 0xde, 0xae, 0x60, 0x05, 0x63, 0xa8, 0x52, 0xa5,
   60     0x4e, 0xe0, 0xdd, 0x71, 0xf2, 0x24, 0x34, 0x57, 0x47, 0xa4, 0xb3, 0x9e, 0x2f, 0xc1, 0xb8, 0xcb,
   61     0x2b, 0xd4, 0x0d, 0x36, 0x91, 0x8b, 0x9c, 0x26, 0x25, 0x61, 0xa3, 0xd6, 0xeb, 0x35, 0x53, 0xf4,
   62     0x2e, 0x88, 0x80, 0xe4, 0x30, 0xdb, 0xfc, 0x0e, 0x77, 0x8c, 0x93, 0xa6, 0x78, 0x06, 0xe1, 0xec,
   63     0xf9, 0x03, 0xa0, 0x27, 0xda, 0xef, 0x5c, 0x00, 0x7a, 0x45, 0xe8, 0x40, 0x1a, 0x4b, 0x5e, 0x73,
   64     0xc3, 0xff, 0xf5, 0xf3, 0xb0, 0xc5, 0x49, 0x21, 0xfa, 0x11, 0x39, 0x84, 0x43, 0x38, 0x85, 0x07,
   65     0xf0, 0x79, 0x46, 0xf8, 0xe3, 0x1f, 0x09, 0xb6, 0xcd, 0x55, 0x1c, 0x1b, 0xfb, 0x7c, 0xed, 0x6d,
   66     0x15, 0x56, 0x86, 0x20, 0x68, 0x4a, 0x41, 0x4f, 0xd3, 0x99, 0x08, 0xf6, 0x3f, 0x89, 0x62, 0x04,
   67     0xcf, 0xc8, 0x69, 0x9f, 0x19, 0x5b, 0x44, 0x9b, 0x87, 0xb1, 0x3d, 0xbb, 0xdc, 0x2a, 0xbf, 0x58,
   68     0x3c, 0x8a, 0x18, 0x3e, 0x72, 0x0b, 0x28, 0x4d, 0xb5, 0x9a, 0xc9, 0x74, 0x29, 0xf1, 0x3b, 0x70
   69 
   70 },
   71 {
   72     0x68, 0x8d, 0xca, 0x4d, 0x73, 0x4b, 0x4e, 0x2a, 0xd4, 0x52, 0x26, 0xb3, 0x54, 0x1e, 0x19, 0x1f, 
   73     0x22, 0x03, 0x46, 0x3d, 0x2d, 0x4a, 0x53, 0x83, 0x13, 0x8a, 0xb7, 0xd5, 0x25, 0x79, 0xf5, 0xbd, 
   74     0x58, 0x2f, 0x0d, 0x02, 0xed, 0x51, 0x9e, 0x11, 0xf2, 0x3e, 0x55, 0x5e, 0xd1, 0x16, 0x3c, 0x66, 
   75     0x70, 0x5d, 0xf3, 0x45, 0x40, 0xcc, 0xe8, 0x94, 0x56, 0x08, 0xce, 0x1a, 0x3a, 0xd2, 0xe1, 0xdf, 
   76     0xb5, 0x38, 0x6e, 0x0e, 0xe5, 0xf4, 0xf9, 0x86, 0xe9, 0x4f, 0xd6, 0x85, 0x23, 0xcf, 0x32, 0x99, 
   77     0x31, 0x14, 0xae, 0xee, 0xc8, 0x48, 0xd3, 0x30, 0xa1, 0x92, 0x41, 0xb1, 0x18, 0xc4, 0x2c, 0x71, 
   78     0x72, 0x44, 0x15, 0xfd, 0x37, 0xbe, 0x5f, 0xaa, 0x9b, 0x88, 0xd8, 0xab, 0x89, 0x9c, 0xfa, 0x60, 
   79     0xea, 0xbc, 0x62, 0x0c, 0x24, 0xa6, 0xa8, 0xec, 0x67, 0x20, 0xdb, 0x7c, 0x28, 0xdd, 0xac, 0x5b, 
   80     0x34, 0x7e, 0x10, 0xf1, 0x7b, 0x8f, 0x63, 0xa0, 0x05, 0x9a, 0x43, 0x77, 0x21, 0xbf, 0x27, 0x09, 
   81     0xc3, 0x9f, 0xb6, 0xd7, 0x29, 0xc2, 0xeb, 0xc0, 0xa4, 0x8b, 0x8c, 0x1d, 0xfb, 0xff, 0xc1, 0xb2, 
   82     0x97, 0x2e, 0xf8, 0x65, 0xf6, 0x75, 0x07, 0x04, 0x49, 0x33, 0xe4, 0xd9, 0xb9, 0xd0, 0x42, 0xc7, 
   83     0x6c, 0x90, 0x00, 0x8e, 0x6f, 0x50, 0x01, 0xc5, 0xda, 0x47, 0x3f, 0xcd, 0x69, 0xa2, 0xe2, 0x7a, 
   84     0xa7, 0xc6, 0x93, 0x0f, 0x0a, 0x06, 0xe6, 0x2b, 0x96, 0xa3, 0x1c, 0xaf, 0x6a, 0x12, 0x84, 0x39, 
   85     0xe7, 0xb0, 0x82, 0xf7, 0xfe, 0x9d, 0x87, 0x5c, 0x81, 0x35, 0xde, 0xb4, 0xa5, 0xfc, 0x80, 0xef, 
   86     0xcb, 0xbb, 0x6b, 0x76, 0xba, 0x5a, 0x7d, 0x78, 0x0b, 0x95, 0xe3, 0xad, 0x74, 0x98, 0x3b, 0x36, 
   87     0x64, 0x6d, 0xdc, 0xf0, 0x59, 0xa9, 0x4c, 0x17, 0x7f, 0x91, 0xb8, 0xc9, 0x57, 0x1b, 0xe0, 0x61 
   88 },
   89 {
   90     0xa8, 0x43, 0x5f, 0x06, 0x6b, 0x75, 0x6c, 0x59, 0x71, 0xdf, 0x87, 0x95, 0x17, 0xf0, 0xd8, 0x09, 
   91     0x6d, 0xf3, 0x1d, 0xcb, 0xc9, 0x4d, 0x2c, 0xaf, 0x79, 0xe0, 0x97, 0xfd, 0x6f, 0x4b, 0x45, 0x39, 
   92     0x3e, 0xdd, 0xa3, 0x4f, 0xb4, 0xb6, 0x9a, 0x0e, 0x1f, 0xbf, 0x15, 0xe1, 0x49, 0xd2, 0x93, 0xc6, 
   93     0x92, 0x72, 0x9e, 0x61, 0xd1, 0x63, 0xfa, 0xee, 0xf4, 0x19, 0xd5, 0xad, 0x58, 0xa4, 0xbb, 0xa1, 
   94     0xdc, 0xf2, 0x83, 0x37, 0x42, 0xe4, 0x7a, 0x32, 0x9c, 0xcc, 0xab, 0x4a, 0x8f, 0x6e, 0x04, 0x27, 
   95     0x2e, 0xe7, 0xe2, 0x5a, 0x96, 0x16, 0x23, 0x2b, 0xc2, 0x65, 0x66, 0x0f, 0xbc, 0xa9, 0x47, 0x41, 
   96     0x34, 0x48, 0xfc, 0xb7, 0x6a, 0x88, 0xa5, 0x53, 0x86, 0xf9, 0x5b, 0xdb, 0x38, 0x7b, 0xc3, 0x1e, 
   97     0x22, 0x33, 0x24, 0x28, 0x36, 0xc7, 0xb2, 0x3b, 0x8e, 0x77, 0xba, 0xf5, 0x14, 0x9f, 0x08, 0x55, 
   98     0x9b, 0x4c, 0xfe, 0x60, 0x5c, 0xda, 0x18, 0x46, 0xcd, 0x7d, 0x21, 0xb0, 0x3f, 0x1b, 0x89, 0xff, 
   99     0xeb, 0x84, 0x69, 0x3a, 0x9d, 0xd7, 0xd3, 0x70, 0x67, 0x40, 0xb5, 0xde, 0x5d, 0x30, 0x91, 0xb1, 
  100     0x78, 0x11, 0x01, 0xe5, 0x00, 0x68, 0x98, 0xa0, 0xc5, 0x02, 0xa6, 0x74, 0x2d, 0x0b, 0xa2, 0x76, 
  101     0xb3, 0xbe, 0xce, 0xbd, 0xae, 0xe9, 0x8a, 0x31, 0x1c, 0xec, 0xf1, 0x99, 0x94, 0xaa, 0xf6, 0x26, 
  102     0x2f, 0xef, 0xe8, 0x8c, 0x35, 0x03, 0xd4, 0x7f, 0xfb, 0x05, 0xc1, 0x5e, 0x90, 0x20, 0x3d, 0x82, 
  103     0xf7, 0xea, 0x0a, 0x0d, 0x7e, 0xf8, 0x50, 0x1a, 0xc4, 0x07, 0x57, 0xb8, 0x3c, 0x62, 0xe3, 0xc8, 
  104     0xac, 0x52, 0x64, 0x10, 0xd0, 0xd9, 0x13, 0x0c, 0x12, 0x29, 0x51, 0xb9, 0xcf, 0xd6, 0x73, 0x8d, 
  105     0x81, 0x54, 0xc0, 0xed, 0x4e, 0x44, 0xa7, 0x2a, 0x85, 0x25, 0xe6, 0xca, 0x7c, 0x8b, 0x56, 0x80 
  106 }
  107 };
  108 
  109 
  110 uint8_t mea_invSbox[4][256] = {
  111 {
  112     0x83, 0xf2, 0x2a, 0xeb, 0xe9, 0xbf, 0x7b, 0x9c, 0x34, 0x96, 0x8d, 0x98, 0xb9, 0x69, 0x8c, 0x29, 
  113     0x3d, 0x88, 0x68, 0x06, 0x39, 0x11, 0x4c, 0x0e, 0xa0, 0x56, 0x40, 0x92, 0x15, 0xbc, 0xb3, 0xdc, 
  114     0x6f, 0xf8, 0x26, 0xba, 0xbe, 0xbd, 0x31, 0xfb, 0xc3, 0xfe, 0x80, 0x61, 0xe1, 0x7a, 0x32, 0xd2, 
  115     0x70, 0x20, 0xa1, 0x45, 0xec, 0xd9, 0x1a, 0x5d, 0xb4, 0xd8, 0x09, 0xa5, 0x55, 0x8e, 0x37, 0x76, 
  116     0xa9, 0x67, 0x10, 0x17, 0x36, 0x65, 0xb1, 0x95, 0x62, 0x59, 0x74, 0xa3, 0x50, 0x2f, 0x4b, 0xc8, 
  117     0xd0, 0x8f, 0xcd, 0xd4, 0x3c, 0x86, 0x12, 0x1d, 0x23, 0xef, 0xf4, 0x53, 0x19, 0x35, 0xe6, 0x7f, 
  118     0x5e, 0xd6, 0x79, 0x51, 0x22, 0x14, 0xf7, 0x1e, 0x4a, 0x42, 0x9b, 0x41, 0x73, 0x2d, 0xc1, 0x5c, 
  119     0xa6, 0xa2, 0xe0, 0x2e, 0xd3, 0x28, 0xbb, 0xc9, 0xae, 0x6a, 0xd1, 0x5a, 0x30, 0x90, 0x84, 0xf9, 
  120     0xb2, 0x58, 0xcf, 0x7e, 0xc5, 0xcb, 0x97, 0xe4, 0x16, 0x6c, 0xfa, 0xb0, 0x6d, 0x1f, 0x52, 0x99, 
  121     0x0d, 0x4e, 0x03, 0x91, 0xc2, 0x4d, 0x64, 0x77, 0x9f, 0xdd, 0xc4, 0x49, 0x8a, 0x9a, 0x24, 0x38, 
  122     0xa7, 0x57, 0x85, 0xc7, 0x7c, 0x7d, 0xe7, 0xf6, 0xb7, 0xac, 0x27, 0x46, 0xde, 0xdf, 0x3b, 0xd7, 
  123     0x9e, 0x2b, 0x0b, 0xd5, 0x13, 0x75, 0xf0, 0x72, 0xb6, 0x9d, 0x1b, 0x01, 0x3f, 0x44, 0xe5, 0x87, 
  124     0xfd, 0x07, 0xf1, 0xab, 0x94, 0x18, 0xea, 0xfc, 0x3a, 0x82, 0x5f, 0x05, 0x54, 0xdb, 0x00, 0x8b, 
  125     0xe3, 0x48, 0x0c, 0xca, 0x78, 0x89, 0x0a, 0xff, 0x3e, 0x5b, 0x81, 0xee, 0x71, 0xe2, 0xda, 0x2c, 
  126     0xb8, 0xb5, 0xcc, 0x6e, 0xa8, 0x6b, 0xad, 0x60, 0xc6, 0x08, 0x04, 0x02, 0xe8, 0xf5, 0x4f, 0xa4, 
  127     0xf3, 0xc0, 0xce, 0x43, 0x25, 0x1c, 0x21, 0x33, 0x0f, 0xaf, 0x47, 0xed, 0x66, 0x63, 0x93, 0xaa
  128 },
  129 {
  130     0xa7, 0x4f, 0x53, 0xa1, 0xdf, 0x6b, 0x9d, 0xbf, 0xda, 0xc6, 0x0c, 0xf5, 0x4d, 0x82, 0x97, 0x56,
  131     0x33, 0xb9, 0x52, 0x55, 0x00, 0xd0, 0x23, 0x2b, 0xf2, 0xe4, 0xac, 0xcb, 0xca, 0x0a, 0x24, 0xc5,
  132     0xd3, 0xb7, 0x58, 0x65, 0x75, 0x88, 0x87, 0xa3, 0xf6, 0xfc, 0xed, 0x80, 0x2d, 0x16, 0x90, 0x7c,
  133     0x94, 0x0b, 0x3e, 0x66, 0x76, 0x8d, 0x83, 0x67, 0xbd, 0xba, 0x4b, 0xfe, 0xf0, 0xea, 0xf3, 0xdc,
  134     0xab, 0xd6, 0x41, 0xbc, 0xe6, 0xa9, 0xc2, 0x78, 0x3a, 0xb6, 0xd5, 0xad, 0x05, 0xf7, 0x70, 0xd7,
  135     0x06, 0x0f, 0x6e, 0x8e, 0x12, 0xc9, 0xd1, 0x77, 0xef, 0x63, 0x29, 0xe5, 0xa6, 0x49, 0xae, 0x46,
  136     0x6a, 0x89, 0xde, 0x6c, 0x60, 0x31, 0x20, 0x04, 0xd4, 0xe2, 0x38, 0x57, 0x1f, 0xcf, 0x39, 0x22,
  137     0xff, 0x73, 0xf4, 0xaf, 0xfb, 0x54, 0x25, 0x98, 0x9c, 0xc1, 0xa8, 0x30, 0xcd, 0x17, 0x19, 0x5c,
  138     0x92, 0x44, 0x07, 0x1d, 0xbb, 0xbe, 0xd2, 0xe8, 0x91, 0xdd, 0xf1, 0x85, 0x99, 0x4e, 0x1e, 0x2a, 
  139     0x13, 0x84, 0x35, 0x9a, 0x1b, 0x3c, 0x3b, 0x5e, 0x50, 0xd9, 0xf9, 0xe7, 0x86, 0x01, 0x7b, 0xe3,
  140     0xa2, 0x40, 0x10, 0x8a, 0x79, 0x6f, 0x9b, 0x43, 0x6d, 0x32, 0x28, 0x5a, 0x2e, 0x4a, 0x69, 0x64,
  141     0xb4, 0xe9, 0x0e, 0x7a, 0x45, 0xf8, 0xc7, 0x4c, 0x7e, 0x02, 0x5d, 0xeb, 0x3f, 0x2c, 0x37, 0xee,
  142     0x34, 0x7d, 0x48, 0xb0, 0x62, 0xb5, 0x0d, 0x18, 0xe1, 0xfa, 0x08, 0x7f, 0x27, 0xc8, 0x15, 0xe0,
  143     0x14, 0x5f, 0x21, 0xd8, 0x81, 0x42, 0x8b, 0x1a, 0x11, 0x61, 0xa4, 0x95, 0xec, 0x72, 0x68, 0x1c,
  144     0x71, 0x9e, 0x59, 0xc4, 0x93, 0x09, 0x47, 0x03, 0xaa, 0x3d, 0x2f, 0x8c, 0x9f, 0xce, 0x36, 0xa5,
  145     0xc0, 0xfd, 0x74, 0xb3, 0x8f, 0xb2, 0xdb, 0x5b, 0xc3, 0xa0, 0xb8, 0xcc, 0x96, 0x51, 0x26, 0xb1
  146 },
  147 {
  148     0xb2, 0xb6, 0x23, 0x11, 0xa7, 0x88, 0xc5, 0xa6, 0x39, 0x8f, 0xc4, 0xe8, 0x73, 0x22, 0x43, 0xc3, 
  149     0x82, 0x27, 0xcd, 0x18, 0x51, 0x62, 0x2d, 0xf7, 0x5c, 0x0e, 0x3b, 0xfd, 0xca, 0x9b, 0x0d, 0x0f, 
  150     0x79, 0x8c, 0x10, 0x4c, 0x74, 0x1c, 0x0a, 0x8e, 0x7c, 0x94, 0x07, 0xc7, 0x5e, 0x14, 0xa1, 0x21, 
  151     0x57, 0x50, 0x4e, 0xa9, 0x80, 0xd9, 0xef, 0x64, 0x41, 0xcf, 0x3c, 0xee, 0x2e, 0x13, 0x29, 0xba, 
  152     0x34, 0x5a, 0xae, 0x8a, 0x61, 0x33, 0x12, 0xb9, 0x55, 0xa8, 0x15, 0x05, 0xf6, 0x03, 0x06, 0x49, 
  153     0xb5, 0x25, 0x09, 0x16, 0x0c, 0x2a, 0x38, 0xfc, 0x20, 0xf4, 0xe5, 0x7f, 0xd7, 0x31, 0x2b, 0x66, 
  154     0x6f, 0xff, 0x72, 0x86, 0xf0, 0xa3, 0x2f, 0x78, 0x00, 0xbc, 0xcc, 0xe2, 0xb0, 0xf1, 0x42, 0xb4, 
  155     0x30, 0x5f, 0x60, 0x04, 0xec, 0xa5, 0xe3, 0x8b, 0xe7, 0x1d, 0xbf, 0x84, 0x7b, 0xe6, 0x81, 0xf8, 
  156     0xde, 0xd8, 0xd2, 0x17, 0xce, 0x4b, 0x47, 0xd6, 0x69, 0x6c, 0x19, 0x99, 0x9a, 0x01, 0xb3, 0x85, 
  157     0xb1, 0xf9, 0x59, 0xc2, 0x37, 0xe9, 0xc8, 0xa0, 0xed, 0x4f, 0x89, 0x68, 0x6d, 0xd5, 0x26, 0x91, 
  158     0x87, 0x58, 0xbd, 0xc9, 0x98, 0xdc, 0x75, 0xc0, 0x76, 0xf5, 0x67, 0x6b, 0x7e, 0xeb, 0x52, 0xcb, 
  159     0xd1, 0x5b, 0x9f, 0x0b, 0xdb, 0x40, 0x92, 0x1a, 0xfa, 0xac, 0xe4, 0xe1, 0x71, 0x1f, 0x65, 0x8d, 
  160     0x97, 0x9e, 0x95, 0x90, 0x5d, 0xb7, 0xc1, 0xaf, 0x54, 0xfb, 0x02, 0xe0, 0x35, 0xbb, 0x3a, 0x4d, 
  161     0xad, 0x2c, 0x3d, 0x56, 0x08, 0x1b, 0x4a, 0x93, 0x6a, 0xab, 0xb8, 0x7a, 0xf2, 0x7d, 0xda, 0x3f, 
  162     0xfe, 0x3e, 0xbe, 0xea, 0xaa, 0x44, 0xc6, 0xd0, 0x36, 0x48, 0x70, 0x96, 0x77, 0x24, 0x53, 0xdf, 
  163     0xf3, 0x83, 0x28, 0x32, 0x45, 0x1e, 0xa4, 0xd3, 0xa2, 0x46, 0x6e, 0x9c, 0xdd, 0x63, 0xd4, 0x9d
  164 },
  165 {
  166     0xa4, 0xa2, 0xa9, 0xc5, 0x4e, 0xc9, 0x03, 0xd9, 0x7e, 0x0f, 0xd2, 0xad, 0xe7, 0xd3, 0x27, 0x5b, 
  167     0xe3, 0xa1, 0xe8, 0xe6, 0x7c, 0x2a, 0x55, 0x0c, 0x86, 0x39, 0xd7, 0x8d, 0xb8, 0x12, 0x6f, 0x28, 
  168     0xcd, 0x8a, 0x70, 0x56, 0x72, 0xf9, 0xbf, 0x4f, 0x73, 0xe9, 0xf7, 0x57, 0x16, 0xac, 0x50, 0xc0, 
  169     0x9d, 0xb7, 0x47, 0x71, 0x60, 0xc4, 0x74, 0x43, 0x6c, 0x1f, 0x93, 0x77, 0xdc, 0xce, 0x20, 0x8c, 
  170     0x99, 0x5f, 0x44, 0x01, 0xf5, 0x1e, 0x87, 0x5e, 0x61, 0x2c, 0x4b, 0x1d, 0x81, 0x15, 0xf4, 0x23, 
  171     0xd6, 0xea, 0xe1, 0x67, 0xf1, 0x7f, 0xfe, 0xda, 0x3c, 0x07, 0x53, 0x6a, 0x84, 0x9c, 0xcb, 0x02, 
  172     0x83, 0x33, 0xdd, 0x35, 0xe2, 0x59, 0x5a, 0x98, 0xa5, 0x92, 0x64, 0x04, 0x06, 0x10, 0x4d, 0x1c, 
  173     0x97, 0x08, 0x31, 0xee, 0xab, 0x05, 0xaf, 0x79, 0xa0, 0x18, 0x46, 0x6d, 0xfc, 0x89, 0xd4, 0xc7, 
  174     0xff, 0xf0, 0xcf, 0x42, 0x91, 0xf8, 0x68, 0x0a, 0x65, 0x8e, 0xb6, 0xfd, 0xc3, 0xef, 0x78, 0x4c, 
  175     0xcc, 0x9e, 0x30, 0x2e, 0xbc, 0x0b, 0x54, 0x1a, 0xa6, 0xbb, 0x26, 0x80, 0x48, 0x94, 0x32, 0x7d, 
  176     0xa7, 0x3f, 0xae, 0x22, 0x3d, 0x66, 0xaa, 0xf6, 0x00, 0x5d, 0xbd, 0x4a, 0xe0, 0x3b, 0xb4, 0x17, 
  177     0x8b, 0x9f, 0x76, 0xb0, 0x24, 0x9a, 0x25, 0x63, 0xdb, 0xeb, 0x7a, 0x3e, 0x5c, 0xb3, 0xb1, 0x29, 
  178     0xf2, 0xca, 0x58, 0x6e, 0xd8, 0xa8, 0x2f, 0x75, 0xdf, 0x14, 0xfb, 0x13, 0x49, 0x88, 0xb2, 0xec, 
  179     0xe4, 0x34, 0x2d, 0x96, 0xc6, 0x3a, 0xed, 0x95, 0x0e, 0xe5, 0x85, 0x6b, 0x40, 0x21, 0x9b, 0x09, 
  180     0x19, 0x2b, 0x52, 0xde, 0x45, 0xa3, 0xfa, 0x51, 0xc2, 0xb5, 0xd1, 0x90, 0xb9, 0xf3, 0x37, 0xc1, 
  181     0x0d, 0xba, 0x41, 0x11, 0x38, 0x7b, 0xbe, 0xd0, 0xd5, 0x69, 0x36, 0xc8, 0x62, 0x1b, 0x82, 0x8f
  182 }
  183 };

</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001014000000000000000">
mea.c</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA 
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   mea.c
    5 */  
    6 
    7 #include &lt;string.h&gt;
    8 #include &lt;stdlib.h&gt;
    9 #include &lt;stdint.h&gt;
   10 #include &lt;stdio.h&gt;
   11 
   12 #include "mea.h"
   13 #include "tables.h"
   14 
   15 int mea_xorRoundKey(mea_t *mea_ctx, int round);
   16 
   17 
   18 uint64_t __reverseWord(uint64_t in){
   19     return __builtin_bswap64(in);
   20 }
   21 
   22 uint8_t*  __wordsToBytes(uint64_t* in){
   23     return(uint8_t *)in;
   24 }
   25 
   26 uint64_t* __bytesToWords(uint8_t* in){
   27     return(uint64_t *)in;
   28 }
   29 
   30 uint8_t __multiplyGF(uint8_t a, uint8_t b){
   31     uint8_t res = 0, hbs = 0;
   32 
   33     for(int i = 0x08; i--;){
   34         if((b &amp; 0x01) == 1){
   35             res ^= a;
   36         }
   37 
   38         hbs = (a &amp; 0x80);
   39         a &lt;&lt;= 1;
   40 
   41         if(hbs == 0x80){
   42             a ^= 0x11d; // m(x) = x8 + x4 + x3 + x2 +1
   43         }
   44         b &gt;&gt;=1;
   45     }
   46 
   47     return res;
   48 }
   49 
   50 int __matrixMultiplywState(mea_t *mea_ctx, uint8_t in_matrix[8][8]){
   51     int n_col, n_row, b;
   52     uint8_t pr;
   53     uint64_t res;
   54     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
   55 
   56     for (n_col = 0; n_col &lt; MEA_NW_STATE; n_col++) {
   57         res = 0;
   58         for (n_row = sizeof(uint64_t) - 1; n_row &gt;= 0; n_row--) {
   59             pr = 0;
   60             for (b = sizeof(uint64_t) - 1; b &gt;= 0; b--) {
   61                 pr ^= __multiplyGF(BYTE_TO_M_STATE(pmstate, b, n_col), in_matrix[n_row][b]);
   62             }
   63             res |= (uint64_t)pr &lt;&lt; (n_row*sizeof(uint64_t));
   64         }    
   65         mea_ctx-&gt;m_state[n_col] = res;
   66     }
   67 
   68     return 0;
   69 }
   70 
   71 int __returnFncRnd(mea_t *mea_ctx, uint8_t *in, int i, int rKP, int dRP){
   72     if(in[i] == MEA_FNC_HRSR)
   73         mea_horShiftRows(mea_ctx);
   74 
   75     else if(in[i] == MEA_FNC_SBB)
   76         mea_subBytes(mea_ctx);
   77 
   78     else if(in[i] == MEA_FNC_VRSC)
   79         mea_verShiftColumns(mea_ctx);
   80 
   81     else if(in[i] == MEA_FNC_MXCL)
   82         mea_mixColumns(mea_ctx);
   83 
   84     else if(in[i] == MEA_FNC_DRT)
   85         mea_dimRotate(mea_ctx, dRP);
   86 
   87     else if(in[i] == MEA_FNC_XRK) 
   88         mea_xorRoundKey(mea_ctx, rKP);
   89 
   90     else
   91         return -1;
   92 
   93     return 1;
   94 }
   95 
   96 int __returnInvFncRnd(mea_t *mea_ctx, uint8_t *in, int i, int rKP, int dRP){
   97     if(in[i] == MEA_FNC_HRSR)
   98         mea_invHorShiftRows(mea_ctx);
   99 
  100     else if(in[i] == MEA_FNC_SBB)
  101         mea_invSubBytes(mea_ctx);
  102 
  103     else if(in[i] == MEA_FNC_VRSC)
  104         mea_invVerShiftColumns(mea_ctx);
  105 
  106     else if(in[i] == MEA_FNC_MXCL)
  107         mea_invMixColumns(mea_ctx);
  108 
  109     else if(in[i] == MEA_FNC_DRT)
  110         mea_invDimRotate(mea_ctx, dRP);
  111 
  112     else if(in[i] == MEA_FNC_XRK) 
  113         mea_xorRoundKey(mea_ctx, rKP);
  114 
  115     else
  116         return -1;
  117 
  118     return 1;
  119 }
  120 
  121 uint8_t __returnVInt(uint8_t in){
  122     if(in &lt;= 0x2A) //42
  123         return 0x00;
  124 
  125     else if(in &lt;= 0x54) //84
  126         return 0x01;
  127 
  128     else if(in &lt;= 0x7E) //126
  129         return 0x02;
  130 
  131     else if(in &lt;= 0xA8) //168
  132         return 0x03;
  133 
  134     else if(in &lt;= 0xD2) //210
  135         return 0x04;
  136 
  137     else if(in &lt;= 0xFC) //252
  138         return 0x05;
  139     else
  140         return 0x05;
  141 }
  142 
  143 mea_t *mea_init(){
  144     mea_t *mea_ctx = (mea_t *)malloc(sizeof(mea_t));
  145 
  146     if(mea_ctx == NULL)
  147         return NULL;
  148 
  149     mea_ctx-&gt;m_state = (uint64_t *)calloc(MEA_NW_STATE , sizeof(uint64_t));
  150     if(mea_ctx-&gt;m_state == NULL)
  151         return NULL;
  152 
  153     mea_ctx-&gt;r_seq = calloc(MEA_SUB_ROUNDS*MEA_M_ROUNDS/2, sizeof(uint8_t *));
  154     if(mea_ctx-&gt;r_seq == NULL)
  155         return NULL;
  156 
  157     for(int i = 0; i &lt; MEA_SUB_ROUNDS*MEA_M_ROUNDS/2; i++){
  158         mea_ctx-&gt;r_seq[i] = (uint8_t *)calloc(MEA_M_ROUNDS, sizeof(uint8_t));
  159 
  160         if(mea_ctx-&gt;r_seq[i] == NULL)
  161             return NULL;
  162     }
  163 
  164     mea_ctx-&gt;r_keys = (uint64_t **)calloc(MEA_SUB_ROUNDS*MEA_M_ROUNDS, sizeof(uint64_t **)); 
  165     if(mea_ctx-&gt;r_keys == NULL)
  166         return NULL;
  167 
  168     for(int i = 0; i &lt; MEA_SUB_ROUNDS*MEA_M_ROUNDS; i++){ 
  169         mea_ctx-&gt;r_keys[i] = (uint64_t *)calloc(MEA_NW_KEY, sizeof(uint64_t));
  170 
  171         if(mea_ctx-&gt;r_keys[i] == NULL)
  172             return NULL;
  173     }
  174 
  175     return mea_ctx;
  176 }
  177 
  178 int mea_del(mea_t *mea_ctx){
  179     free(mea_ctx-&gt;m_state);
  180     
  181     for(int i = 0; i &lt; MEA_SUB_ROUNDS*MEA_M_ROUNDS; i ++){
  182         free(mea_ctx-&gt;r_keys[i]);
  183     }
  184 
  185     for(int i = 0; i &lt; MEA_M_ROUNDS; i++){
  186         free(mea_ctx-&gt;r_seq[i]);
  187     }
  188 
  189     free(mea_ctx-&gt;r_keys);
  190     free(mea_ctx-&gt;r_seq);
  191     free(mea_ctx);
  192 
  193     mea_ctx = NULL;
  194     return 0;
  195 }
  196 
  197 int mea_generateRKeys(mea_t *mea_ctx, uint64_t *mkey){
  198     uint64_t *ntmp;  
  199     uint8_t src, dst; 
  200 
  201     for(int r = 0; r &lt; MEA_SUB_ROUNDS*MEA_M_ROUNDS; r++){
  202         int tmp ,tmp2;
  203         uint64_t *inpoi;
  204 
  205         ntmp = mea_ctx-&gt;r_keys[r];
  206         if(r == 0)
  207             inpoi = mkey;
  208 
  209         else
  210             inpoi = mea_ctx-&gt;r_keys[r-1];
  211 
  212         for(int l = 0; l &lt; MEA_NW_KEY; l++){
  213             ntmp[l] = inpoi[l] ^ RKCON;
  214         }
  215                 
  216         for(int i = 0; i &lt; MEA_NW_KEY; i++){
  217             ntmp[i] = mea_sbox[0x01][(ntmp[i] &amp; 0x00000000000000FF)] | 
  218                 ((uint64_t)mea_sbox[0x00][(ntmp[i] &amp; 0x000000000000FF00) &gt;&gt; 0x08] &lt;&lt; 0x08) |
  219                 ((uint64_t)mea_sbox[0x03][(ntmp[i] &amp; 0x0000000000FF0000) &gt;&gt; 0x10] &lt;&lt; 0x10) |
  220                 ((uint64_t)mea_sbox[0x02][(ntmp[i] &amp; 0x00000000FF000000) &gt;&gt; 0x18] &lt;&lt; 0x18) |
  221                 ((uint64_t)mea_sbox[0x03][(ntmp[i] &amp; 0x000000FF00000000) &gt;&gt; 0x20] &lt;&lt; 0x20) |
  222                 ((uint64_t)mea_sbox[0x00][(ntmp[i] &amp; 0x0000FF0000000000) &gt;&gt; 0x28] &lt;&lt; 0x28) |
  223                 ((uint64_t)mea_sbox[0x01][(ntmp[i] &amp; 0x00FF000000000000) &gt;&gt; 0x30] &lt;&lt; 0x30) |
  224                 ((uint64_t)mea_sbox[0x02][(ntmp[i] &amp; 0xFF00000000000000) &gt;&gt; 0x38] &lt;&lt; 0x38); 
  225         }
  226 
  227         uint8_t *tmp_key = __wordsToBytes(ntmp);
  228         for(int z = 0; z &lt; MEA_MS_DIM+1; z++){
  229 	        for (int i = 1; i &lt; MEA_MS_ROW; i++){
  230 		        int s = 0;
  231 		        while (s &lt; i){
  232 			        tmp = tmp_key[MEA_MS_IN_DIM*z+i];
  233 			
  234 			        for(int k = 1; k &lt; MEA_MS_ROW; k++){
  235 				        tmp_key[MEA_MS_IN_DIM*z+(MEA_MS_ROW*(k -1))+i] = tmp_key[MEA_MS_IN_DIM*z+MEA_MS_ROW*k+i];
  236 			        }
  237 
  238 			        tmp_key[MEA_MS_IN_DIM*z+(MEA_MS_ROW*(MEA_MS_ROW-1))+ i] = tmp;
  239 			        s++;
  240 		        }
  241 	        }
  242         }
  243          
  244         for(int i = 0; i &lt; MEA_MS_ROW; i++){
  245             for(int k = 0; k &lt; MEA_MS_ROW; k++){
  246                 tmp2 = tmp_key[MEA_MS_IN_DIM*0x02+MEA_MS_ROW*i+k];
  247                 tmp_key[MEA_MS_IN_DIM*0x02+MEA_MS_ROW*i+k] = tmp_key[MEA_MS_IN_DIM*0x03+MEA_MS_ROW*i+k];
  248                 tmp_key[MEA_MS_IN_DIM*0x03+MEA_MS_ROW*i+k] = tmp2; 
  249             }
  250         }
  251 
  252         ntmp = __bytesToWords(tmp_key);
  253         for(int i = 0; i &lt; MEA_NW_KEY; i++){
  254             ntmp[i] = ntmp[i] ^ inpoi[i];
  255         }
  256     }
  257 
  258     for(int i = 0; i &lt; MEA_M_ROUNDS*MEA_SUB_ROUNDS/2; i++){
  259         uint8_t *tmp = mea_ctx-&gt;r_seq[i];
  260 
  261         for(int j = 0; j &lt; MEA_SUB_ROUNDS; j++){
  262             tmp[j] = j;
  263         }
  264     }
  265     
  266     mea_rSeqGen(mea_ctx);
  267     return 0;
  268 }
  269 
  270 int mea_rSeqGen(mea_t *mea_ctx){
  271     for(int w = 0; w &lt; MEA_M_ROUNDS; w++){
  272         for(int i = 0; i &lt; MEA_M_ROUNDS*MEA_SUB_ROUNDS/2; i++){
  273             uint8_t *tmp_key = (uint8_t *)mea_ctx-&gt;r_keys[i+w];
  274             uint8_t *tmp_nseq = mea_ctx-&gt;r_seq[i];
  275 
  276             for(int j = 0; j &lt; MEA_SUB_ROUNDS-1; j++){
  277                 uint8_t tmp_p = __returnVInt(tmp_key[j]);
  278                 uint8_t tmp_op;
  279 
  280                 tmp_op = tmp_nseq[tmp_p]; 
  281                 tmp_nseq[tmp_p] = tmp_nseq[__returnVInt(tmp_key[j+1])];
  282                 tmp_nseq[__returnVInt(tmp_key[j+1])] = tmp_op;
  283             }
  284         }
  285     }
  286     return 0;
  287 }
  288 
  289 int mea_blockEncipher(mea_t *mea_ctx, uint64_t *plain, uint64_t *cipher){
  290     memcpy(mea_ctx-&gt;m_state, plain, MEA_NW_STATE * sizeof(uint64_t));
  291 
  292     for(int i = 0; i &lt; MEA_M_ROUNDS; i++){
  293         for(int j = 0; j &lt; MEA_SUB_ROUNDS; j++){
  294             if(j%2==0){
  295                 mea_horShiftRows(mea_ctx);
  296                 mea_subBytes(mea_ctx);
  297 
  298                 mea_verShiftColumns(mea_ctx);
  299                 mea_mixColumns(mea_ctx);
  300 
  301                 mea_dimRotate(mea_ctx, j/2);
  302                 mea_xorRoundKey(mea_ctx, i*MEA_M_ROUNDS+j);
  303             }
  304             else{
  305                 uint8_t *tmp_seq = mea_ctx-&gt;r_seq[((i*MEA_M_ROUNDS+j+1)/2)-1];
  306 
  307                 for(int rndR = 0; rndR &lt; MEA_SUB_ROUNDS; rndR++){
  308 
  309                      __returnFncRnd(mea_ctx, tmp_seq, rndR, i*MEA_M_ROUNDS+j, (j+1)/2);
  310                  }
  311 
  312                 mea_xorRoundKey(mea_ctx, i*MEA_M_ROUNDS+j);
  313             }
  314         }
  315     }
  316 
  317     memcpy(cipher, mea_ctx-&gt;m_state, MEA_NW_STATE * sizeof(uint64_t));
  318     return 0;
  319 }
  320 
  321 int mea_blockDecipher(mea_t *mea_ctx, uint64_t *cipher, uint64_t *plain){
  322     memcpy(mea_ctx-&gt;m_state, cipher, MEA_NW_STATE * sizeof(uint64_t));
  323 
  324     for(int i = MEA_M_ROUNDS; i &gt; 0; i--){
  325         for(int j = MEA_SUB_ROUNDS; j &gt; 0; j--){
  326 
  327             if((j-1)%2==0){
  328                 mea_xorRoundKey(mea_ctx, (i-1)*MEA_M_ROUNDS+(j-1)); 
  329                 mea_invDimRotate(mea_ctx, ((j-1)/2));
  330 
  331                 mea_invMixColumns(mea_ctx);
  332                 mea_invVerShiftColumns(mea_ctx);
  333 
  334                 mea_invSubBytes(mea_ctx);
  335                 mea_invHorShiftRows(mea_ctx);
  336             }
  337             else{
  338                 uint8_t *tmp_seq = mea_ctx-&gt;r_seq[((i-1)*MEA_M_ROUNDS+j-2)/2]; 
  339 
  340                 mea_xorRoundKey(mea_ctx, (i-1)*MEA_M_ROUNDS+(j-1)); 
  341                 for(int rndR = MEA_SUB_ROUNDS; rndR &gt; 0; rndR--){
  342 
  343                      __returnInvFncRnd(mea_ctx, tmp_seq, rndR-1, (i-1)*MEA_M_ROUNDS+(j-1), j/2); 
  344                 }
  345             }
  346 
  347         }
  348     }
  349 
  350     memcpy(plain, mea_ctx-&gt;m_state, MEA_NW_STATE * sizeof(uint64_t));
  351     return 0; 
  352 }
  353 
  354 void print_m_state(mea_t *mea_ctx){
  355     for(int i = 0; i &lt; MEA_NW_STATE; i++){
  356         printf("%llx", mea_ctx-&gt;m_state[i]);
  357     }
  358 
  359     printf("\n\n");
  360 }
  361 
  362 int mea_verShiftColumns(mea_t *mea_ctx){
  363 	uint8_t z, i, k, s, tmp;
  364     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  365 
  366     for(z = 0; z &lt; MEA_MS_DIM+1; z++){
  367 	    for (i = 1; i &lt; MEA_MS_ROW; i++){
  368 		    s = 0;
  369 		    while (s &lt; i){
  370 			    tmp = pmstate[MEA_MS_IN_DIM*z+i];
  371 			
  372 			    for(k = 1; k &lt; MEA_MS_ROW; k++){
  373 				    pmstate[MEA_MS_IN_DIM*z+(MEA_MS_ROW*(k-1))+i] = pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*k+i];
  374 			    }
  375 
  376 			    pmstate[MEA_MS_IN_DIM*z+(MEA_MS_ROW*(MEA_MS_ROW-1))+ i] = tmp;
  377 			    s++;
  378 		    }
  379 	    }
  380     }
  381 
  382     mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  383     return 0;
  384 }
  385 
  386 int mea_invVerShiftColumns(mea_t *mea_ctx){
  387 	uint8_t z, i, k, s, tmp;
  388     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  389 
  390     for(z = 0; z &lt; MEA_MS_DIM+1; z++){
  391 	    for (i = 1; i &lt; MEA_MS_ROW; i++){
  392 		    s = 0;
  393 		    while (s &lt; i){
  394 			    tmp = pmstate[MEA_MS_IN_DIM*z+(MEA_MS_ROW*(MEA_MS_ROW-1))+i];
  395 			
  396 			    for(k = MEA_MS_ROW-1; k &gt; 0; k--){
  397 				    pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*k+i] = pmstate[MEA_MS_IN_DIM*z+(MEA_MS_ROW*(k-1))+i];
  398 			    }
  399 
  400 			    pmstate[MEA_MS_IN_DIM*z+i] = tmp;
  401 			    s++;
  402 		    }
  403 	    }
  404     }
  405 
  406     mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  407     return 0;
  408 }
  409 
  410 int mea_horShiftRows(mea_t *mea_ctx){
  411 	uint8_t z, i, k, s, tmp;
  412     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  413 
  414     for(z = 0; z &lt; MEA_MS_DIM+1; z++){
  415 	    for (i = 1; i &lt; MEA_MS_ROW; i++){
  416 		    s = 0;
  417 		    while (s &lt; i){
  418 			    tmp = pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+0];
  419 			
  420 			    for(k = 1; k &lt; MEA_MS_ROW; k++){
  421 				    pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+k-1] = pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+k];
  422 			    }
  423 
  424 			    pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+MEA_MS_ROW-1] = tmp;
  425 			    s++;
  426 		    }
  427 	    }
  428     }
  429 
  430     mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  431     return 0;
  432 }
  433 
  434 int mea_invHorShiftRows(mea_t *mea_ctx){
  435 	uint8_t z, i, k, s, tmp;
  436     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  437 
  438     for(z = 0; z &lt; MEA_MS_DIM+1; z++){
  439 	    for (i = 1; i &lt; MEA_MS_ROW; i++){
  440 		    s = 0;
  441 		    while (s &lt; i){
  442 			    tmp = pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+MEA_MS_ROW-1];
  443 			
  444 			    for(k = MEA_MS_ROW-1; k &gt; 0; k--){
  445                     pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+k] = pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i+k-1];
  446 			    }
  447 
  448 			    pmstate[MEA_MS_IN_DIM*z+MEA_MS_ROW*i] = tmp;
  449 			    s++;
  450 		    }
  451 	    }
  452     }
  453 
  454     mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  455     return 0;
  456 }
  457 
  458 int mea_subBytes(mea_t *mea_ctx){
  459     for(int i = 0; i &lt; MEA_NW_STATE; i++){
  460         mea_ctx-&gt;m_state[i] = mea_sbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x00000000000000FF)] | 
  461             ((uint64_t)mea_sbox[0x01][(mea_ctx-&gt;m_state[i] &amp; 0x000000000000FF00) &gt;&gt; 0x08] &lt;&lt; 0x08) |
  462             ((uint64_t)mea_sbox[0x02][(mea_ctx-&gt;m_state[i] &amp; 0x0000000000FF0000) &gt;&gt; 0x10] &lt;&lt; 0x10) |
  463             ((uint64_t)mea_sbox[0x03][(mea_ctx-&gt;m_state[i] &amp; 0x00000000FF000000) &gt;&gt; 0x18] &lt;&lt; 0x18) |
  464             ((uint64_t)mea_sbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x000000FF00000000) &gt;&gt; 0x20] &lt;&lt; 0x20) |
  465             ((uint64_t)mea_sbox[0x01][(mea_ctx-&gt;m_state[i] &amp; 0x0000FF0000000000) &gt;&gt; 0x28] &lt;&lt; 0x28) |
  466             ((uint64_t)mea_sbox[0x02][(mea_ctx-&gt;m_state[i] &amp; 0x00FF000000000000) &gt;&gt; 0x30] &lt;&lt; 0x30) |
  467             ((uint64_t)mea_sbox[0x03][(mea_ctx-&gt;m_state[i] &amp; 0xFF00000000000000) &gt;&gt; 0x38] &lt;&lt; 0x38); 
  468     }
  469 
  470     return 0;
  471 }
  472 
  473 int mea_invSubBytes(mea_t *mea_ctx){
  474     for(int i = 0; i &lt; MEA_NW_STATE; i++){
  475         mea_ctx-&gt;m_state[i] = mea_invSbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x00000000000000FF)] | 
  476             ((uint64_t)mea_invSbox[0x01][(mea_ctx-&gt;m_state[i] &amp; 0x000000000000FF00) &gt;&gt; 0x08] &lt;&lt; 0x08) |
  477             ((uint64_t)mea_invSbox[0x02][(mea_ctx-&gt;m_state[i] &amp; 0x0000000000FF0000) &gt;&gt; 0x10] &lt;&lt; 0x10) |
  478             ((uint64_t)mea_invSbox[0x03][(mea_ctx-&gt;m_state[i] &amp; 0x00000000FF000000) &gt;&gt; 0x18] &lt;&lt; 0x18) |
  479             ((uint64_t)mea_invSbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x000000FF00000000) &gt;&gt; 0x20] &lt;&lt; 0x20) |
  480             ((uint64_t)mea_invSbox[0x01][(mea_ctx-&gt;m_state[i] &amp; 0x0000FF0000000000) &gt;&gt; 0x28] &lt;&lt; 0x28) |
  481             ((uint64_t)mea_invSbox[0x02][(mea_ctx-&gt;m_state[i] &amp; 0x00FF000000000000) &gt;&gt; 0x30] &lt;&lt; 0x30) |
  482             ((uint64_t)mea_invSbox[0x03][(mea_ctx-&gt;m_state[i] &amp; 0xFF00000000000000) &gt;&gt; 0x38] &lt;&lt; 0x38); 
  483     }
  484 
  485     return 0;
  486 }
  487 
  488 int mea_dimRotate(mea_t *mea_ctx, uint8_t dim){
  489     uint8_t i, s, k;
  490     uint8_t tmp[MEA_MS_IN_DIM];
  491     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  492    
  493     for(int l = 0; l &lt; MEA_MS_IN_DIM; l++){
  494         tmp[l] = pmstate[MEA_MS_IN_DIM*dim+l];
  495     }
  496 
  497     for(i = 0; i &lt; MEA_MS_ROW; i++){
  498         for(s = 0; s &lt; MEA_MS_ROW; s++){
  499             k = s+1;
  500             pmstate[MEA_MS_IN_DIM*dim+MEA_MS_ROW*(MEA_MS_ROW-k)+i] = tmp[MEA_MS_ROW*i+s];
  501         }
  502     }
  503 
  504     mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  505     return 0;
  506 }
  507 
  508 int mea_invDimRotate(mea_t *mea_ctx, uint8_t dim){
  509     uint8_t i, s, k;
  510     uint8_t tmp[MEA_MS_IN_DIM];
  511     uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  512    
  513     for(int l = 0; l &lt; MEA_MS_IN_DIM; l++){
  514         tmp[l] = pmstate[MEA_MS_IN_DIM*dim+l];
  515     }
  516     
  517     for(i = 0; i &lt; MEA_MS_ROW; i++){
  518         for(s = 0; s &lt; MEA_MS_ROW; s++){
  519             k = s+1;
  520             pmstate[MEA_MS_IN_DIM*dim+MEA_MS_ROW*i+s] = tmp[MEA_MS_ROW*(MEA_MS_ROW-k)+i];
  521         }
  522     }
  523 
  524     mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  525     return 0;
  526 }
  527 
  528 int mea_mixColumns(mea_t *mea_ctx){
  529     __matrixMultiplywState(mea_ctx, mds_matrix);
  530     return 0;
  531 }
  532 
  533 int mea_invMixColumns(mea_t *mea_ctx){
  534     __matrixMultiplywState(mea_ctx, mds_inv_matrix);
  535     return 0;
  536 }
  537 
  538 int mea_xorRoundKey(mea_t *mea_ctx, int round){
  539     for(int i = 0; i &lt; MEA_NW_STATE; i++){
  540         mea_ctx-&gt;m_state[i] = mea_ctx-&gt;m_state[i] ^ mea_ctx-&gt;r_keys[round][i];
  541     }
  542 
  543     return 0;
  544 }
</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001015000000000000000">
main.c</A>
</H2>
<TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA 
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   main.c
    5 */  
    6 
    7 #include &lt;stdio.h&gt;
    8 #include &lt;stdint.h&gt;
    9 
   10 #include "mea.h"
   11 #include "tables.h"
   12 
   13 int print(uint64_t *input);
   14 
   15 int main(){
   16     uint64_t plain[8] = {0xd23412e140d67e3e, 0x09671b7823148bee, 0x0c2549512aed62fb, 0x033152cb267d449e,
   17                         0xff7a6618caa9e1b8, 0x4de9e7b02bfe66e8, 0x4313b4ed71bf8735, 0x35ea92cd2f442bfc};
   18 
   19     uint64_t key[8] = {0x8ff47276b13a6427, 0xf8c902c9acb386bb, 0x9d9be5eac2575ac1, 0x5ac16c57cb722825,
   20                         0x984f111a6a1c0cf4, 0x1c379112094de69a, 0xa573aa28564707b2, 0x263c23787ef5323d};
   21 
   22     uint64_t cipher[8];
   23     uint64_t dcipher[8];
   24 
   25     mea_t* ctxenc_mea = mea_init();
   26     mea_t* ctxdec_mea = mea_init();
   27     
   28     mea_generateRKeys(ctxenc_mea, key);
   29     mea_generateRKeys(ctxdec_mea, key);
   30 
   31     mea_blockEncipher(ctxenc_mea, plain, cipher);
   32     mea_blockDecipher(ctxdec_mea, cipher, dcipher);
   33 
   34     printf("%s\n", "Daten:");
   35     print(plain);
   36 
   37     printf("%s\n", "Verschluesselte Daten:");
   38     print(cipher);
   39 
   40     printf("%s\n", "Entschluesselte Daten:");
   41     print(dcipher);
   42     
   43     mea_del(ctxenc_mea);
   44     mea_del(ctxdec_mea);
   45 
   46     return 0;
   47 }
   48 
   49 int print(uint64_t *input){
   50     for(int i = 0; i &lt; MEA_NW_STATE; i++){
   51         printf("%llx", input[i]);
   52     }
   53 
   54     printf("\n\n");
   55     return 0;
   56 }
</PRE>
</SPAN></TT>
</TD></TR></TABLE>

<P>


<P>


<P>
<BR><HR>

</BODY>
</HTML>
