<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>MEA</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="main.css">

</HEAD>

<BODY >

    <DIV class="CENTER">
<BR>
<BR>
<BR>
<BR>
</DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN  CLASS="textbf">MEA</SPAN>
</SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE">
<BR>
<BR>
        <SPAN CLASS="XXLARGE">Ein symmetrischer Blockverschlüsselungsalgorithmus
</SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE">
<BR>
<BR>
<BR>
<BR>
</SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN  CLASS="textbf">Michael Engel</SPAN>
</SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"></SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"></SPAN></SPAN></SPAN><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE">
            Autor:     </SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"> Michael Engel</SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"></SPAN></SPAN></SPAN></TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"> 
            Datum:     </SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"> 06.04.2022
        </SPAN></SPAN></SPAN></TD>
<TD CLASS="LEFT"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE"></SPAN></SPAN></SPAN></TD>
</TR>
</TABLE><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE">
</SPAN></SPAN></SPAN></DIV>
<P>
<DIV class="CENTER"><SPAN CLASS="XHUGE"><SPAN CLASS="XXLARGE"><SPAN CLASS="XLARGE">
</SPAN></SPAN></SPAN></DIV>


<P>


<P>

<H1><A ID="SECTION00100000000000000000">
Abstract</A>
</H1>

<P>
Der Blockverschlüsselungsalgorithmus MEA ist ein dynamischer symmetrischer Verschlüsseulgsalgorithmus. Er setzt auf ein dynamisches
Netzwerk und eine höhere Blockgröße als AES [#!AES:1!#], die die Sicherheit und den Algorithmus mit seiner größeren Blockgröße effizienter für 64-Bit CPUs macht. Der Algorithmus hat
eine dynamische SPN-ähnliche[#!AES:1!#] Struktur mit vergrößerten MDS-Matrizen und vier neue S-Boxen. Zudem werden verschiedenste Transformationen angewendet, damit es zur einer
besseren Obfuskation kommt. Die Schlüssellänge und die Blockgröße des Algorithmus sind äquivalent mit einer Größe von 512 Bits, was durch die Verminderung der Varietäten des Algorithmus zur einer Verminderung von
Schwachstellen führt. Außerdem wird eine neue Schlüsselerzeugung benutzt, die sehr schnell und effizient im Vergleich zu andern Schlüsselerzeugungen ist. Zudem wird ein Permutationsalgorithmus angewandt, der schnell und sicher eine
Permutation der Funktionen in Abhängigkeit vom Schlüssel erzeugt. Die Rundenanzahl vom MEA ist höher im Vergleich zu AES [#!AES:1!#], was die Sicherheit verbessern sollte.
Aktuell sind keine effizienten und effektiven Angriffe oder Schwachstellen vom MEA bekannt, weswegen MEA zur Zeit als sehr sicher einzustufen ist. Der Blockverschlüsselungsalgorithmus MEA ist auch
für Hardware-bassierte Aufgaben gedacht, da er leicht auf spezielle Hardware implementierbar ist. Die unten gegebene Implementierung ist auf Schnelligkeit ausgelegt, weswegen sie in der Programmiersprache C verfasst wurde.

<P>
<BR>

<H2><A ID="SECTION00200000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A ID="tex2html34"
  HREF="main.html#SECTION00100000000000000000">Abstract</A>
<LI><A ID="tex2html35"
  HREF="main.html#SECTION00300000000000000000">Symbole und Definitionen</A>
<LI><A ID="tex2html36"
  HREF="main.html#SECTION00400000000000000000">Generelles</A>
<UL>
<LI><A ID="tex2html37"
  HREF="main.html#SECTION00410000000000000000">Input und Output</A>
</UL>
<BR>
<LI><A ID="tex2html38"
  HREF="main.html#SECTION00500000000000000000">Verschlüsselung</A>
<UL>
<LI><A ID="tex2html39"
  HREF="main.html#SECTION00510000000000000000">Algorithmus</A>
<LI><A ID="tex2html40"
  HREF="main.html#SECTION00520000000000000000">Die horizontale Permutation <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN></A>
<LI><A ID="tex2html41"
  HREF="main.html#SECTION00530000000000000000">Das bijektive nicht lineare mapping <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img77.png"
 ALT="$\Omega_l$"></SPAN></A>
<LI><A ID="tex2html42"
  HREF="main.html#SECTION00540000000000000000">Die vertikale Permutation <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN></A>
<LI><A ID="tex2html43"
  HREF="main.html#SECTION00550000000000000000">Die lineare Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img80.png"
 ALT="$\pi_l$"></SPAN></A>
<LI><A ID="tex2html44"
  HREF="main.html#SECTION00560000000000000000">Die dimensionale Permutation <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img63.png"
 ALT="$\chi_l^{(h)}$"></SPAN></A>
<LI><A ID="tex2html45"
  HREF="main.html#SECTION00570000000000000000">Die Modulo 2 Addition (XOR-Operation) <!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></A>
</UL>
<BR>
<LI><A ID="tex2html46"
  HREF="main.html#SECTION00600000000000000000">Entschlüsselung</A>
<UL>
<LI><A ID="tex2html47"
  HREF="main.html#SECTION00610000000000000000">Algorithmus</A>
<LI><A ID="tex2html48"
  HREF="main.html#SECTION00620000000000000000">Die Inverse der horizontalen Permutation <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img135.png"
 ALT="$\hat{\vartheta_l}$"></SPAN></A>
<LI><A ID="tex2html49"
  HREF="main.html#SECTION00630000000000000000">Das bijektive nicht lineare mapping <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img136.png"
 ALT="$\hat{\Omega_l}$"></SPAN></A>
<LI><A ID="tex2html50"
  HREF="main.html#SECTION00640000000000000000">Die Inverse der vertikalen Permutation <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img138.png"
 ALT="$\hat{\Gamma_l}$"></SPAN></A>
<LI><A ID="tex2html51"
  HREF="main.html#SECTION00650000000000000000">Die Inverse der linearen Transformation <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img139.png"
 ALT="$\hat{\pi_l}$"></SPAN></A>
<LI><A ID="tex2html52"
  HREF="main.html#SECTION00660000000000000000">Die Inverse der dimensionalen Permutation <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img157.png"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN></A>
</UL>
<BR>
<LI><A ID="tex2html53"
  HREF="main.html#SECTION00700000000000000000">Rundenschlüssel Erzeugung</A>
<LI><A ID="tex2html54"
  HREF="main.html#SECTION00800000000000000000">Sequenz Shuffle Funktion <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.10ex; " SRC="img180.png"
 ALT="$\Psi^{(K_z)}$"></SPAN></A>
<LI><A ID="tex2html55"
  HREF="main.html#SECTION00900000000000000000">Weiteres</A>
<UL>
<LI><A ID="tex2html56"
  HREF="main.html#SECTION00910000000000000000">S-Boxen   <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN> und -<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN></A>
</UL>
<BR>
<LI><A ID="tex2html57"
  HREF="main.html#SECTION001000000000000000000">Implementierung in der Programmiersprache C</A>
<UL>
<LI><A ID="tex2html58"
  HREF="main.html#SECTION001010000000000000000">Code</A>
<UL>
<LI><A ID="tex2html59"
  HREF="main.html#SECTION001011000000000000000">mea.h</A>
<LI><A ID="tex2html60"
  HREF="main.html#SECTION001012000000000000000">tables.h</A>
<LI><A ID="tex2html61"
  HREF="main.html#SECTION001013000000000000000">tables.c</A>
<LI><A ID="tex2html62"
  HREF="main.html#SECTION001014000000000000000">mea.c</A>
<LI><A ID="tex2html63"
  HREF="main.html#SECTION001015000000000000000">main.c</A>
</UL></UL></UL>
<!--End of Table of Contents-->

<P>
<P>

<H1><A ID="SECTION00300000000000000000">
Symbole und Definitionen</A>
</H1>

<P>
Die follgenden Symbole und Definitionen werden benutzt im MEA.

<P>
<BR>
<BR>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">0x</TD>
<TD CLASS="LEFT">- Prefix für Nummern im Hexadezimalsystem;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img1.png"
 ALT="$\eta(x)$"></SPAN></TD>
<TD CLASS="LEFT">- das irreduzible Polynom <!-- MATH
 $x^8+x^4+x^3+x^2+1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.27ex; " SRC="img2.png"
 ALT="$x^8+x^4+x^3+x^2+1$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN></TD>
<TD CLASS="LEFT">- ein endlicher Körper mit dem irreduziblen Polynom <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img1.png"
 ALT="$\eta(x)$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN></TD>
<TD CLASS="LEFT">- die Blockgröße vom MEA, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN> = 512;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img5.png"
 ALT="$k$"></SPAN></TD>
<TD CLASS="LEFT">- die Schlüsselgröße vom MEA, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img5.png"
 ALT="$k$"></SPAN> = 512;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img6.png"
 ALT="$r$"></SPAN></TD>
<TD CLASS="LEFT">- die Anzahl der Reihen in der State-Matrix, <!-- MATH
 $r \in \{4,8\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img7.png"
 ALT="$r \in \{4,8\}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img8.png"
 ALT="$s$"></SPAN></TD>
<TD CLASS="LEFT">- die Anzahl der Spalten in der State-Matrix, <!-- MATH
 $s \in \{4,8\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img9.png"
 ALT="$s \in \{4,8\}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN></TD>
<TD CLASS="LEFT">- der Schlüssel mit Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img5.png"
 ALT="$k$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img11.png"
 ALT="$V_d$"></SPAN></TD>
<TD CLASS="LEFT">- d-Dimensionaler Vektorraum im <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img12.png"
 ALT="$GF(2)$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="img13.png"
 ALT="$d \geq 1$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.29ex; " SRC="img14.png"
 ALT="$\oplus$"></SPAN></TD>
<TD CLASS="LEFT">- die binäre exklusiv ODER Verknüpfung;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.52ex; vertical-align: -0.18ex; " SRC="img15.png"
 ALT="$\ggg$"></SPAN></TD>
<TD CLASS="LEFT">- die rechts shift Operation mit einer konstanten Länge;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.52ex; vertical-align: -0.18ex; " SRC="img16.png"
 ALT="$\lll$"></SPAN></TD>
<TD CLASS="LEFT">- die links shift Operation mit einer konstanten Länge;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN></TD>
<TD CLASS="LEFT">- die symmetrische Verschlüsselungstransformation,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">dass mapping von <!-- MATH
 $V_l \mapsto V_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img18.png"
 ALT="$V_l \mapsto V_l$"></SPAN>, abhängig von <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN></TD>
<TD CLASS="LEFT">- die symmetrische Entschlüsselungstransformation,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">dass mapping von <!-- MATH
 $V_l \mapsto V_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img18.png"
 ALT="$V_l \mapsto V_l$"></SPAN>, abhängig von <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\tau\odot\nu$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.29ex; " SRC="img20.png"
 ALT="$\tau\odot\nu$"></SPAN></TD>
<TD CLASS="LEFT">- sequentieller Ablauf der  der Transformationen <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img21.png"
 ALT="$\tau$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">und <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.10ex; " SRC="img22.png"
 ALT="$\nu$"></SPAN>, (<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.10ex; " SRC="img22.png"
 ALT="$\nu$"></SPAN> wird zuerst angewandt);</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img23.png"
 ALT="$\tau\vert\nu$"></SPAN></TD>
<TD CLASS="LEFT">- Ablauf der Transformationen <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img21.png"
 ALT="$\tau$"></SPAN> oder <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.10ex; " SRC="img22.png"
 ALT="$\nu$"></SPAN> (jede wird einmal ausgeführt),</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Permutation generiert duch die Sequenz-Shuffle Funktion <!-- MATH
 $\Psi^{K_k}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.92ex; vertical-align: -0.10ex; " SRC="img24.png"
 ALT="$\Psi^{K_k}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\mu||\lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img25.png"
 ALT="$\mu\vert\vert\lambda$"></SPAN></TD>
<TD CLASS="LEFT">- Ablauf der Packete <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.55ex; " SRC="img26.png"
 ALT="$\mu$"></SPAN> oder <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img27.png"
 ALT="$\lambda$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.55ex; " SRC="img26.png"
 ALT="$\mu$"></SPAN> wird bei</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $i \mod{2} = 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img28.png"
 ALT="$i \mod{2} = 0$"></SPAN> ausgeführt, abhängig von der Hauptrundenzahl <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.10ex; " SRC="img29.png"
 ALT="$i$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">ansonnsten wird <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img27.png"
 ALT="$\lambda$"></SPAN> ausgeführt;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\mu \doteq\lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img30.png"
 ALT="$\mu \doteq\lambda$"></SPAN></TD>
<TD CLASS="LEFT">Substitution der Elemente <!-- MATH
 $\mu \& \lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.22ex; vertical-align: -0.55ex; " SRC="img31.png"
 ALT="$\mu \&amp; \lambda$"></SPAN>,   <!-- MATH
 $\mu \mapsto \lambda$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img32.png"
 ALT="$\mu \mapsto \lambda$"></SPAN> und <!-- MATH
 $\lambda \mapsto \mu$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img33.png"
 ALT="$\lambda \mapsto \mu$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img34.png"
 ALT="$n$"></SPAN></TD>
<TD CLASS="LEFT">- die jeweilige Anzahl der Iterationen in den Transformationen</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> und <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.10ex; " SRC="img35.png"
 ALT="$n = 36$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.75ex; " SRC="img36.png"
 ALT="$mea_{l,k}$"></SPAN></TD>
<TD CLASS="LEFT">Applikation der Transformationen <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> und <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\prod\limits_{i=c}^n\tau^{(i)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 4.96ex; vertical-align: -2.13ex; " SRC="img37.png"
 ALT="$\prod\limits_{i=c}^n\tau^{(i)}$"></SPAN></TD>
<TD CLASS="LEFT">- sequentieller Ablauf der Transformationen <!-- MATH
 $\tau^{(c)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img38.png"
 ALT="$\tau^{(c)}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $\tau^{(c+1)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img39.png"
 ALT="$\tau^{(c+1)}$"></SPAN>, <!-- MATH
 $\tau^{(c+2)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img40.png"
 ALT="$\tau^{(c+2)}$"></SPAN>, ...,  <!-- MATH
 $\tau^{(n)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img41.png"
 ALT="$\tau^{(n)}$"></SPAN>, (<!-- MATH
 $\tau^{(c)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img38.png"
 ALT="$\tau^{(c)}$"></SPAN> wird zuerst angewandt);</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<H1><A ID="SECTION00400000000000000000">
Generelles</A>
</H1>

<P>
Die Verschlüsselungstransformation ist das mapping von <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN>: <!-- MATH
 $V_d \mapsto V_d$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img42.png"
 ALT="$V_d \mapsto V_d$"></SPAN>, dass
vom Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img43.png"
 ALT="$K \in V_k$"></SPAN> abhängig ist, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img44.png"
 ALT="$l = 512$"></SPAN> und <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img45.png"
 ALT="$k = 512$"></SPAN>, also <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img46.png"
 ALT="$l = k$"></SPAN>. <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> ist definiert
als eine Reihenfolge von <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img34.png"
 ALT="$n$"></SPAN> Paketen, jeweils bestehend aus <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.65ex; " SRC="img47.png"
 ALT="$\sqrt{n}$"></SPAN> Funktionen, wobei bei <!-- MATH
 $\frac{n}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.90ex; " SRC="img48.png"
 ALT="$\frac{n}{2}$"></SPAN> Paketen,
falls <!-- MATH
 $i_i \in \{0,1,2,3,...,35\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img49.png"
 ALT="$i_i \in \{0,1,2,3,...,35\}$"></SPAN>, <!-- MATH
 $i_i \mod 2 = 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img50.png"
 ALT="$i_i \mod 2 = 0$"></SPAN> (die Rundenzahl), die Reihenfolge der Funktionen im Paket konstant ist. Ansonnsten ist bei <!-- MATH
 $i_i \mod 2 \neq 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.22ex; vertical-align: -0.55ex; " SRC="img51.png"
 ALT="$i_i \mod 2 \neq 0$"></SPAN>
die Reihenfolge eine nicht vorhersehbare Permutation der <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.65ex; " SRC="img47.png"
 ALT="$\sqrt{n}$"></SPAN> Funktionen in einem dynamischen Paket, die in Abhängigkeit von <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> generiert wird. 
Die jeweiligen Funktionen nehmen eine  <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.17ex; vertical-align: -0.10ex; " SRC="img52.png"
 ALT="$r * s$"></SPAN> Matrix im <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN> als Input, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.10ex; " SRC="img53.png"
 ALT="$r = 8$"></SPAN> und <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.10ex; " SRC="img54.png"
 ALT="$s = 8$"></SPAN> und <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img55.png"
 ALT="$x \in V_l$"></SPAN>.
Die <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.17ex; vertical-align: -0.10ex; " SRC="img52.png"
 ALT="$r * s$"></SPAN> Matrix ist der Cihper State. Die Entschlüsselungstransformation <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN> in Abhängigkeit von <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.10ex; " SRC="img56.png"
 ALT="$K$"></SPAN> ist das inversive
mapping von <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> mit allen Inversiven der Funktionen.
<BR>
Alle Parameter, die <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.75ex; " SRC="img36.png"
 ALT="$mea_{l,k}$"></SPAN> definieren, sind in Tabelle 1 angegeben.
<DIV class="CENTER">
MEA
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">Blockgröße</TD>
<TD CLASS="LEFT">Rundenanzahl</TD>
<TD CLASS="LEFT">Schlüssellänge</TD>
<TD CLASS="CENTER">Anzahl der Reihen</TD>
<TD CLASS="LEFT">Anzahl der Spalten</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">512</TD>
<TD CLASS="LEFT">36</TD>
<TD CLASS="LEFT">512</TD>
<TD CLASS="CENTER">8 <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.40ex; vertical-align: -0.10ex; " SRC="img57.png"
 ALT="$\lor$"></SPAN> 4</TD>
<TD CLASS="LEFT">8 <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.40ex; vertical-align: -0.10ex; " SRC="img57.png"
 ALT="$\lor$"></SPAN> 4</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
</TR>
</TABLE>
<BR>
</DIV>
Tabelle 1

<P>

<H1><A ID="SECTION00410000000000000000">
Input und Output</A>
</H1>

<P>
Die Transformationprozesse nehmen als Input einen Block der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN>, egal ob bei der Verschlüsselung oder Entschlüsselung und geben
am Ende der Transformationen einen Block mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN> als Output. Die State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN> wird  repräsentiert durch <!-- MATH
 ${(s_{a,d,h})}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img59.png"
 ALT="${(s_{a,d,h})}$"></SPAN>,
wobei <!-- MATH
 ${(s_{a,d,h})} \in V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img60.png"
 ALT="${(s_{a,d,h})} \in V_8$"></SPAN> (bei <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN> und <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img63.png"
 ALT="$\chi_l^{(h)}$"></SPAN>) , <!-- MATH
 $a = \overline{0, r-1}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img64.png"
 ALT="$a = \overline{0, r-1}$"></SPAN>, <!-- MATH
 $d = \overline{0, s-1}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img65.png"
 ALT="$d = \overline{0, s-1}$"></SPAN> und falls <!-- MATH
 $r = 4,s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.55ex; " SRC="img66.png"
 ALT="$r = 4,s = 4$"></SPAN> ist, 
ist <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>. Ansonnsten ist <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img68.png"
 ALT="$h = 1$"></SPAN> . Die State-Matrix wird befüllt mit den Input Bytes <!-- MATH
 $B_1,B_2,B_4,\dots, B_{l/8}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.85ex; " SRC="img69.png"
 ALT="$B_1,B_2,B_4,\dots, B_{l/8}$"></SPAN> in der Row-Major Order,
dass heißt, dass als erstes die erste Reihe sequentiell von links nach rechts befüllt wird und danach die darunterliegende Reihe, bis
alle Reihen der Matrix voll sind. Falls die Input Nachricht <!-- MATH
 $P \mod{64} \neq 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.22ex; vertical-align: -0.55ex; " SRC="img70.png"
 ALT="$P \mod{64} \neq 0$"></SPAN> (in Bytes) ist, muss ein Padding Algorithmus<A ID="tex2html1"
  HREF="footnode.html#foot92"><SUP><IMG  ALT="[*]" SRC="footnote.png"></SUP></A> 
angewendet werden, damit die Nachricht in Bytes <!-- MATH
 $P \mod{64} = 0$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img71.png"
 ALT="$P \mod{64} = 0$"></SPAN> erfüllt.

<P>

<H1><A ID="SECTION00500000000000000000">
Verschlüsselung</A>
</H1>

<P>

<H1><A ID="SECTION00510000000000000000">
Algorithmus</A>
</H1>

<P>
Der Verschlüsselungsalgortihmus <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> ist wie folgt definiert:
<P><!-- MATH
 \begin{displaymath}
E_{l,k}^{(K_k)} = \prod\limits_{i=0}^{\sqrt{n}-1}\prod\limits_{t=0}^{\sqrt{n}-1} (\kappa_l^{(K_z)} \odot \chi_{l}^{(\frac{t}{2})} \odot \pi_l \odot \Gamma_l \odot \Omega_l \odot \vartheta_l
)||( \kappa_l^{(K_z)} \odot (\vartheta_l | \Omega_l | \Gamma_l | \pi_l | \chi_{l}^{(\frac{t+1}{2})} | \kappa_l^{(K_z)} )\Psi^{(K_z)}) ,
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 7.00ex; vertical-align: -2.82ex; " SRC="img72.png"
 ALT="$\displaystyle E_{l,k}^{(K_k)} = \prod\limits_{i=0}^{\sqrt{n}-1}\prod\limits_{t=...
...\pi_l \vert \chi_{l}^{(\frac{t+1}{2})} \vert \kappa_l^{(K_z)} )\Psi^{(K_z)}) , $">
</DIV><P></P>
wo <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> der Schlüssel mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img5.png"
 ALT="$k$"></SPAN> ist,
<BR><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN></TD>
<TD CLASS="LEFT">- die horizentale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img77.png"
 ALT="$\Omega_l$"></SPAN></TD>
<TD CLASS="LEFT">- das bijektive nicht lineare mapping der S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN>, <!-- MATH
 $b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img79.png"
 ALT="$b \in \{0,1,2,3\}$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">mit den State-Matrix Vektoren,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN></TD>
<TD CLASS="LEFT">- die vertikale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img80.png"
 ALT="$\pi_l$"></SPAN></TD>
<TD CLASS="LEFT">- die lineare Transformation des Cipher-State über das endliche Feld <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\chi_{l}^{(\frac{t+1}{2})}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.56ex; vertical-align: -0.74ex; " SRC="img81.png"
 ALT="$\chi_{l}^{(\frac{t+1}{2})}$"></SPAN></TD>
<TD CLASS="LEFT">- die dimensionale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.74ex; vertical-align: -0.90ex; " SRC="img82.png"
 ALT="$h = \frac{t+1}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\chi_{l}^{(\frac{t}{2})}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.50ex; vertical-align: -0.74ex; " SRC="img83.png"
 ALT="$\chi_{l}^{(\frac{t}{2})}$"></SPAN></TD>
<TD CLASS="LEFT">- die dimensionale Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h  = \frac{t}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.90ex; " SRC="img84.png"
 ALT="$h = \frac{t}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\kappa_l ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operation) mit den Rundenschlüssel</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $K_l^{(K_z)}, z = i\times6+t$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img86.png"
 ALT="$K_l^{(K_z)}, z = i\times6+t$"></SPAN> und mit der State-Matrix ist.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
<BR>
In den Funktionen <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN>, <!-- MATH
 $\chi_{l}^{((t+1)/2)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img87.png"
 ALT="$\chi_{l}^{((t+1)/2)}$"></SPAN> und <!-- MATH
 $\chi_{l}^{(t/2)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img88.png"
 ALT="$\chi_{l}^{(t/2)}$"></SPAN>, mit dem Input <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img55.png"
 ALT="$x \in V_l$"></SPAN>,
werden die Permutationen in einer dreidimensionalen <!-- MATH
 $4 \times 4 \times 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.10ex; " SRC="img89.png"
 ALT="$4 \times 4 \times 4$"></SPAN> State-Matrix ausgeführt(<!-- MATH
 $r = 4, s = 4, h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img90.png"
 ALT="$r = 4, s = 4, h = \overline{0,3}$"></SPAN>), um eine bessere Obfuskation zu erziehlen. 
Anonnsten wird immer eine zweidimensionale <!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matrix benutzt (<!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img92.png"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>). Als Rückgabe aller Funktionen wird eine zweidimensionale 
<!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matirx ausgegeben.

<P>

<H1><A ID="SECTION00520000000000000000">
Die horizontale Permutation <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN></A>
</H1>

<P>
Die horizontale Permutation <!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN> ist eine horizontale rechts shift Operation, die jede Reihe der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img93.png"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.55ex; " SRC="img66.png"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img94.png"
 ALT="$\zeta_r$"></SPAN> Positionen in einer Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img95.png"
 ALT="$r_h$"></SPAN> nach rechts bewegt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img94.png"
 ALT="$\zeta_r$"></SPAN> ist abhängig von der 
Reihennummer <!-- MATH
 $r_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img96.png"
 ALT="$r_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_r = \frac{r\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.86ex; vertical-align: -0.90ex; " SRC="img97.png"
 ALT="$\zeta_r = \frac{r\times l}{512}$"></SPAN> beschrieben werden. So wird
jede Reihe in jeder der vier Dimensionen um die Anzahl der Reihenzahl der Reihe nach rechts verschoben. So wird zum Beispiel jedes Element der Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.45ex; " SRC="img98.png"
 ALT="$r_h = 2$"></SPAN>
(in der dritten Reihe) um 2 Position nach rechts verschoben. Die Elemente, die rechts aus der Reihe gehen, werden wieder links angehangen. Dieser Prozess
wird für jeder der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{13} & x_{10} & x_{11}& x_{12}\\
    x_{22} & x_{23} & x_{20}& x_{21}\\
    x_{31} & x_{32} & x_{33}& x_{30}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.25ex; vertical-align: -5.16ex; " SRC="img99.png"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{23} &amp; x_{20}&amp; x_{21}\\
x_{31} &amp; x_{32} &amp; x_{33}&amp; x_{30}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00530000000000000000">
Das bijektive nicht lineare mapping <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img77.png"
 ALT="$\Omega_l$"></SPAN></A>
</H1>

<P>
Die bijektive nicht lineare mapping Funktion <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img77.png"
 ALT="$\Omega_l$"></SPAN> implementiert die S-Box Layer. Hier wird jedes Element <!-- MATH
 $s_{a,d,h} \in
 V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img100.png"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img92.png"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>, der State-Matrix mit <!-- MATH
 $\beta_r \mod4(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img101.png"
 ALT="$\beta_r \mod4(s_{a,d,h})$"></SPAN>, wo <!-- MATH
 $\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img102.png"
 ALT="$\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$"></SPAN>
substituiert. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN> sind Substitutionsboxen, die unten angegeben sind. Zum Beispiel wird <!-- MATH
 $s_{a,d,h} =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.75ex; " SRC="img103.png"
 ALT="$s_{a,d,h} =$"></SPAN> 0x33 zu <!-- MATH
 $\beta_0(0x33) = 0xf7$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img104.png"
 ALT="$\beta_0(0x33) = 0xf7$"></SPAN>
bei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img105.png"
 ALT="$\beta_0$"></SPAN>. Es können auch andere S-Boxen benutzt werden, solange sie sicher sind und in der beschriebenen Fuktionsweise funktionieren. Die
angegebenen S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN> wurden mit Hilfe des Papers [#!SBOX:1!#] generiert.

<P>

<H1><A ID="SECTION00540000000000000000">
Die vertikale Permutation <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN></A>
</H1>

<P>
Die vertikale Permutation <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN> ist eine vertikale down shift Operation, die jede Spalte der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img93.png"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.55ex; " SRC="img66.png"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img106.png"
 ALT="$\zeta_s$"></SPAN> Positionen in einer Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img107.png"
 ALT="$s_h$"></SPAN> nach unten bewegt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img106.png"
 ALT="$\zeta_s$"></SPAN> ist abhängig von der 
Spaltennummer <!-- MATH
 $s_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img108.png"
 ALT="$s_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_s = \frac{s\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.86ex; vertical-align: -0.90ex; " SRC="img109.png"
 ALT="$\zeta_s = \frac{s\times l}{512}$"></SPAN> beschrieben werden.
Jede Spalte in jeder der vier Dimensionen wird um die Anzahl der  der Spalten nach unten verschoben. So wird zum Beispiel jedes Element der Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.45ex; " SRC="img110.png"
 ALT="$s_h = 3$"></SPAN>
(in der vierten Spalte) um 3 Positionen nach unten verschoben. Die Elemente, die unten aus der Spalte gehen, werden wieder oben angehangen. Dieser Prozess
wird für jeder der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{31} & x_{22}& x_{13}\\
    x_{10} & x_{01} & x_{32}& x_{23}\\
    x_{20} & x_{11} & x_{02}& x_{33}\\
    x_{30} & x_{21} & x_{12}& x_{03}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.25ex; vertical-align: -5.16ex; " SRC="img111.png"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{11} &amp; x_{02}&amp; x_{33}\\
x_{30} &amp; x_{21} &amp; x_{12}&amp; x_{03}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00550000000000000000">
Die lineare Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img80.png"
 ALT="$\pi_l$"></SPAN></A>
</H1>

<P>
In der linearen Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img80.png"
 ALT="$\pi_l$"></SPAN> wird jedes Element <!-- MATH
 $s_{a,d,h} \in V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img100.png"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN> der State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8; h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img112.png"
 ALT="$r = 8, s = 8; h = 1$"></SPAN> ist, als
ein Element des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN> mit dem irreduziblen Polynom <!-- MATH
 $\eta(x) = x^8+x^4+x^3+x^2+1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img113.png"
 ALT="$\eta(x) = x^8+x^4+x^3+x^2+1$"></SPAN> dargestellt. Jedes neue Element der neuen
resultierenden Matrix <!-- MATH
 $T = (t_{a,d})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img114.png"
 ALT="$T = (t_{a,d})$"></SPAN> wird in dem <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN> mit der folgenden Gleichung berechnet:
<P><!-- MATH
 \begin{displaymath}
(t_{a,d}) = (q \ggg a) \otimes S_d
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img115.png"
 ALT="$\displaystyle (t_{a,d}) = (q \ggg a) \otimes S_d$">
</DIV><P></P>
<BR><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img116.png"
 ALT="$Q$"></SPAN> ist hier die MDS-Matrix (maximum distance separable)<A ID="tex2html2"
  HREF="footnode.html#foot249"><SUP><IMG  ALT="[*]" SRC="footnote.png"></SUP></A> <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.52ex; vertical-align: -0.55ex; " SRC="img117.png"
 ALT="$q =$"></SPAN>( 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01), die eine Matrix ist, mit
bestimmten MDS Eigentschaften, die die Diffusion des Algorithmus stärkt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img118.png"
 ALT="$S_d$"></SPAN> ist die d. Spalte der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matrix <!-- MATH
 $S = (s_{a,d,h}), r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img119.png"
 ALT="$S = (s_{a,d,h}), r = 8, s = 8, h = 1$"></SPAN>. Der Vektor <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.52ex; vertical-align: -0.55ex; " SRC="img120.png"
 ALT="$q$"></SPAN> besteht
aus Elementen des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN>, die in jeder Reihe um <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img121.png"
 ALT="$a$"></SPAN> Einheiten, die Reihenzahl nach rechts verschoben werden. Am Ende der Transformation <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img80.png"
 ALT="$\pi_l$"></SPAN> resultiert eine
neue <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matrix.

<P>

<H1><A ID="SECTION00560000000000000000">
Die dimensionale Permutation <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img63.png"
 ALT="$\chi_l^{(h)}$"></SPAN></A>
</H1>

<P>
In der dimensionalen Permutation <!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img63.png"
 ALT="$\chi_l^{(h)}$"></SPAN>, abhängig vom Parameter <!-- MATH
 $h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img122.png"
 ALT="$h \in \{0,1,2,3\}$"></SPAN>, wird die Dimension h in der <!-- MATH
 $4\times4\times4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.10ex; " SRC="img89.png"
 ALT="$4 \times 4 \times 4$"></SPAN>
State-Matrix <!-- MATH
 $S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img123.png"
 ALT="$S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$"></SPAN>, einmal um 90 Grad nach links gedreht. So wird die Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img124.png"
 ALT="$S_{a,h}$"></SPAN> zur Spalte 
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img125.png"
 ALT="$S_{d,h}$"></SPAN>, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img126.png"
 ALT="$S_{a_0,h}$"></SPAN> nach <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img127.png"
 ALT="$S_{d_3,h}$"></SPAN> verschoben wird. Bei dem konstanten Packet <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.55ex; " SRC="img26.png"
 ALT="$\mu$"></SPAN> wird die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img128.png"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.90ex; " SRC="img84.png"
 ALT="$h = \frac{t}{2}$"></SPAN> berechnet, bei der dann
die dimensionale Permutation angewendet wird. Bei dem variablen Packet <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img27.png"
 ALT="$\lambda$"></SPAN> wird die Diemension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img128.png"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.74ex; vertical-align: -0.90ex; " SRC="img82.png"
 ALT="$h = \frac{t+1}{2}$"></SPAN> berechnet. Durch diese Gleichungen werden
nicht immer die gleichen Dimensionen im Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN> permutiert. Ein Beispiel für die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img129.png"
 ALT="$h = 0$"></SPAN>:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{03} & x_{13} & x_{23}& x_{33}\\
    x_{02} & x_{12} & x_{22}& x_{32}\\
    x_{01} & x_{11} & x_{21}& x_{31}\\
    x_{00} & x_{10} & x_{20}& x_{30}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.25ex; vertical-align: -5.16ex; " SRC="img130.png"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{11} &amp; x_{21}&amp; x_{31}\\
x_{00} &amp; x_{10} &amp; x_{20}&amp; x_{30}
\end{vmatrix}
$">
</DIV><P></P>

<P>

<H1><A ID="SECTION00570000000000000000">
Die Modulo 2 Addition (XOR-Operation) <!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></A>
</H1>

<P>
Die Funktion <!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN>, welche abhänngig vom Parameter <!-- MATH
 $K_z \in V_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img131.png"
 ALT="$K_z \in V_l$"></SPAN> ist, hat als Argument die State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>
, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img55.png"
 ALT="$x \in V_l$"></SPAN>. Der Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img132.png"
 ALT="$K_z$"></SPAN>, wo <!-- MATH
 $z \in \{0,1,2,...,35\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img133.png"
 ALT="$z \in \{0,1,2,...,35\}$"></SPAN> die aktuelle Runde ist, wird wie die State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, in einer Matrix
der Größe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> dargestellt. Dann wird der Schlüssel mit der State-Matrix mit Hilfe der XOR-Operation addiert. Das Ergebnis ist eine 
State-Matrix der Größe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN>, mit der dann weitere Funktionen ausgeführt werden.

<H1><A ID="SECTION00600000000000000000">
Entschlüsselung</A>
</H1>

<P>

<H1><A ID="SECTION00610000000000000000">
Algorithmus</A>
</H1>

<P>
Der Entschlüsselungsalgortihmus <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN> ist wie folgt definiert:
<P><!-- MATH
 \begin{displaymath}
D_{l,k}^{(K_k)} = \prod\limits_{i=\sqrt{n}-1}^{0}\prod\limits_{t=\sqrt{n}-1}^{0} (\hat{\vartheta_l} \odot \hat{\Omega_l} \odot \hat{\Gamma_l} \odot \hat{\pi_l} \odot \hat{\chi_{l}^{(\frac{t}{2})}} \odot \kappa_l ^{(K_z)}
)||(\hat{\vartheta_l} | \hat{\Omega_l} | \hat{\Gamma_l} | \hat{\pi_l} | \hat{\chi_{l}^{(\frac{t+1}{2})}} | \kappa_l^{(K_z)} ) \Psi^{(K_z)} \odot \kappa_l^{(K_z)}) ,
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 7.29ex; vertical-align: -3.42ex; " SRC="img134.png"
 ALT="$\displaystyle D_{l,k}^{(K_k)} = \prod\limits_{i=\sqrt{n}-1}^{0}\prod\limits_{t=...
...rac{t+1}{2})}} \vert \kappa_l^{(K_z)} ) \Psi^{(K_z)} \odot \kappa_l^{(K_z)}) , $">
</DIV><P></P>
wo <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> der Schlüssel mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img5.png"
 ALT="$k$"></SPAN> ist,
<BR><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img135.png"
 ALT="$\hat{\vartheta_l}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der horizentalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img136.png"
 ALT="$\hat{\Omega_l}$"></SPAN></TD>
<TD CLASS="LEFT">- das bijektive nicht lineare mapping der S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img137.png"
 ALT="$-\beta_b$"></SPAN>, <!-- MATH
 $b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img79.png"
 ALT="$b \in \{0,1,2,3\}$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">mit den State-Matrix Vektoren,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img138.png"
 ALT="$\hat{\Gamma_l}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der vertikalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">dem Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img139.png"
 ALT="$\hat{\pi_l}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der linearen Transformation des Cipher-State über das</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">endliche Feld <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\chi_{l}^{(\frac{t+1}{2})}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 4.14ex; vertical-align: -0.74ex; " SRC="img140.png"
 ALT="$\hat{\chi_{l}^{(\frac{t+1}{2})}}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der dimensionalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.74ex; vertical-align: -0.90ex; " SRC="img82.png"
 ALT="$h = \frac{t+1}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\chi_{l}^{(\frac{t}{2})}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 4.08ex; vertical-align: -0.74ex; " SRC="img141.png"
 ALT="$\hat{\chi_{l}^{(\frac{t}{2})}}$"></SPAN></TD>
<TD CLASS="LEFT">- die Inverse der dimensionalen Permutation der Elemente <!-- MATH
 $(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img73.png"
 ALT="$(s_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(s_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img74.png"
 ALT="${(s_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> , mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Cipher-State <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, bei <!-- MATH
 $h = \frac{h}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.80ex; vertical-align: -0.90ex; " SRC="img142.png"
 ALT="$h = \frac{h}{2}$"></SPAN>,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\kappa_l ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operation) mit den Rundenschlüssel</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $K_l^{(K_z)}, z = i\times6+t$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img86.png"
 ALT="$K_l^{(K_z)}, z = i\times6+t$"></SPAN> und mit der State-Matrix ist .</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
Wie bei der Verschlüsselung, wird bei den Funktionen <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img135.png"
 ALT="$\hat{\vartheta_l}$"></SPAN>, <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img138.png"
 ALT="$\hat{\Gamma_l}$"></SPAN>, <!-- MATH
 $\hat{\chi_{l}^{((t+1)/2)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img143.png"
 ALT="$\hat{\chi_{l}^{((t+1)/2)}}$"></SPAN> und <!-- MATH
 $\hat{\chi_{l}^{(t/2)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img144.png"
 ALT="$\hat{\chi_{l}^{(t/2)}}$"></SPAN>, mit dem Input <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img55.png"
 ALT="$x \in V_l$"></SPAN>, die Inverse der Permutationen in einer dreidimensionalen <!-- MATH
 $4 \times 4 \times 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.10ex; " SRC="img89.png"
 ALT="$4 \times 4 \times 4$"></SPAN> State-Matrix ausgeführt (<!-- MATH
 $r = 4, s = 4, h = \overline{0,3},$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img145.png"
 ALT="$r = 4, s = 4, h = \overline{0,3},$"></SPAN>), um eine bessere Obfuskation zu erzielen. 
Ansonsten wird immer eine zweidimensionale <!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matrix benutzt (<!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img92.png"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>). Als Rückgabe aller Funktionen wird eine zweidimensionale 
<!-- MATH
 $8 \times 8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matirx ausgegeben.

<P>

<H1><A ID="SECTION00620000000000000000">
Die Inverse der horizontalen Permutation <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img135.png"
 ALT="$\hat{\vartheta_l}$"></SPAN></A>
</H1>

<P>
Die Inverse der horizontalen Permutation <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img135.png"
 ALT="$\hat{\vartheta_l}$"></SPAN> ist eine horizontale links shift Operation, die jede Reihe der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img93.png"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.55ex; " SRC="img66.png"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img94.png"
 ALT="$\zeta_r$"></SPAN> Positionen in einer Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img95.png"
 ALT="$r_h$"></SPAN> nach links bewegt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img94.png"
 ALT="$\zeta_r$"></SPAN> ist abhängig von der 
Reihennummer <!-- MATH
 $r_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img96.png"
 ALT="$r_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_r = \frac{r\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.86ex; vertical-align: -0.90ex; " SRC="img97.png"
 ALT="$\zeta_r = \frac{r\times l}{512}$"></SPAN> berechnet werden. So wird
jede Reihe in jeder der vier Dimensionen um die Anzahl der Reihenzahl der Reihe nach links verschoben. Zum Beispiel wird jedes Element der Reihe <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.45ex; " SRC="img98.png"
 ALT="$r_h = 2$"></SPAN>
(in der dritten Reihe) um 2 Positionen nach links verschoben. Die Elemente, die links aus der Reihe gehen, werden wieder rechts angehangen. Dieser Prozess
wird für jeder der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{11} & x_{12} & x_{13}& x_{10}\\
    x_{22} & x_{23} & x_{20}& x_{21}\\
    x_{33} & x_{30} & x_{31}& x_{32}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.25ex; vertical-align: -5.16ex; " SRC="img146.png"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{23} &amp; x_{20}&amp; x_{21}\\
x_{33} &amp; x_{30} &amp; x_{31}&amp; x_{32}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00630000000000000000">
Das bijektive nicht lineare mapping <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img136.png"
 ALT="$\hat{\Omega_l}$"></SPAN></A>
</H1>

<P>
Die bijektive nicht lineare mapping Funktion <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img136.png"
 ALT="$\hat{\Omega_l}$"></SPAN> ist die Inverse der S-Box Layer. Hier wird jedes Element <!-- MATH
 $s_{a,d,h} \in
 V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img100.png"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img92.png"
 ALT="$r = 8, s = 8, h = 1$"></SPAN>, der State-Matrix mit <!-- MATH
 $-\beta_r \mod4(s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img147.png"
 ALT="$-\beta_r \mod4(s_{a,d,h})$"></SPAN>, wo <!-- MATH
 $-\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img148.png"
 ALT="$-\beta_b : V_8 \mapsto V_8, b \in \{0,1,2,3\}$"></SPAN>
substituiert. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img137.png"
 ALT="$-\beta_b$"></SPAN> sind die inversen Substitutionsboxen, die unten angegeben sind. Zum Beispiel wird <!-- MATH
 $s_{a,d,h} =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.75ex; " SRC="img103.png"
 ALT="$s_{a,d,h} =$"></SPAN> 0xf7 zu <!-- MATH
 $-\beta_0(0xf7) = 0x33$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img149.png"
 ALT="$-\beta_0(0xf7) = 0x33$"></SPAN>
bei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img150.png"
 ALT="$-\beta_0$"></SPAN>. Es können auch andere S-Boxen benutzt werden, solange sie die korrekten Inversen der S-Boxen sind.

<P>

<H1><A ID="SECTION00640000000000000000">
Die Inverse der vertikalen Permutation <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img138.png"
 ALT="$\hat{\Gamma_l}$"></SPAN></A>
</H1>

<P>
Die Inverse der vertikalen Permutation <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img138.png"
 ALT="$\hat{\Gamma_l}$"></SPAN> ist eine vertikale up shift Operation, die jede Spalte der drei dimensionalen State-Matrix <!-- MATH
 $S = (s_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img93.png"
 ALT="$S = (s_{a,d,h})$"></SPAN>, 
<!-- MATH
 $r = 4, s = 4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.55ex; " SRC="img66.png"
 ALT="$r = 4,s = 4$"></SPAN>, <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, um <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img106.png"
 ALT="$\zeta_s$"></SPAN> Positionen in einer Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img107.png"
 ALT="$s_h$"></SPAN> nach oben verschiebt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img106.png"
 ALT="$\zeta_s$"></SPAN> ist abhängig von der 
Spaltennummer <!-- MATH
 $s_h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img108.png"
 ALT="$s_h \in \{0,1,2,3\}$"></SPAN>, die Blockgröße <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img4.png"
 ALT="$l$"></SPAN> und kann mit der Formel <!-- MATH
 $\zeta_s = \frac{s\times l}{512}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.86ex; vertical-align: -0.90ex; " SRC="img109.png"
 ALT="$\zeta_s = \frac{s\times l}{512}$"></SPAN> beschrieben werden. So wird
jede Spalte in jeder der drei Dimensionen um die Anzahl der Spaltenzahl der Spalten nach oben verschoben. Zum Beispiel wird jedes Element der Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.45ex; " SRC="img110.png"
 ALT="$s_h = 3$"></SPAN>
(in der vierten Spalte) um 3 Positionen nach oben verschoben. Die Elemente, die oben aus der Spalte gehen, werden wieder unten angehangen. Dieser Prozess
wird für jede der <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN> Dimensionen durchgeführt.
<BR>
Ein Beispiel für die Dimension h = 0:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{00} & x_{11} & x_{22}& x_{33}\\
    x_{10} & x_{21} & x_{32}& x_{03}\\
    x_{20} & x_{31} & x_{02}& x_{13}\\
    x_{30} & x_{01} & x_{12}& x_{23}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.25ex; vertical-align: -5.16ex; " SRC="img151.png"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{31} &amp; x_{02}&amp; x_{13}\\
x_{30} &amp; x_{01} &amp; x_{12}&amp; x_{23}
\end{vmatrix}
$">
</DIV><P></P>
<H1><A ID="SECTION00650000000000000000">
Die Inverse der linearen Transformation <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img139.png"
 ALT="$\hat{\pi_l}$"></SPAN></A>
</H1>

<P>
In der Inverse der linearen Transformation <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img139.png"
 ALT="$\hat{\pi_l}$"></SPAN> wird jedes Element <!-- MATH
 $s_{a,d,h} \in V_8$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img100.png"
 ALT="$s_{a,d,h} \in
V_8$"></SPAN> der State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN>, wobei <!-- MATH
 $r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img92.png"
 ALT="$r = 8, s = 8, h = 1$"></SPAN> ist, als
ein Element des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN> mit dem irreduziblen Polynom <!-- MATH
 $\eta(x) = x^8+x^4+x^3+x^2+1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img113.png"
 ALT="$\eta(x) = x^8+x^4+x^3+x^2+1$"></SPAN> dargestellt. Jedes neue Element der neuen
resultierenden Matrix <!-- MATH
 $\hat{T} = (\hat{t}_{a,d})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.86ex; vertical-align: -0.75ex; " SRC="img152.png"
 ALT="$\hat{T} = (\hat{t}_{a,d})$"></SPAN> wird in dem <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN> mit der folgenden Gleichung berechnet:
<P><!-- MATH
 \begin{displaymath}
(\hat{t}_{a,d}) = (\hat{q} \lll a) \otimes S_d
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 2.68ex; vertical-align: -0.75ex; " SRC="img153.png"
 ALT="$\displaystyle (\hat{t}_{a,d}) = (\hat{q} \lll a) \otimes S_d$">
</DIV><P></P>
<BR><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.55ex; " SRC="img154.png"
 ALT="$\hat{Q}$"></SPAN> ist hier die Inverse MDS-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img155.png"
 ALT="$\hat{q} =$"></SPAN>(0x2f,0x49,0xd7,0xca,0xad,0x95,0x76,0xa8), die auch die MDS Eigenschaften besitzt.
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img118.png"
 ALT="$S_d$"></SPAN> ist die d. Spalte der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matrix <!-- MATH
 $S = (s_{a,d,h}), r = 8, s = 8, h = 1$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img119.png"
 ALT="$S = (s_{a,d,h}), r = 8, s = 8, h = 1$"></SPAN>. Der Vektor <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img156.png"
 ALT="$\hat{q}$"></SPAN> besteht
 nur aus Elementen des endlichen Feldes <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.68ex; " SRC="img3.png"
 ALT="$GF(2^8)$"></SPAN>, die in jeder Reihe um <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img121.png"
 ALT="$a$"></SPAN> Einheiten, die Reihenzahl nach rechts verschoben werden. Am Ende der Inverse resultiert eine
neue <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN> State-Matrix.

<P>

<H1><A ID="SECTION00660000000000000000">
Die Inverse der dimensionalen Permutation <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img157.png"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN></A>
</H1>

<P>
In der Inverse der dimensionalen Permutation <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img157.png"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN>, abhängig vom Parameter <!-- MATH
 $h \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img122.png"
 ALT="$h \in \{0,1,2,3\}$"></SPAN>, wird die Dimension h in der <!-- MATH
 $4\times4\times4$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.10ex; " SRC="img89.png"
 ALT="$4 \times 4 \times 4$"></SPAN>
State-Matirx <!-- MATH
 $S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img123.png"
 ALT="$S = (s_{a,d,h}), r = 4, s = 4, h = \overline{0,3}$"></SPAN>, zurück 90 Grad nach rechts gedreht. So wird wird die Spalte <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img125.png"
 ALT="$S_{d,h}$"></SPAN> zur Reihe 
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img124.png"
 ALT="$S_{a,h}$"></SPAN>, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img158.png"
 ALT="$S_{d_0,h}$"></SPAN> nach <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.27ex; vertical-align: -0.75ex; " SRC="img159.png"
 ALT="$S_{a_3,h}$"></SPAN> verschoben wird. Bei dem konstanten Packet <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.57ex; vertical-align: -0.55ex; " SRC="img26.png"
 ALT="$\mu$"></SPAN> , wird die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img128.png"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.68ex; vertical-align: -0.90ex; " SRC="img84.png"
 ALT="$h = \frac{t}{2}$"></SPAN> berechnet, bei der dann
die Inverse der dimensionalen Permutation angewendet wird. Bei den variablen Packeten <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img27.png"
 ALT="$\lambda$"></SPAN> wird die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img128.png"
 ALT="$h$"></SPAN> mit <!-- MATH
 $h  = \frac{t+1}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.74ex; vertical-align: -0.90ex; " SRC="img82.png"
 ALT="$h = \frac{t+1}{2}$"></SPAN> berechnet. Durch diese Gleichungen 
wird die korrekte Inverse der dimensionalen Permutation berechnet. Ein Beispiel für die Dimension <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img129.png"
 ALT="$h = 0$"></SPAN>:
<P><!-- MATH
 \begin{displaymath}
(S_{a,d,h}) =
  \begin{vmatrix}
    x_{00} & x_{01} & x_{02}& x_{03}\\
    x_{10} & x_{11} & x_{12}& x_{13}\\
    x_{20} & x_{21} & x_{22}& x_{23}\\
    x_{30} & x_{31} & x_{32}& x_{33}
  \end{vmatrix} \Rightarrow
  \begin{vmatrix}
    x_{30} & x_{20} & x_{10}& x_{00}\\
    x_{31} & x_{21} & x_{11}& x_{01}\\
    x_{32} & x_{22} & x_{12}& x_{02}\\
    x_{33} & x_{23} & x_{13}& x_{03}
  \end{vmatrix} 
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 11.25ex; vertical-align: -5.16ex; " SRC="img160.png"
 ALT="$\displaystyle (S_{a,d,h}) =
\begin{vmatrix}
x_{00} &amp; x_{01} &amp; x_{02}&amp; x_{03}...
...&amp; x_{22} &amp; x_{12}&amp; x_{02}\\
x_{33} &amp; x_{23} &amp; x_{13}&amp; x_{03}
\end{vmatrix}
$">
</DIV><P></P>

<P>

<H1><A ID="SECTION00700000000000000000">
Rundenschlüssel Erzeugung</A>
</H1>

<P>
Die Rundenschlüssel <!-- MATH
 $K_z, z \in \{0,1,2,...,35\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img161.png"
 ALT="$K_z, z \in \{0,1,2,...,35\}$"></SPAN> haben die gleiche Größe wie die Blocklänge <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.10ex; vertical-align: -0.55ex; " SRC="img162.png"
 ALT="$l, l = k$"></SPAN>. In der Funktion <!-- MATH
 $\kappa_l ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN>  werden die Rundenschlüssel in der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.15ex; " SRC="img91.png"
 ALT="$8 \times 8$"></SPAN>
State-Matrix <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img58.png"
 ALT="$S$"></SPAN> mit der XOR-Operation zusammenaddiert. Da es aber nicht sicher wäre, für jede Runde der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.63ex; vertical-align: -0.10ex; " SRC="img35.png"
 ALT="$n = 36$"></SPAN> Runden den gleichen
Schlüssel zu benutzen, werden 36 Rundenschlüssel mit der folgenden Gleichung <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img163.png"
 ALT="$G^{(K_k)}$"></SPAN> erzeugt. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img163.png"
 ALT="$G^{(K_k)}$"></SPAN> ist abhängig von dem Master-Schlüssel
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> und von dem temporären Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img164.png"
 ALT="$\alpha$"></SPAN>, der bei der ersten Runde <!-- MATH
 $\alpha = K_k$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img165.png"
 ALT="$\alpha = K_k$"></SPAN> ist, und bei den restlichen 35 Schlüssel,
<!-- MATH
 $\alpha = K_{-z}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.53ex; " SRC="img166.png"
 ALT="$\alpha = K_{-z}$"></SPAN> ist, wobei <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.53ex; " SRC="img167.png"
 ALT="$K_{-z}$"></SPAN> der vorherige Rundenschlüssl ist. Somit ist <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img163.png"
 ALT="$G^{(K_k)}$"></SPAN>:

<P>
<P><!-- MATH
 \begin{displaymath}
G^{(K_k)} = \hat{\kappa_k^{(\alpha)}} \odot \digamma_k \odot \Gamma_k \odot \Omega_k^{(rh)} \odot \kappa_k^{(\alpha)},
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img168.png"
 ALT="$\displaystyle G^{(K_k)} = \hat{\kappa_k^{(\alpha)}} \odot \digamma_k \odot \Gamma_k \odot \Omega_k^{(rh)} \odot \kappa_k^{(\alpha)}, $">
</DIV><P></P>
<BR>
wo <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> der Master-Schlüssel mit der Länge <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img5.png"
 ALT="$k$"></SPAN> ist,
<BR><TABLE class="PAD " style="">
<TR><TD CLASS="LEFT"><!-- MATH
 $\kappa_k ^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img169.png"
 ALT="$\kappa_k ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operaton) mit dem Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img164.png"
 ALT="$\alpha$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">und der RCON Konstanten <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img170.png"
 ALT="$m$"></SPAN> = 0xc6e8e5ed7b352d4 ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\hat{\kappa_k ^{(K_z)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img171.png"
 ALT="$\hat{\kappa_k ^{(K_z)}}$"></SPAN></TD>
<TD CLASS="LEFT">- eine Modulo 2 Addition (XOR-Operaton) mit dem Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img164.png"
 ALT="$\alpha$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">und den Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img132.png"
 ALT="$K_z$"></SPAN> ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\Omega_k^{(rh)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img172.png"
 ALT="$\Omega_k^{(rh)}$"></SPAN></TD>
<TD CLASS="LEFT">- das bijektive nicht lineare mapping der S-Boxen <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN>, <!-- MATH
 $b \in \{0,1,2,3\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img79.png"
 ALT="$b \in \{0,1,2,3\}$"></SPAN>, mit der</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">konstanten Reihenfolge <!-- MATH
 $rh = \{1,0,3,2,3,0,1,2\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.33ex; vertical-align: -0.68ex; " SRC="img173.png"
 ALT="$rh = \{1,0,3,2,3,0,1,2\}$"></SPAN>, statt einer sequenziellen</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Reihenfolge wie bei der Verschlüsselung, mit den Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img132.png"
 ALT="$K_z$"></SPAN> ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img174.png"
 ALT="$\Gamma_k$"></SPAN></TD>
<TD CLASS="LEFT">- die vertikale Permutation der Elemente <!-- MATH
 $(k_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img175.png"
 ALT="$(k_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(k_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img176.png"
 ALT="${(k_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img132.png"
 ALT="$K_z$"></SPAN> ist,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><!-- MATH
 $\digamma_k$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.81ex; vertical-align: -0.45ex; " SRC="img177.png"
 ALT="$\digamma_k$"></SPAN></TD>
<TD CLASS="LEFT">- die dimensionale Permutation der Elemente <!-- MATH
 $(k_{a,d,h})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.75ex; " SRC="img175.png"
 ALT="$(k_{a,d,h})$"></SPAN>, wo</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 ${(k_{a,d,h})} \in GF(2^8)$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.75ex; " SRC="img176.png"
 ALT="${(k_{a,d,h})} \in GF(2^8)$"></SPAN>, <!-- MATH
 $a = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img75.png"
 ALT="$a = \overline{0,3}$"></SPAN>, <!-- MATH
 $d = \overline{0, 3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img76.png"
 ALT="$d = \overline{0, 3}$"></SPAN> und <!-- MATH
 $h = \overline{0,3}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.55ex; " SRC="img67.png"
 ALT="$h = \overline{0,3}$"></SPAN>, mit dem</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img132.png"
 ALT="$K_z$"></SPAN>, hier aber die Dimensionen h in der Reihenfolge,</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><!-- MATH
 $h = 2 \mapsto h = 3$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img178.png"
 ALT="$h = 2 \mapsto h = 3$"></SPAN> und <!-- MATH
 $h = 3 \mapsto h = 2$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.69ex; vertical-align: -0.10ex; " SRC="img179.png"
 ALT="$h = 3 \mapsto h = 2$"></SPAN> gewechselt wird.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
Die Funktion <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img163.png"
 ALT="$G^{(K_k)}$"></SPAN>muss dann <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.11ex; vertical-align: -0.10ex; " SRC="img34.png"
 ALT="$n$"></SPAN> mal ausführt werden, damit man die benötigte Anzahl von Rundenschlüssel erzeugt. Es wurde
bewusst ein recht leicht zu berechnener Algorithmus für die Rundenschlüssel-Erzeugung entwickelt, da dieser Algorithmus auf die
nicht Vorhersehbarkeit des Master-Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> setzt und es somit nicht nötig und effizient wäre, einen komplexen Algorithmus für die
Rundenschlüssel-Erzeugung zu entwickeln und anzuwenden.

<P>

<H1><A ID="SECTION00800000000000000000">
Sequenz Shuffle Funktion <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.10ex; " SRC="img180.png"
 ALT="$\Psi^{(K_z)}$"></SPAN></A>
</H1>

<P>
Da MEA nicht wie AES [#!AES:1!#] ein konstantes kryptographisches Netzwerk wie das SPN [#!AES:1!#] benutzt, muss eine dynamische Reihenfolge für jedes
dynamische Packet generiert werden. Diese Reihenfolge ist abhängig vom Schlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN>, doch sollte sie nicht vorhersehbar ohne den Schlüssel
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> sein. Aus diesem Grund wird der Permutations Algorithmus <!-- MATH
 $\Psi^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.10ex; " SRC="img181.png"
 ALT="$\Psi^{(K_k)}$"></SPAN> angewandt, der abhängig von den Rundenschlüsseln <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img132.png"
 ALT="$K_z$"></SPAN> ist,
die vom Masterschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img10.png"
 ALT="$K_k$"></SPAN> mit der vorher beschriebenen Funktion <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.10ex; " SRC="img163.png"
 ALT="$G^{(K_k)}$"></SPAN> generiert wurden. Zuerst werden <!-- MATH
 $\frac{n}{2}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.90ex; " SRC="img48.png"
 ALT="$\frac{n}{2}$"></SPAN> Arrays mit jeweils 6 Elementen
generiert, die jeweils sequentziell mit 0 bis 5 aufgefüllt werden. Dies ist die Startreihenfolge <!-- MATH
 $Rt_{\sqrt{n}} \in R_{\frac{n}{2}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.57ex; vertical-align: -1.05ex; " SRC="img182.png"
 ALT="$Rt_{\sqrt{n}} \in R_{\frac{n}{2}}$"></SPAN>, wobei
<!-- MATH
 $Rt_{\sqrt{n}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.92ex; " SRC="img183.png"
 ALT="$Rt_{\sqrt{n}}$"></SPAN> das t. Element von <!-- MATH
 $R_{\frac{n}{2}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.57ex; vertical-align: -1.05ex; " SRC="img184.png"
 ALT="$R_{\frac{n}{2}}$"></SPAN> ist. <!-- MATH
 $t \in \{0,1,2,...,\frac{n}{2}-1\}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.90ex; " SRC="img185.png"
 ALT="$t \in \{0,1,2,...,\frac{n}{2}-1\}$"></SPAN>. <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.10ex; " SRC="img180.png"
 ALT="$\Psi^{(K_z)}$"></SPAN> ist wie folgt definiert:

<P>
<P><!-- MATH
 \begin{displaymath}
\Psi^{(K_z)} = \prod\limits_{i=0}^{\sqrt{n}-1} \prod\limits_{t=0}^{\frac{n}{2}} \prod\limits_{z=0}^{\sqrt{n}-2} Rt_{(\iota_{K_{(i+t)}}^{(z)})} \doteq Rt_{(\iota_{K_{(i+t)}}^{(z+1)})},
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG
 STYLE="height: 7.17ex; vertical-align: -2.82ex; " SRC="img186.png"
 ALT="$\displaystyle \Psi^{(K_z)} = \prod\limits_{i=0}^{\sqrt{n}-1} \prod\limits_{t=0}...
...t{n}-2} Rt_{(\iota_{K_{(i+t)}}^{(z)})} \doteq Rt_{(\iota_{K_{(i+t)}}^{(z+1)})},$">
</DIV><P></P>
wobei <!-- MATH
 $\iota_{K_{(i+t)}}^{(-z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.61ex; vertical-align: -1.35ex; " SRC="img187.png"
 ALT="$\iota_{K_{(i+t)}}^{(-z)}$"></SPAN> das x. Element von <!-- MATH
 $Rt_{\sqrt{n}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.51ex; vertical-align: -0.92ex; " SRC="img183.png"
 ALT="$Rt_{\sqrt{n}}$"></SPAN> ist und mit Hilfe der Tabelle 2 in Ahbängigkeit vom Rundenschlüssel <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.85ex; " SRC="img188.png"
 ALT="$K_{(i+t)}$"></SPAN> bestimmt wird. Bei der Funktion
<!-- MATH
 $\iota_{K_{(i+t)}}^{(-z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.61ex; vertical-align: -1.35ex; " SRC="img187.png"
 ALT="$\iota_{K_{(i+t)}}^{(-z)}$"></SPAN> wird geschaut, ob die Nummer <!-- MATH
 $-y \in K_{[-z]}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.45ex; vertical-align: -0.85ex; " SRC="img189.png"
 ALT="$-y \in K_{[-z]}$"></SPAN>, im Rundenschlüssel <!-- MATH
 $K_{z} \in K_{z = i+t}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.61ex; " SRC="img190.png"
 ALT="$K_{z} \in K_{z = i+t}$"></SPAN>, kleiner als ein Wert ist und dann mit Hilfe der Tabelle 2 den größtmöglichen Wert zugewiesen wird. Das Resultat wird dann als Rückgabe gegeben.
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">Wert</TD>
<TD CLASS="LEFT">Resultat</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.87ex; vertical-align: -0.41ex; " SRC="img191.png"
 ALT="$\leq$"></SPAN> 0x2A</TD>
<TD CLASS="LEFT">0x00</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.87ex; vertical-align: -0.41ex; " SRC="img191.png"
 ALT="$\leq$"></SPAN> 0x54</TD>
<TD CLASS="LEFT">0x01</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.87ex; vertical-align: -0.41ex; " SRC="img191.png"
 ALT="$\leq$"></SPAN> 0x7E</TD>
<TD CLASS="LEFT">0x02</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.87ex; vertical-align: -0.41ex; " SRC="img191.png"
 ALT="$\leq$"></SPAN> 0xA8</TD>
<TD CLASS="LEFT">0x03</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.87ex; vertical-align: -0.41ex; " SRC="img191.png"
 ALT="$\leq$"></SPAN> 0xD2</TD>
<TD CLASS="LEFT">0x04</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">-y <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.87ex; vertical-align: -0.41ex; " SRC="img191.png"
 ALT="$\leq$"></SPAN> 0xFF</TD>
<TD CLASS="LEFT">0x05</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">Wert</TD>
<TD CLASS="LEFT">Funktion</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x00</TD>
<TD CLASS="LEFT"><!-- MATH
 $\vartheta_l$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img61.png"
 ALT="$\vartheta_l$"></SPAN> oder <!-- MATH
 $\hat{\vartheta_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img135.png"
 ALT="$\hat{\vartheta_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x01</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img77.png"
 ALT="$\Omega_l$"></SPAN> oder <!-- MATH
 $\hat{\Omega_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img136.png"
 ALT="$\hat{\Omega_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x02</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img62.png"
 ALT="$\Gamma_l$"></SPAN> oder <!-- MATH
 $\hat{\Gamma_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.62ex; vertical-align: -0.45ex; " SRC="img138.png"
 ALT="$\hat{\Gamma_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x03</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.46ex; vertical-align: -0.45ex; " SRC="img80.png"
 ALT="$\pi_l$"></SPAN> oder <!-- MATH
 $\hat{\pi_l}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.04ex; vertical-align: -0.45ex; " SRC="img139.png"
 ALT="$\hat{\pi_l}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x04</TD>
<TD CLASS="LEFT"><!-- MATH
 $\chi_l^{(h)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img63.png"
 ALT="$\chi_l^{(h)}$"></SPAN> oder <!-- MATH
 $\hat{\chi_l^{(h)}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.67ex; vertical-align: -0.74ex; " SRC="img157.png"
 ALT="$\hat{\chi_l^{(h)}}$"></SPAN> (bei <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN>)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="CENTER">0x05</TD>
<TD CLASS="LEFT"><!-- MATH
 $\kappa_l^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.03ex; vertical-align: -0.74ex; " SRC="img85.png"
 ALT="$\kappa_l ^{(K_z)}$"></SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>
<BR>
Tabelle 2        und            Tabelle 3
<BR>
<BR>
Dieser Prozess wird dann <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.39ex; vertical-align: -0.65ex; " SRC="img47.png"
 ALT="$\sqrt{n}$"></SPAN>-mal wiederholt, damit eine sichere Permutation ensteht. Diese Permutation wird dann als
dynamische Reihenfolge <!-- MATH
 $\Psi^{(K_z)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.98ex; vertical-align: -0.10ex; " SRC="img180.png"
 ALT="$\Psi^{(K_z)}$"></SPAN> benutzt, die mit Hilfe der Tabelle 3 die jeweligen Funktionen in <!-- MATH
 $E_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img17.png"
 ALT="$E_{l,k}^{(K_k)}$"></SPAN> und <!-- MATH
 $D_{l,k}^{(K_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.26ex; vertical-align: -1.04ex; " SRC="img19.png"
 ALT="$D_{l,k}^{(K_k)}$"></SPAN> ausführt.

<P>

<H1><A ID="SECTION00900000000000000000">
Weiteres</A>
</H1>

<P>

<H1><A ID="SECTION00910000000000000000">
S-Boxen   <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN> und -<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img78.png"
 ALT="$\beta_b$"></SPAN></A>
</H1>
Die 8 Substitutionsboxen sind wie folgt definiert:
<BR>
<BR><SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img192.png"
 ALT="$\beta_0 = $"></SPAN>
</SPAN><PRE>
{
    0xce, 0xbb, 0xeb, 0x92, 0xea, 0xcb, 0x13, 0xc1,
    0xe9, 0x3a, 0xd6, 0xb2, 0xd2, 0x90, 0x17, 0xf8,
    0x42, 0x15, 0x56, 0xb4, 0x65, 0x1c, 0x88, 0x43,
    0xc5, 0x5c, 0x36, 0xba, 0xf5, 0x57, 0x67, 0x8d,
    0x31, 0xf6, 0x64, 0x58, 0x9e, 0xf4, 0x22, 0xaa,
    0x75, 0x0f, 0x02, 0xb1, 0xdf, 0x6d, 0x73, 0x4d,
    0x7c, 0x26, 0x2e, 0xf7, 0x08, 0x5d, 0x44, 0x3e,
    0x9f, 0x14, 0xc8, 0xae, 0x54, 0x10, 0xd8, 0xbc,
    0x1a, 0x6b, 0x69, 0xf3, 0xbd, 0x33, 0xab, 0xfa,
    0xd1, 0x9b, 0x68, 0x4e, 0x16, 0x95, 0x91, 0xee,
    0x4c, 0x63, 0x8e, 0x5b, 0xcc, 0x3c, 0x19, 0xa1,
    0x81, 0x49, 0x7b, 0xd9, 0x6f, 0x37, 0x60, 0xca,
    0xe7, 0x2b, 0x48, 0xfd, 0x96, 0x45, 0xfc, 0x41,
    0x12, 0x0d, 0x79, 0xe5, 0x89, 0x8c, 0xe3, 0x20,
    0x30, 0xdc, 0xb7, 0x6c, 0x4a, 0xb5, 0x3f, 0x97,
    0xd4, 0x62, 0x2d, 0x06, 0xa4, 0xa5, 0x83, 0x5f,
    0x2a, 0xda, 0xc9, 0x00, 0x7e, 0xa2, 0x55, 0xbf,
    0x11, 0xd5, 0x9c, 0xcf, 0x0e, 0x0a, 0x3d, 0x51,
    0x7d, 0x93, 0x1b, 0xfe, 0xc4, 0x47, 0x09, 0x86,
    0x0b, 0x8f, 0x9d, 0x6a, 0x07, 0xb9, 0xb0, 0x98,
    0x18, 0x32, 0x71, 0x4b, 0xef, 0x3b, 0x70, 0xa0,
    0xe4, 0x40, 0xff, 0xc3, 0xa9, 0xe6, 0x78, 0xf9,
    0x8b, 0x46, 0x80, 0x1e, 0x38, 0xe1, 0xb8, 0xa8,
    0xe0, 0x0c, 0x23, 0x76, 0x1d, 0x25, 0x24, 0x05,
    0xf1, 0x6e, 0x94, 0x28, 0x9a, 0x84, 0xe8, 0xa3,
    0x4f, 0x77, 0xd3, 0x85, 0xe2, 0x52, 0xf2, 0x82,
    0x50, 0x7a, 0x2f, 0x74, 0x53, 0xb3, 0x61, 0xaf,
    0x39, 0x35, 0xde, 0xcd, 0x1f, 0x99, 0xac, 0xad,
    0x72, 0x2c, 0xdd, 0xd0, 0x87, 0xbe, 0x5e, 0xa6,
    0xec, 0x04, 0xc6, 0x03, 0x34, 0xfb, 0xdb, 0x59,
    0xb6, 0xc2, 0x01, 0xf0, 0x5a, 0xed, 0xa7, 0x66,
    0x21, 0x7f, 0x8a, 0x27, 0xc7, 0xc0, 0x29, 0xd7
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img193.png"
 ALT="$\beta_1 = $"></SPAN>
</SPAN><PRE>
{
    0x14, 0x9d, 0xb9, 0xe7, 0x67, 0x4c, 0x50, 0x82,
    0xca, 0xe5, 0x1d, 0x31, 0x0a, 0xc6, 0xb2, 0x51,
    0xa2, 0xd8, 0x54, 0x90, 0xd0, 0xce, 0x2d, 0x7d,
    0xc7, 0x7e, 0xd7, 0x94, 0xdf, 0x83, 0x8e, 0x6c,
    0x66, 0xd2, 0x6f, 0x16, 0x1e, 0x76, 0xfe, 0xcc,
    0xaa, 0x5a, 0x8f, 0x17, 0xbd, 0x2c, 0xac, 0xea,
    0x7b, 0x65, 0xa9, 0x10, 0xc0, 0x92, 0xee, 0xbe,
    0x6a, 0x6e, 0x48, 0x96, 0x95, 0xe9, 0x32, 0xbc,
    0xa1, 0x42, 0xd5, 0xa7, 0x81, 0xb4, 0x5f, 0xe6,
    0xc2, 0x5d, 0xad, 0x3a, 0xb7, 0x0c, 0x8d, 0x01,
    0x98, 0xfd, 0x12, 0x02, 0x75, 0x13, 0x0f, 0x6b,
    0x22, 0xe2, 0xab, 0xf7, 0x7f, 0xba, 0x97, 0xd1,
    0x64, 0xd9, 0xc4, 0x59, 0xaf, 0x23, 0x33, 0x37,
    0xde, 0xae, 0x60, 0x05, 0x63, 0xa8, 0x52, 0xa5,
    0x4e, 0xe0, 0xdd, 0x71, 0xf2, 0x24, 0x34, 0x57,
    0x47, 0xa4, 0xb3, 0x9e, 0x2f, 0xc1, 0xb8, 0xcb,
    0x2b, 0xd4, 0x0d, 0x36, 0x91, 0x8b, 0x9c, 0x26,
    0x25, 0x61, 0xa3, 0xd6, 0xeb, 0x35, 0x53, 0xf4,
    0x2e, 0x88, 0x80, 0xe4, 0x30, 0xdb, 0xfc, 0x0e,
    0x77, 0x8c, 0x93, 0xa6, 0x78, 0x06, 0xe1, 0xec,
    0xf9, 0x03, 0xa0, 0x27, 0xda, 0xef, 0x5c, 0x00,
    0x7a, 0x45, 0xe8, 0x40, 0x1a, 0x4b, 0x5e, 0x73,
    0xc3, 0xff, 0xf5, 0xf3, 0xb0, 0xc5, 0x49, 0x21,
    0xfa, 0x11, 0x39, 0x84, 0x43, 0x38, 0x85, 0x07,
    0xf0, 0x79, 0x46, 0xf8, 0xe3, 0x1f, 0x09, 0xb6,
    0xcd, 0x55, 0x1c, 0x1b, 0xfb, 0x7c, 0xed, 0x6d,
    0x15, 0x56, 0x86, 0x20, 0x68, 0x4a, 0x41, 0x4f,
    0xd3, 0x99, 0x08, 0xf6, 0x3f, 0x89, 0x62, 0x04,
    0xcf, 0xc8, 0x69, 0x9f, 0x19, 0x5b, 0x44, 0x9b,
    0x87, 0xb1, 0x3d, 0xbb, 0xdc, 0x2a, 0xbf, 0x58,
    0x3c, 0x8a, 0x18, 0x3e, 0x72, 0x0b, 0x28, 0x4d,
    0xb5, 0x9a, 0xc9, 0x74, 0x29, 0xf1, 0x3b, 0x70
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img194.png"
 ALT="$\beta_2 = $"></SPAN>
</SPAN><PRE>
{
    0x68, 0x8d, 0xca, 0x4d, 0x73, 0x4b, 0x4e, 0x2a,
    0xd4, 0x52, 0x26, 0xb3, 0x54, 0x1e, 0x19, 0x1f,
    0x22, 0x03, 0x46, 0x3d, 0x2d, 0x4a, 0x53, 0x83,
    0x13, 0x8a, 0xb7, 0xd5, 0x25, 0x79, 0xf5, 0xbd,
    0x58, 0x2f, 0x0d, 0x02, 0xed, 0x51, 0x9e, 0x11,
    0xf2, 0x3e, 0x55, 0x5e, 0xd1, 0x16, 0x3c, 0x66,
    0x70, 0x5d, 0xf3, 0x45, 0x40, 0xcc, 0xe8, 0x94,
    0x56, 0x08, 0xce, 0x1a, 0x3a, 0xd2, 0xe1, 0xdf,
    0xb5, 0x38, 0x6e, 0x0e, 0xe5, 0xf4, 0xf9, 0x86,
    0xe9, 0x4f, 0xd6, 0x85, 0x23, 0xcf, 0x32, 0x99,
    0x31, 0x14, 0xae, 0xee, 0xc8, 0x48, 0xd3, 0x30,
    0xa1, 0x92, 0x41, 0xb1, 0x18, 0xc4, 0x2c, 0x71,
    0x72, 0x44, 0x15, 0xfd, 0x37, 0xbe, 0x5f, 0xaa,
    0x9b, 0x88, 0xd8, 0xab, 0x89, 0x9c, 0xfa, 0x60,
    0xea, 0xbc, 0x62, 0x0c, 0x24, 0xa6, 0xa8, 0xec,
    0x67, 0x20, 0xdb, 0x7c, 0x28, 0xdd, 0xac, 0x5b,
    0x34, 0x7e, 0x10, 0xf1, 0x7b, 0x8f, 0x63, 0xa0,
    0x05, 0x9a, 0x43, 0x77, 0x21, 0xbf, 0x27, 0x09,
    0xc3, 0x9f, 0xb6, 0xd7, 0x29, 0xc2, 0xeb, 0xc0,
    0xa4, 0x8b, 0x8c, 0x1d, 0xfb, 0xff, 0xc1, 0xb2,
    0x97, 0x2e, 0xf8, 0x65, 0xf6, 0x75, 0x07, 0x04,
    0x49, 0x33, 0xe4, 0xd9, 0xb9, 0xd0, 0x42, 0xc7,
    0x6c, 0x90, 0x00, 0x8e, 0x6f, 0x50, 0x01, 0xc5,
    0xda, 0x47, 0x3f, 0xcd, 0x69, 0xa2, 0xe2, 0x7a,
    0xa7, 0xc6, 0x93, 0x0f, 0x0a, 0x06, 0xe6, 0x2b,
    0x96, 0xa3, 0x1c, 0xaf, 0x6a, 0x12, 0x84, 0x39,
    0xe7, 0xb0, 0x82, 0xf7, 0xfe, 0x9d, 0x87, 0x5c,
    0x81, 0x35, 0xde, 0xb4, 0xa5, 0xfc, 0x80, 0xef,
    0xcb, 0xbb, 0x6b, 0x76, 0xba, 0x5a, 0x7d, 0x78,
    0x0b, 0x95, 0xe3, 0xad, 0x74, 0x98, 0x3b, 0x36,
    0x64, 0x6d, 0xdc, 0xf0, 0x59, 0xa9, 0x4c, 0x17,
    0x7f, 0x91, 0xb8, 0xc9, 0x57, 0x1b, 0xe0, 0x61
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img195.png"
 ALT="$\beta_3 = $"></SPAN>
</SPAN><PRE>
{
    0xa8, 0x43, 0x5f, 0x06, 0x6b, 0x75, 0x6c, 0x59,
    0x71, 0xdf, 0x87, 0x95, 0x17, 0xf0, 0xd8, 0x09,
    0x6d, 0xf3, 0x1d, 0xcb, 0xc9, 0x4d, 0x2c, 0xaf,
    0x79, 0xe0, 0x97, 0xfd, 0x6f, 0x4b, 0x45, 0x39,
    0x3e, 0xdd, 0xa3, 0x4f, 0xb4, 0xb6, 0x9a, 0x0e,
    0x1f, 0xbf, 0x15, 0xe1, 0x49, 0xd2, 0x93, 0xc6,
    0x92, 0x72, 0x9e, 0x61, 0xd1, 0x63, 0xfa, 0xee,
    0xf4, 0x19, 0xd5, 0xad, 0x58, 0xa4, 0xbb, 0xa1,
    0xdc, 0xf2, 0x83, 0x37, 0x42, 0xe4, 0x7a, 0x32,
    0x9c, 0xcc, 0xab, 0x4a, 0x8f, 0x6e, 0x04, 0x27,
    0x2e, 0xe7, 0xe2, 0x5a, 0x96, 0x16, 0x23, 0x2b,
    0xc2, 0x65, 0x66, 0x0f, 0xbc, 0xa9, 0x47, 0x41,
    0x34, 0x48, 0xfc, 0xb7, 0x6a, 0x88, 0xa5, 0x53,
    0x86, 0xf9, 0x5b, 0xdb, 0x38, 0x7b, 0xc3, 0x1e,
    0x22, 0x33, 0x24, 0x28, 0x36, 0xc7, 0xb2, 0x3b,
    0x8e, 0x77, 0xba, 0xf5, 0x14, 0x9f, 0x08, 0x55,
    0x9b, 0x4c, 0xfe, 0x60, 0x5c, 0xda, 0x18, 0x46,
    0xcd, 0x7d, 0x21, 0xb0, 0x3f, 0x1b, 0x89, 0xff,
    0xeb, 0x84, 0x69, 0x3a, 0x9d, 0xd7, 0xd3, 0x70,
    0x67, 0x40, 0xb5, 0xde, 0x5d, 0x30, 0x91, 0xb1,
    0x78, 0x11, 0x01, 0xe5, 0x00, 0x68, 0x98, 0xa0,
    0xc5, 0x02, 0xa6, 0x74, 0x2d, 0x0b, 0xa2, 0x76,
    0xb3, 0xbe, 0xce, 0xbd, 0xae, 0xe9, 0x8a, 0x31,
    0x1c, 0xec, 0xf1, 0x99, 0x94, 0xaa, 0xf6, 0x26,
    0x2f, 0xef, 0xe8, 0x8c, 0x35, 0x03, 0xd4, 0x7f,
    0xfb, 0x05, 0xc1, 0x5e, 0x90, 0x20, 0x3d, 0x82,
    0xf7, 0xea, 0x0a, 0x0d, 0x7e, 0xf8, 0x50, 0x1a,
    0xc4, 0x07, 0x57, 0xb8, 0x3c, 0x62, 0xe3, 0xc8,
    0xac, 0x52, 0x64, 0x10, 0xd0, 0xd9, 0x13, 0x0c,
    0x12, 0x29, 0x51, 0xb9, 0xcf, 0xd6, 0x73, 0x8d,
    0x81, 0x54, 0xc0, 0xed, 0x4e, 0x44, 0xa7, 0x2a,
    0x85, 0x25, 0xe6, 0xca, 0x7c, 0x8b, 0x56, 0x80
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_0 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img196.png"
 ALT="$-\beta_0 = $"></SPAN>
</SPAN><PRE>
{
    0x83, 0xf2, 0x2a, 0xeb, 0xe9, 0xbf, 0x7b, 0x9c,
    0x34, 0x96, 0x8d, 0x98, 0xb9, 0x69, 0x8c, 0x29,
    0x3d, 0x88, 0x68, 0x06, 0x39, 0x11, 0x4c, 0x0e,
    0xa0, 0x56, 0x40, 0x92, 0x15, 0xbc, 0xb3, 0xdc,
    0x6f, 0xf8, 0x26, 0xba, 0xbe, 0xbd, 0x31, 0xfb,
    0xc3, 0xfe, 0x80, 0x61, 0xe1, 0x7a, 0x32, 0xd2,
    0x70, 0x20, 0xa1, 0x45, 0xec, 0xd9, 0x1a, 0x5d,
    0xb4, 0xd8, 0x09, 0xa5, 0x55, 0x8e, 0x37, 0x76,
    0xa9, 0x67, 0x10, 0x17, 0x36, 0x65, 0xb1, 0x95,
    0x62, 0x59, 0x74, 0xa3, 0x50, 0x2f, 0x4b, 0xc8,
    0xd0, 0x8f, 0xcd, 0xd4, 0x3c, 0x86, 0x12, 0x1d,
    0x23, 0xef, 0xf4, 0x53, 0x19, 0x35, 0xe6, 0x7f,
    0x5e, 0xd6, 0x79, 0x51, 0x22, 0x14, 0xf7, 0x1e,
    0x4a, 0x42, 0x9b, 0x41, 0x73, 0x2d, 0xc1, 0x5c,
    0xa6, 0xa2, 0xe0, 0x2e, 0xd3, 0x28, 0xbb, 0xc9,
    0xae, 0x6a, 0xd1, 0x5a, 0x30, 0x90, 0x84, 0xf9,
    0xb2, 0x58, 0xcf, 0x7e, 0xc5, 0xcb, 0x97, 0xe4,
    0x16, 0x6c, 0xfa, 0xb0, 0x6d, 0x1f, 0x52, 0x99,
    0x0d, 0x4e, 0x03, 0x91, 0xc2, 0x4d, 0x64, 0x77,
    0x9f, 0xdd, 0xc4, 0x49, 0x8a, 0x9a, 0x24, 0x38,
    0xa7, 0x57, 0x85, 0xc7, 0x7c, 0x7d, 0xe7, 0xf6,
    0xb7, 0xac, 0x27, 0x46, 0xde, 0xdf, 0x3b, 0xd7,
    0x9e, 0x2b, 0x0b, 0xd5, 0x13, 0x75, 0xf0, 0x72,
    0xb6, 0x9d, 0x1b, 0x01, 0x3f, 0x44, 0xe5, 0x87,
    0xfd, 0x07, 0xf1, 0xab, 0x94, 0x18, 0xea, 0xfc,
    0x3a, 0x82, 0x5f, 0x05, 0x54, 0xdb, 0x00, 0x8b,
    0xe3, 0x48, 0x0c, 0xca, 0x78, 0x89, 0x0a, 0xff,
    0x3e, 0x5b, 0x81, 0xee, 0x71, 0xe2, 0xda, 0x2c,
    0xb8, 0xb5, 0xcc, 0x6e, 0xa8, 0x6b, 0xad, 0x60,
    0xc6, 0x08, 0x04, 0x02, 0xe8, 0xf5, 0x4f, 0xa4,
    0xf3, 0xc0, 0xce, 0x43, 0x25, 0x1c, 0x21, 0x33,
    0x0f, 0xaf, 0x47, 0xed, 0x66, 0x63, 0x93, 0xaa
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_1 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img197.png"
 ALT="$-\beta_1 = $"></SPAN>
</SPAN><PRE>
{
    0xa7, 0x4f, 0x53, 0xa1, 0xdf, 0x6b, 0x9d, 0xbf,
    0xda, 0xc6, 0x0c, 0xf5, 0x4d, 0x82, 0x97, 0x56,
    0x33, 0xb9, 0x52, 0x55, 0x00, 0xd0, 0x23, 0x2b,
    0xf2, 0xe4, 0xac, 0xcb, 0xca, 0x0a, 0x24, 0xc5,
    0xd3, 0xb7, 0x58, 0x65, 0x75, 0x88, 0x87, 0xa3,
    0xf6, 0xfc, 0xed, 0x80, 0x2d, 0x16, 0x90, 0x7c,
    0x94, 0x0b, 0x3e, 0x66, 0x76, 0x8d, 0x83, 0x67,
    0xbd, 0xba, 0x4b, 0xfe, 0xf0, 0xea, 0xf3, 0xdc,
    0xab, 0xd6, 0x41, 0xbc, 0xe6, 0xa9, 0xc2, 0x78,
    0x3a, 0xb6, 0xd5, 0xad, 0x05, 0xf7, 0x70, 0xd7,
    0x06, 0x0f, 0x6e, 0x8e, 0x12, 0xc9, 0xd1, 0x77,
    0xef, 0x63, 0x29, 0xe5, 0xa6, 0x49, 0xae, 0x46,
    0x6a, 0x89, 0xde, 0x6c, 0x60, 0x31, 0x20, 0x04,
    0xd4, 0xe2, 0x38, 0x57, 0x1f, 0xcf, 0x39, 0x22,
    0xff, 0x73, 0xf4, 0xaf, 0xfb, 0x54, 0x25, 0x98,
    0x9c, 0xc1, 0xa8, 0x30, 0xcd, 0x17, 0x19, 0x5c,
    0x92, 0x44, 0x07, 0x1d, 0xbb, 0xbe, 0xd2, 0xe8,
    0x91, 0xdd, 0xf1, 0x85, 0x99, 0x4e, 0x1e, 0x2a,
    0x13, 0x84, 0x35, 0x9a, 0x1b, 0x3c, 0x3b, 0x5e,
    0x50, 0xd9, 0xf9, 0xe7, 0x86, 0x01, 0x7b, 0xe3,
    0xa2, 0x40, 0x10, 0x8a, 0x79, 0x6f, 0x9b, 0x43,
    0x6d, 0x32, 0x28, 0x5a, 0x2e, 0x4a, 0x69, 0x64,
    0xb4, 0xe9, 0x0e, 0x7a, 0x45, 0xf8, 0xc7, 0x4c,
    0x7e, 0x02, 0x5d, 0xeb, 0x3f, 0x2c, 0x37, 0xee,
    0x34, 0x7d, 0x48, 0xb0, 0x62, 0xb5, 0x0d, 0x18,
    0xe1, 0xfa, 0x08, 0x7f, 0x27, 0xc8, 0x15, 0xe0,
    0x14, 0x5f, 0x21, 0xd8, 0x81, 0x42, 0x8b, 0x1a,
    0x11, 0x61, 0xa4, 0x95, 0xec, 0x72, 0x68, 0x1c,
    0x71, 0x9e, 0x59, 0xc4, 0x93, 0x09, 0x47, 0x03,
    0xaa, 0x3d, 0x2f, 0x8c, 0x9f, 0xce, 0x36, 0xa5,
    0xc0, 0xfd, 0x74, 0xb3, 0x8f, 0xb2, 0xdb, 0x5b,
    0xc3, 0xa0, 0xb8, 0xcc, 0x96, 0x51, 0x26, 0xb1
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_2 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img198.png"
 ALT="$-\beta_2 = $"></SPAN>
</SPAN><PRE>
{
    0xb2, 0xb6, 0x23, 0x11, 0xa7, 0x88, 0xc5, 0xa6,
    0x39, 0x8f, 0xc4, 0xe8, 0x73, 0x22, 0x43, 0xc3,
    0x82, 0x27, 0xcd, 0x18, 0x51, 0x62, 0x2d, 0xf7,
    0x5c, 0x0e, 0x3b, 0xfd, 0xca, 0x9b, 0x0d, 0x0f,
    0x79, 0x8c, 0x10, 0x4c, 0x74, 0x1c, 0x0a, 0x8e,
    0x7c, 0x94, 0x07, 0xc7, 0x5e, 0x14, 0xa1, 0x21,
    0x57, 0x50, 0x4e, 0xa9, 0x80, 0xd9, 0xef, 0x64,
    0x41, 0xcf, 0x3c, 0xee, 0x2e, 0x13, 0x29, 0xba,
    0x34, 0x5a, 0xae, 0x8a, 0x61, 0x33, 0x12, 0xb9,
    0x55, 0xa8, 0x15, 0x05, 0xf6, 0x03, 0x06, 0x49,
    0xb5, 0x25, 0x09, 0x16, 0x0c, 0x2a, 0x38, 0xfc,
    0x20, 0xf4, 0xe5, 0x7f, 0xd7, 0x31, 0x2b, 0x66,
    0x6f, 0xff, 0x72, 0x86, 0xf0, 0xa3, 0x2f, 0x78,
    0x00, 0xbc, 0xcc, 0xe2, 0xb0, 0xf1, 0x42, 0xb4,
    0x30, 0x5f, 0x60, 0x04, 0xec, 0xa5, 0xe3, 0x8b,
    0xe7, 0x1d, 0xbf, 0x84, 0x7b, 0xe6, 0x81, 0xf8,
    0xde, 0xd8, 0xd2, 0x17, 0xce, 0x4b, 0x47, 0xd6,
    0x69, 0x6c, 0x19, 0x99, 0x9a, 0x01, 0xb3, 0x85,
    0xb1, 0xf9, 0x59, 0xc2, 0x37, 0xe9, 0xc8, 0xa0,
    0xed, 0x4f, 0x89, 0x68, 0x6d, 0xd5, 0x26, 0x91,
    0x87, 0x58, 0xbd, 0xc9, 0x98, 0xdc, 0x75, 0xc0,
    0x76, 0xf5, 0x67, 0x6b, 0x7e, 0xeb, 0x52, 0xcb,
    0xd1, 0x5b, 0x9f, 0x0b, 0xdb, 0x40, 0x92, 0x1a,
    0xfa, 0xac, 0xe4, 0xe1, 0x71, 0x1f, 0x65, 0x8d,
    0x97, 0x9e, 0x95, 0x90, 0x5d, 0xb7, 0xc1, 0xaf,
    0x54, 0xfb, 0x02, 0xe0, 0x35, 0xbb, 0x3a, 0x4d,
    0xad, 0x2c, 0x3d, 0x56, 0x08, 0x1b, 0x4a, 0x93,
    0x6a, 0xab, 0xb8, 0x7a, 0xf2, 0x7d, 0xda, 0x3f,
    0xfe, 0x3e, 0xbe, 0xea, 0xaa, 0x44, 0xc6, 0xd0,
    0x36, 0x48, 0x70, 0x96, 0x77, 0x24, 0x53, 0xdf,
    0xf3, 0x83, 0x28, 0x32, 0x45, 0x1e, 0xa4, 0xd3,
    0xa2, 0x46, 0x6e, 0x9c, 0xdd, 0x63, 0xd4, 0x9d
}
</PRE><SPAN CLASS="SMALL">
</SPAN>
<P>
<SPAN CLASS="SMALL"><!-- MATH
 $-\beta_3 =$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.16ex; vertical-align: -0.55ex; " SRC="img199.png"
 ALT="$-\beta_3 = $"></SPAN>
</SPAN><PRE>
{
    0xa4, 0xa2, 0xa9, 0xc5, 0x4e, 0xc9, 0x03, 0xd9,
    0x7e, 0x0f, 0xd2, 0xad, 0xe7, 0xd3, 0x27, 0x5b,
    0xe3, 0xa1, 0xe8, 0xe6, 0x7c, 0x2a, 0x55, 0x0c,
    0x86, 0x39, 0xd7, 0x8d, 0xb8, 0x12, 0x6f, 0x28,
    0xcd, 0x8a, 0x70, 0x56, 0x72, 0xf9, 0xbf, 0x4f,
    0x73, 0xe9, 0xf7, 0x57, 0x16, 0xac, 0x50, 0xc0,
    0x9d, 0xb7, 0x47, 0x71, 0x60, 0xc4, 0x74, 0x43,
    0x6c, 0x1f, 0x93, 0x77, 0xdc, 0xce, 0x20, 0x8c,
    0x99, 0x5f, 0x44, 0x01, 0xf5, 0x1e, 0x87, 0x5e,
    0x61, 0x2c, 0x4b, 0x1d, 0x81, 0x15, 0xf4, 0x23,
    0xd6, 0xea, 0xe1, 0x67, 0xf1, 0x7f, 0xfe, 0xda,
    0x3c, 0x07, 0x53, 0x6a, 0x84, 0x9c, 0xcb, 0x02,
    0x83, 0x33, 0xdd, 0x35, 0xe2, 0x59, 0x5a, 0x98,
    0xa5, 0x92, 0x64, 0x04, 0x06, 0x10, 0x4d, 0x1c,
    0x97, 0x08, 0x31, 0xee, 0xab, 0x05, 0xaf, 0x79,
    0xa0, 0x18, 0x46, 0x6d, 0xfc, 0x89, 0xd4, 0xc7,
    0xff, 0xf0, 0xcf, 0x42, 0x91, 0xf8, 0x68, 0x0a,
    0x65, 0x8e, 0xb6, 0xfd, 0xc3, 0xef, 0x78, 0x4c,
    0xcc, 0x9e, 0x30, 0x2e, 0xbc, 0x0b, 0x54, 0x1a,
    0xa6, 0xbb, 0x26, 0x80, 0x48, 0x94, 0x32, 0x7d,
    0xa7, 0x3f, 0xae, 0x22, 0x3d, 0x66, 0xaa, 0xf6,
    0x00, 0x5d, 0xbd, 0x4a, 0xe0, 0x3b, 0xb4, 0x17,
    0x8b, 0x9f, 0x76, 0xb0, 0x24, 0x9a, 0x25, 0x63,
    0xdb, 0xeb, 0x7a, 0x3e, 0x5c, 0xb3, 0xb1, 0x29,
    0xf2, 0xca, 0x58, 0x6e, 0xd8, 0xa8, 0x2f, 0x75,
    0xdf, 0x14, 0xfb, 0x13, 0x49, 0x88, 0xb2, 0xec,
    0xe4, 0x34, 0x2d, 0x96, 0xc6, 0x3a, 0xed, 0x95,
    0x0e, 0xe5, 0x85, 0x6b, 0x40, 0x21, 0x9b, 0x09,
    0x19, 0x2b, 0x52, 0xde, 0x45, 0xa3, 0xfa, 0x51,
    0xc2, 0xb5, 0xd1, 0x90, 0xb9, 0xf3, 0x37, 0xc1,
    0x0d, 0xba, 0x41, 0x11, 0x38, 0x7b, 0xbe, 0xd0,
    0xd5, 0x69, 0x36, 0xc8, 0x62, 0x1b, 0x82, 0x8f
}
</PRE><SPAN CLASS="SMALL"></SPAN>
<H1><A ID="SECTION001000000000000000000">
Implementierung in der Programmiersprache C</A>
</H1>

<P>

<H1><A ID="SECTION001010000000000000000">
Code</A>
</H1>

<P>

<H2><A ID="SECTION001011000000000000000">
mea.h</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*
    2  *  Projekt :   MEA
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   mea.h
    5 */
    6 
    7 #ifndef MEA_H
    8 #define MEA_H
    9 
   10 #include &lt;stdint.h&gt;
   11 #include &lt;stddef.h&gt;
   12 
   13 #define MEA_SUB_ROUNDS  0x06
   14 #define MEA_M_ROUNDS    0x06
   15 
   16 #define MEA_NW_STATE    0x08
   17 #define MEA_NW_KEY      0x08
   18 
   19 #define MEA_MS_IN_DIM   0x10
   20 #define MEA_MS_DIM      0x03
   21 #define MEA_MS_ROW      0x04
   22 
   23 #define MEA_FNC_HRSR    0x00
   24 #define MEA_FNC_SBB     0x01
   25 #define MEA_FNC_VRSC    0x02
   26 #define MEA_FNC_MXCL    0x03
   27 #define MEA_FNC_DRT     0x04
   28 #define MEA_FNC_XRK     0x05
   29 
   30 
   31 #define BYTE_TO_M_STATE(table, n_row, n_col) table[(n_row) + (n_col)* sizeof(uint64_t)]
   32 #define RKCON 0xc6e8e5ed7b352d4
   33 
   34 
   35 struct mea_t {
   36     uint64_t* m_state;
   37     uint8_t **r_seq;
   38     uint64_t** r_keys;
   39 };
   40 typedef struct mea_t mea_t;
   41 
   42 mea_t* mea_init();
   43 int mea_del(mea_t* mea_ctx);
   44 
   45 int mea_dimRotate(mea_t *mea_ctx, uint8_t dim);
   46 int mea_invDimRotate(mea_t *mea_ctx, uint8_t dim);
   47 
   48 int mea_verShiftColumns(mea_t *mea_ctx);
   49 int mea_invVerShiftColumns(mea_t *mea_ctx);
   50 
   51 int mea_horShiftRows(mea_t *mea_ctx);
   52 int mea_invHorShiftRows(mea_t *mea_ctx);
   53 
   54 int mea_mixColumns(mea_t *mea_ctx);
   55 int mea_invMixColumns(mea_t *mea_ctx);
   56 
   57 int mea_subBytes(mea_t *mea_ctx);
   58 int mea_invSubBytes(mea_t *mea_ctx);
   59 
   60 int mea_generateRKeys(mea_t *mea_ctx, uint64_t *mkey);
   61 int mea_rSeqGen(mea_t *mea_ctx);
   62 
   63 int mea_blockEncipher(mea_t *mea_ctx, uint64_t *plain, uint64_t *cipher);
   64 int mea_blockDecipher(mea_t *mea_ctx, uint64_t *cipher, uint64_t *plain);
   65 
   66 #endif
</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001012000000000000000">
tables.h</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   tables.h
    5 */  
    6 
    7 #ifndef TABLES_H 
    8 #define TABLES_H
    9 
   10 #include &lt;stdint.h&gt;
   11 
   12 extern uint8_t mds_matrix[8][8];
   13 extern uint8_t mds_inv_matrix[8][8];
   14 
   15 extern uint8_t mea_sbox[4][256];
   16 extern uint8_t mea_invSbox[4][256];
   17 
   18 #endif
</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001013000000000000000">
tables.c</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA
    3  *  autor   :   Michael engel
    4  *  datei   :   tables.c
    5 */  
    6 
    7 #include &lt;stdint.h&gt;
    8 
    9 #include "mea.h"
   10 
   11 uint8_t mds_matrix[8][8] = {
   12     { 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01},
   13     { 0x01, 0x08, 0x06, 0x07, 0x04, 0x01, 0x01, 0x05},
   14     { 0x05, 0x01, 0x08, 0x06, 0x07, 0x04, 0x01, 0x01},
   15     { 0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04, 0x01},
   16     { 0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04},
   17     { 0x04, 0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07},
   18     { 0x07, 0x04, 0x01, 0x01, 0x05, 0x01, 0x08, 0x06},
   19     { 0x06, 0x07, 0x04, 0x01, 0x01, 0x05, 0x01, 0x08}
   20 };
   21 
   22 uint8_t mds_inv_matrix[8][8] = {
   23     { 0x2f, 0x49, 0xd7, 0xca, 0xad, 0x95, 0x76, 0xa8},
   24     { 0xa8, 0x2f, 0x49, 0xd7, 0xca, 0xad, 0x95, 0x76},
   25     { 0x76, 0xa8, 0x2f, 0x49, 0xd7, 0xca, 0xad, 0x95},
   26     { 0x95, 0x76, 0xa8, 0x2f, 0x49, 0xd7, 0xca, 0xad},
   27     { 0xad, 0x95, 0x76, 0xa8, 0x2f, 0x49, 0xd7, 0xca},
   28     { 0xca, 0xad, 0x95, 0x76, 0xa8, 0x2f, 0x49, 0xd7},
   29     { 0xd7, 0xca, 0xad, 0x95, 0x76, 0xa8, 0x2f, 0x49},
   30     { 0x49, 0xd7, 0xca, 0xad, 0x95, 0x76, 0xa8, 0x2f}
   31 };
   32 
   33 uint8_t mea_sbox[4][256] = {
   34 {
   35     0xce, 0xbb, 0xeb, 0x92, 0xea, 0xcb, 0x13, 0xc1, 0xe9, 0x3a, 0xd6, 0xb2, 0xd2, 0x90, 0x17, 0xf8, 
   36     0x42, 0x15, 0x56, 0xb4, 0x65, 0x1c, 0x88, 0x43, 0xc5, 0x5c, 0x36, 0xba, 0xf5, 0x57, 0x67, 0x8d, 
   37     0x31, 0xf6, 0x64, 0x58, 0x9e, 0xf4, 0x22, 0xaa, 0x75, 0x0f, 0x02, 0xb1, 0xdf, 0x6d, 0x73, 0x4d, 
   38     0x7c, 0x26, 0x2e, 0xf7, 0x08, 0x5d, 0x44, 0x3e, 0x9f, 0x14, 0xc8, 0xae, 0x54, 0x10, 0xd8, 0xbc, 
   39     0x1a, 0x6b, 0x69, 0xf3, 0xbd, 0x33, 0xab, 0xfa, 0xd1, 0x9b, 0x68, 0x4e, 0x16, 0x95, 0x91, 0xee, 
   40     0x4c, 0x63, 0x8e, 0x5b, 0xcc, 0x3c, 0x19, 0xa1, 0x81, 0x49, 0x7b, 0xd9, 0x6f, 0x37, 0x60, 0xca, 
   41     0xe7, 0x2b, 0x48, 0xfd, 0x96, 0x45, 0xfc, 0x41, 0x12, 0x0d, 0x79, 0xe5, 0x89, 0x8c, 0xe3, 0x20, 
   42     0x30, 0xdc, 0xb7, 0x6c, 0x4a, 0xb5, 0x3f, 0x97, 0xd4, 0x62, 0x2d, 0x06, 0xa4, 0xa5, 0x83, 0x5f, 
   43     0x2a, 0xda, 0xc9, 0x00, 0x7e, 0xa2, 0x55, 0xbf, 0x11, 0xd5, 0x9c, 0xcf, 0x0e, 0x0a, 0x3d, 0x51, 
   44     0x7d, 0x93, 0x1b, 0xfe, 0xc4, 0x47, 0x09, 0x86, 0x0b, 0x8f, 0x9d, 0x6a, 0x07, 0xb9, 0xb0, 0x98, 
   45     0x18, 0x32, 0x71, 0x4b, 0xef, 0x3b, 0x70, 0xa0, 0xe4, 0x40, 0xff, 0xc3, 0xa9, 0xe6, 0x78, 0xf9, 
   46     0x8b, 0x46, 0x80, 0x1e, 0x38, 0xe1, 0xb8, 0xa8, 0xe0, 0x0c, 0x23, 0x76, 0x1d, 0x25, 0x24, 0x05, 
   47     0xf1, 0x6e, 0x94, 0x28, 0x9a, 0x84, 0xe8, 0xa3, 0x4f, 0x77, 0xd3, 0x85, 0xe2, 0x52, 0xf2, 0x82, 
   48     0x50, 0x7a, 0x2f, 0x74, 0x53, 0xb3, 0x61, 0xaf, 0x39, 0x35, 0xde, 0xcd, 0x1f, 0x99, 0xac, 0xad, 
   49     0x72, 0x2c, 0xdd, 0xd0, 0x87, 0xbe, 0x5e, 0xa6, 0xec, 0x04, 0xc6, 0x03, 0x34, 0xfb, 0xdb, 0x59, 
   50     0xb6, 0xc2, 0x01, 0xf0, 0x5a, 0xed, 0xa7, 0x66, 0x21, 0x7f, 0x8a, 0x27, 0xc7, 0xc0, 0x29, 0xd7 
   51 },
   52 {
   53     0x14, 0x9d, 0xb9, 0xe7, 0x67, 0x4c, 0x50, 0x82, 0xca, 0xe5, 0x1d, 0x31, 0x0a, 0xc6, 0xb2, 0x51,
   54     0xa2, 0xd8, 0x54, 0x90, 0xd0, 0xce, 0x2d, 0x7d, 0xc7, 0x7e, 0xd7, 0x94, 0xdf, 0x83, 0x8e, 0x6c,
   55     0x66, 0xd2, 0x6f, 0x16, 0x1e, 0x76, 0xfe, 0xcc, 0xaa, 0x5a, 0x8f, 0x17, 0xbd, 0x2c, 0xac, 0xea,
   56     0x7b, 0x65, 0xa9, 0x10, 0xc0, 0x92, 0xee, 0xbe, 0x6a, 0x6e, 0x48, 0x96, 0x95, 0xe9, 0x32, 0xbc,
   57     0xa1, 0x42, 0xd5, 0xa7, 0x81, 0xb4, 0x5f, 0xe6, 0xc2, 0x5d, 0xad, 0x3a, 0xb7, 0x0c, 0x8d, 0x01,
   58     0x98, 0xfd, 0x12, 0x02, 0x75, 0x13, 0x0f, 0x6b, 0x22, 0xe2, 0xab, 0xf7, 0x7f, 0xba, 0x97, 0xd1,
   59     0x64, 0xd9, 0xc4, 0x59, 0xaf, 0x23, 0x33, 0x37, 0xde, 0xae, 0x60, 0x05, 0x63, 0xa8, 0x52, 0xa5,
   60     0x4e, 0xe0, 0xdd, 0x71, 0xf2, 0x24, 0x34, 0x57, 0x47, 0xa4, 0xb3, 0x9e, 0x2f, 0xc1, 0xb8, 0xcb,
   61     0x2b, 0xd4, 0x0d, 0x36, 0x91, 0x8b, 0x9c, 0x26, 0x25, 0x61, 0xa3, 0xd6, 0xeb, 0x35, 0x53, 0xf4,
   62     0x2e, 0x88, 0x80, 0xe4, 0x30, 0xdb, 0xfc, 0x0e, 0x77, 0x8c, 0x93, 0xa6, 0x78, 0x06, 0xe1, 0xec,
   63     0xf9, 0x03, 0xa0, 0x27, 0xda, 0xef, 0x5c, 0x00, 0x7a, 0x45, 0xe8, 0x40, 0x1a, 0x4b, 0x5e, 0x73,
   64     0xc3, 0xff, 0xf5, 0xf3, 0xb0, 0xc5, 0x49, 0x21, 0xfa, 0x11, 0x39, 0x84, 0x43, 0x38, 0x85, 0x07,
   65     0xf0, 0x79, 0x46, 0xf8, 0xe3, 0x1f, 0x09, 0xb6, 0xcd, 0x55, 0x1c, 0x1b, 0xfb, 0x7c, 0xed, 0x6d,
   66     0x15, 0x56, 0x86, 0x20, 0x68, 0x4a, 0x41, 0x4f, 0xd3, 0x99, 0x08, 0xf6, 0x3f, 0x89, 0x62, 0x04,
   67     0xcf, 0xc8, 0x69, 0x9f, 0x19, 0x5b, 0x44, 0x9b, 0x87, 0xb1, 0x3d, 0xbb, 0xdc, 0x2a, 0xbf, 0x58,
   68     0x3c, 0x8a, 0x18, 0x3e, 0x72, 0x0b, 0x28, 0x4d, 0xb5, 0x9a, 0xc9, 0x74, 0x29, 0xf1, 0x3b, 0x70
   69 
   70 },
   71 {
   72     0x68, 0x8d, 0xca, 0x4d, 0x73, 0x4b, 0x4e, 0x2a, 0xd4, 0x52, 0x26, 0xb3, 0x54, 0x1e, 0x19, 0x1f, 
   73     0x22, 0x03, 0x46, 0x3d, 0x2d, 0x4a, 0x53, 0x83, 0x13, 0x8a, 0xb7, 0xd5, 0x25, 0x79, 0xf5, 0xbd, 
   74     0x58, 0x2f, 0x0d, 0x02, 0xed, 0x51, 0x9e, 0x11, 0xf2, 0x3e, 0x55, 0x5e, 0xd1, 0x16, 0x3c, 0x66, 
   75     0x70, 0x5d, 0xf3, 0x45, 0x40, 0xcc, 0xe8, 0x94, 0x56, 0x08, 0xce, 0x1a, 0x3a, 0xd2, 0xe1, 0xdf, 
   76     0xb5, 0x38, 0x6e, 0x0e, 0xe5, 0xf4, 0xf9, 0x86, 0xe9, 0x4f, 0xd6, 0x85, 0x23, 0xcf, 0x32, 0x99, 
   77     0x31, 0x14, 0xae, 0xee, 0xc8, 0x48, 0xd3, 0x30, 0xa1, 0x92, 0x41, 0xb1, 0x18, 0xc4, 0x2c, 0x71, 
   78     0x72, 0x44, 0x15, 0xfd, 0x37, 0xbe, 0x5f, 0xaa, 0x9b, 0x88, 0xd8, 0xab, 0x89, 0x9c, 0xfa, 0x60, 
   79     0xea, 0xbc, 0x62, 0x0c, 0x24, 0xa6, 0xa8, 0xec, 0x67, 0x20, 0xdb, 0x7c, 0x28, 0xdd, 0xac, 0x5b, 
   80     0x34, 0x7e, 0x10, 0xf1, 0x7b, 0x8f, 0x63, 0xa0, 0x05, 0x9a, 0x43, 0x77, 0x21, 0xbf, 0x27, 0x09, 
   81     0xc3, 0x9f, 0xb6, 0xd7, 0x29, 0xc2, 0xeb, 0xc0, 0xa4, 0x8b, 0x8c, 0x1d, 0xfb, 0xff, 0xc1, 0xb2, 
   82     0x97, 0x2e, 0xf8, 0x65, 0xf6, 0x75, 0x07, 0x04, 0x49, 0x33, 0xe4, 0xd9, 0xb9, 0xd0, 0x42, 0xc7, 
   83     0x6c, 0x90, 0x00, 0x8e, 0x6f, 0x50, 0x01, 0xc5, 0xda, 0x47, 0x3f, 0xcd, 0x69, 0xa2, 0xe2, 0x7a, 
   84     0xa7, 0xc6, 0x93, 0x0f, 0x0a, 0x06, 0xe6, 0x2b, 0x96, 0xa3, 0x1c, 0xaf, 0x6a, 0x12, 0x84, 0x39, 
   85     0xe7, 0xb0, 0x82, 0xf7, 0xfe, 0x9d, 0x87, 0x5c, 0x81, 0x35, 0xde, 0xb4, 0xa5, 0xfc, 0x80, 0xef, 
   86     0xcb, 0xbb, 0x6b, 0x76, 0xba, 0x5a, 0x7d, 0x78, 0x0b, 0x95, 0xe3, 0xad, 0x74, 0x98, 0x3b, 0x36, 
   87     0x64, 0x6d, 0xdc, 0xf0, 0x59, 0xa9, 0x4c, 0x17, 0x7f, 0x91, 0xb8, 0xc9, 0x57, 0x1b, 0xe0, 0x61 
   88 },
   89 {
   90     0xa8, 0x43, 0x5f, 0x06, 0x6b, 0x75, 0x6c, 0x59, 0x71, 0xdf, 0x87, 0x95, 0x17, 0xf0, 0xd8, 0x09, 
   91     0x6d, 0xf3, 0x1d, 0xcb, 0xc9, 0x4d, 0x2c, 0xaf, 0x79, 0xe0, 0x97, 0xfd, 0x6f, 0x4b, 0x45, 0x39, 
   92     0x3e, 0xdd, 0xa3, 0x4f, 0xb4, 0xb6, 0x9a, 0x0e, 0x1f, 0xbf, 0x15, 0xe1, 0x49, 0xd2, 0x93, 0xc6, 
   93     0x92, 0x72, 0x9e, 0x61, 0xd1, 0x63, 0xfa, 0xee, 0xf4, 0x19, 0xd5, 0xad, 0x58, 0xa4, 0xbb, 0xa1, 
   94     0xdc, 0xf2, 0x83, 0x37, 0x42, 0xe4, 0x7a, 0x32, 0x9c, 0xcc, 0xab, 0x4a, 0x8f, 0x6e, 0x04, 0x27, 
   95     0x2e, 0xe7, 0xe2, 0x5a, 0x96, 0x16, 0x23, 0x2b, 0xc2, 0x65, 0x66, 0x0f, 0xbc, 0xa9, 0x47, 0x41, 
   96     0x34, 0x48, 0xfc, 0xb7, 0x6a, 0x88, 0xa5, 0x53, 0x86, 0xf9, 0x5b, 0xdb, 0x38, 0x7b, 0xc3, 0x1e, 
   97     0x22, 0x33, 0x24, 0x28, 0x36, 0xc7, 0xb2, 0x3b, 0x8e, 0x77, 0xba, 0xf5, 0x14, 0x9f, 0x08, 0x55, 
   98     0x9b, 0x4c, 0xfe, 0x60, 0x5c, 0xda, 0x18, 0x46, 0xcd, 0x7d, 0x21, 0xb0, 0x3f, 0x1b, 0x89, 0xff, 
   99     0xeb, 0x84, 0x69, 0x3a, 0x9d, 0xd7, 0xd3, 0x70, 0x67, 0x40, 0xb5, 0xde, 0x5d, 0x30, 0x91, 0xb1, 
  100     0x78, 0x11, 0x01, 0xe5, 0x00, 0x68, 0x98, 0xa0, 0xc5, 0x02, 0xa6, 0x74, 0x2d, 0x0b, 0xa2, 0x76, 
  101     0xb3, 0xbe, 0xce, 0xbd, 0xae, 0xe9, 0x8a, 0x31, 0x1c, 0xec, 0xf1, 0x99, 0x94, 0xaa, 0xf6, 0x26, 
  102     0x2f, 0xef, 0xe8, 0x8c, 0x35, 0x03, 0xd4, 0x7f, 0xfb, 0x05, 0xc1, 0x5e, 0x90, 0x20, 0x3d, 0x82, 
  103     0xf7, 0xea, 0x0a, 0x0d, 0x7e, 0xf8, 0x50, 0x1a, 0xc4, 0x07, 0x57, 0xb8, 0x3c, 0x62, 0xe3, 0xc8, 
  104     0xac, 0x52, 0x64, 0x10, 0xd0, 0xd9, 0x13, 0x0c, 0x12, 0x29, 0x51, 0xb9, 0xcf, 0xd6, 0x73, 0x8d, 
  105     0x81, 0x54, 0xc0, 0xed, 0x4e, 0x44, 0xa7, 0x2a, 0x85, 0x25, 0xe6, 0xca, 0x7c, 0x8b, 0x56, 0x80 
  106 }
  107 };
  108 
  109 
  110 uint8_t mea_invSbox[4][256] = {
  111 {
  112     0x83, 0xf2, 0x2a, 0xeb, 0xe9, 0xbf, 0x7b, 0x9c, 0x34, 0x96, 0x8d, 0x98, 0xb9, 0x69, 0x8c, 0x29, 
  113     0x3d, 0x88, 0x68, 0x06, 0x39, 0x11, 0x4c, 0x0e, 0xa0, 0x56, 0x40, 0x92, 0x15, 0xbc, 0xb3, 0xdc, 
  114     0x6f, 0xf8, 0x26, 0xba, 0xbe, 0xbd, 0x31, 0xfb, 0xc3, 0xfe, 0x80, 0x61, 0xe1, 0x7a, 0x32, 0xd2, 
  115     0x70, 0x20, 0xa1, 0x45, 0xec, 0xd9, 0x1a, 0x5d, 0xb4, 0xd8, 0x09, 0xa5, 0x55, 0x8e, 0x37, 0x76, 
  116     0xa9, 0x67, 0x10, 0x17, 0x36, 0x65, 0xb1, 0x95, 0x62, 0x59, 0x74, 0xa3, 0x50, 0x2f, 0x4b, 0xc8, 
  117     0xd0, 0x8f, 0xcd, 0xd4, 0x3c, 0x86, 0x12, 0x1d, 0x23, 0xef, 0xf4, 0x53, 0x19, 0x35, 0xe6, 0x7f, 
  118     0x5e, 0xd6, 0x79, 0x51, 0x22, 0x14, 0xf7, 0x1e, 0x4a, 0x42, 0x9b, 0x41, 0x73, 0x2d, 0xc1, 0x5c, 
  119     0xa6, 0xa2, 0xe0, 0x2e, 0xd3, 0x28, 0xbb, 0xc9, 0xae, 0x6a, 0xd1, 0x5a, 0x30, 0x90, 0x84, 0xf9, 
  120     0xb2, 0x58, 0xcf, 0x7e, 0xc5, 0xcb, 0x97, 0xe4, 0x16, 0x6c, 0xfa, 0xb0, 0x6d, 0x1f, 0x52, 0x99, 
  121     0x0d, 0x4e, 0x03, 0x91, 0xc2, 0x4d, 0x64, 0x77, 0x9f, 0xdd, 0xc4, 0x49, 0x8a, 0x9a, 0x24, 0x38, 
  122     0xa7, 0x57, 0x85, 0xc7, 0x7c, 0x7d, 0xe7, 0xf6, 0xb7, 0xac, 0x27, 0x46, 0xde, 0xdf, 0x3b, 0xd7, 
  123     0x9e, 0x2b, 0x0b, 0xd5, 0x13, 0x75, 0xf0, 0x72, 0xb6, 0x9d, 0x1b, 0x01, 0x3f, 0x44, 0xe5, 0x87, 
  124     0xfd, 0x07, 0xf1, 0xab, 0x94, 0x18, 0xea, 0xfc, 0x3a, 0x82, 0x5f, 0x05, 0x54, 0xdb, 0x00, 0x8b, 
  125     0xe3, 0x48, 0x0c, 0xca, 0x78, 0x89, 0x0a, 0xff, 0x3e, 0x5b, 0x81, 0xee, 0x71, 0xe2, 0xda, 0x2c, 
  126     0xb8, 0xb5, 0xcc, 0x6e, 0xa8, 0x6b, 0xad, 0x60, 0xc6, 0x08, 0x04, 0x02, 0xe8, 0xf5, 0x4f, 0xa4, 
  127     0xf3, 0xc0, 0xce, 0x43, 0x25, 0x1c, 0x21, 0x33, 0x0f, 0xaf, 0x47, 0xed, 0x66, 0x63, 0x93, 0xaa
  128 },
  129 {
  130     0xa7, 0x4f, 0x53, 0xa1, 0xdf, 0x6b, 0x9d, 0xbf, 0xda, 0xc6, 0x0c, 0xf5, 0x4d, 0x82, 0x97, 0x56,
  131     0x33, 0xb9, 0x52, 0x55, 0x00, 0xd0, 0x23, 0x2b, 0xf2, 0xe4, 0xac, 0xcb, 0xca, 0x0a, 0x24, 0xc5,
  132     0xd3, 0xb7, 0x58, 0x65, 0x75, 0x88, 0x87, 0xa3, 0xf6, 0xfc, 0xed, 0x80, 0x2d, 0x16, 0x90, 0x7c,
  133     0x94, 0x0b, 0x3e, 0x66, 0x76, 0x8d, 0x83, 0x67, 0xbd, 0xba, 0x4b, 0xfe, 0xf0, 0xea, 0xf3, 0xdc,
  134     0xab, 0xd6, 0x41, 0xbc, 0xe6, 0xa9, 0xc2, 0x78, 0x3a, 0xb6, 0xd5, 0xad, 0x05, 0xf7, 0x70, 0xd7,
  135     0x06, 0x0f, 0x6e, 0x8e, 0x12, 0xc9, 0xd1, 0x77, 0xef, 0x63, 0x29, 0xe5, 0xa6, 0x49, 0xae, 0x46,
  136     0x6a, 0x89, 0xde, 0x6c, 0x60, 0x31, 0x20, 0x04, 0xd4, 0xe2, 0x38, 0x57, 0x1f, 0xcf, 0x39, 0x22,
  137     0xff, 0x73, 0xf4, 0xaf, 0xfb, 0x54, 0x25, 0x98, 0x9c, 0xc1, 0xa8, 0x30, 0xcd, 0x17, 0x19, 0x5c,
  138     0x92, 0x44, 0x07, 0x1d, 0xbb, 0xbe, 0xd2, 0xe8, 0x91, 0xdd, 0xf1, 0x85, 0x99, 0x4e, 0x1e, 0x2a, 
  139     0x13, 0x84, 0x35, 0x9a, 0x1b, 0x3c, 0x3b, 0x5e, 0x50, 0xd9, 0xf9, 0xe7, 0x86, 0x01, 0x7b, 0xe3,
  140     0xa2, 0x40, 0x10, 0x8a, 0x79, 0x6f, 0x9b, 0x43, 0x6d, 0x32, 0x28, 0x5a, 0x2e, 0x4a, 0x69, 0x64,
  141     0xb4, 0xe9, 0x0e, 0x7a, 0x45, 0xf8, 0xc7, 0x4c, 0x7e, 0x02, 0x5d, 0xeb, 0x3f, 0x2c, 0x37, 0xee,
  142     0x34, 0x7d, 0x48, 0xb0, 0x62, 0xb5, 0x0d, 0x18, 0xe1, 0xfa, 0x08, 0x7f, 0x27, 0xc8, 0x15, 0xe0,
  143     0x14, 0x5f, 0x21, 0xd8, 0x81, 0x42, 0x8b, 0x1a, 0x11, 0x61, 0xa4, 0x95, 0xec, 0x72, 0x68, 0x1c,
  144     0x71, 0x9e, 0x59, 0xc4, 0x93, 0x09, 0x47, 0x03, 0xaa, 0x3d, 0x2f, 0x8c, 0x9f, 0xce, 0x36, 0xa5,
  145     0xc0, 0xfd, 0x74, 0xb3, 0x8f, 0xb2, 0xdb, 0x5b, 0xc3, 0xa0, 0xb8, 0xcc, 0x96, 0x51, 0x26, 0xb1
  146 },
  147 {
  148     0xb2, 0xb6, 0x23, 0x11, 0xa7, 0x88, 0xc5, 0xa6, 0x39, 0x8f, 0xc4, 0xe8, 0x73, 0x22, 0x43, 0xc3, 
  149     0x82, 0x27, 0xcd, 0x18, 0x51, 0x62, 0x2d, 0xf7, 0x5c, 0x0e, 0x3b, 0xfd, 0xca, 0x9b, 0x0d, 0x0f, 
  150     0x79, 0x8c, 0x10, 0x4c, 0x74, 0x1c, 0x0a, 0x8e, 0x7c, 0x94, 0x07, 0xc7, 0x5e, 0x14, 0xa1, 0x21, 
  151     0x57, 0x50, 0x4e, 0xa9, 0x80, 0xd9, 0xef, 0x64, 0x41, 0xcf, 0x3c, 0xee, 0x2e, 0x13, 0x29, 0xba, 
  152     0x34, 0x5a, 0xae, 0x8a, 0x61, 0x33, 0x12, 0xb9, 0x55, 0xa8, 0x15, 0x05, 0xf6, 0x03, 0x06, 0x49, 
  153     0xb5, 0x25, 0x09, 0x16, 0x0c, 0x2a, 0x38, 0xfc, 0x20, 0xf4, 0xe5, 0x7f, 0xd7, 0x31, 0x2b, 0x66, 
  154     0x6f, 0xff, 0x72, 0x86, 0xf0, 0xa3, 0x2f, 0x78, 0x00, 0xbc, 0xcc, 0xe2, 0xb0, 0xf1, 0x42, 0xb4, 
  155     0x30, 0x5f, 0x60, 0x04, 0xec, 0xa5, 0xe3, 0x8b, 0xe7, 0x1d, 0xbf, 0x84, 0x7b, 0xe6, 0x81, 0xf8, 
  156     0xde, 0xd8, 0xd2, 0x17, 0xce, 0x4b, 0x47, 0xd6, 0x69, 0x6c, 0x19, 0x99, 0x9a, 0x01, 0xb3, 0x85, 
  157     0xb1, 0xf9, 0x59, 0xc2, 0x37, 0xe9, 0xc8, 0xa0, 0xed, 0x4f, 0x89, 0x68, 0x6d, 0xd5, 0x26, 0x91, 
  158     0x87, 0x58, 0xbd, 0xc9, 0x98, 0xdc, 0x75, 0xc0, 0x76, 0xf5, 0x67, 0x6b, 0x7e, 0xeb, 0x52, 0xcb, 
  159     0xd1, 0x5b, 0x9f, 0x0b, 0xdb, 0x40, 0x92, 0x1a, 0xfa, 0xac, 0xe4, 0xe1, 0x71, 0x1f, 0x65, 0x8d, 
  160     0x97, 0x9e, 0x95, 0x90, 0x5d, 0xb7, 0xc1, 0xaf, 0x54, 0xfb, 0x02, 0xe0, 0x35, 0xbb, 0x3a, 0x4d, 
  161     0xad, 0x2c, 0x3d, 0x56, 0x08, 0x1b, 0x4a, 0x93, 0x6a, 0xab, 0xb8, 0x7a, 0xf2, 0x7d, 0xda, 0x3f, 
  162     0xfe, 0x3e, 0xbe, 0xea, 0xaa, 0x44, 0xc6, 0xd0, 0x36, 0x48, 0x70, 0x96, 0x77, 0x24, 0x53, 0xdf, 
  163     0xf3, 0x83, 0x28, 0x32, 0x45, 0x1e, 0xa4, 0xd3, 0xa2, 0x46, 0x6e, 0x9c, 0xdd, 0x63, 0xd4, 0x9d
  164 },
  165 {
  166     0xa4, 0xa2, 0xa9, 0xc5, 0x4e, 0xc9, 0x03, 0xd9, 0x7e, 0x0f, 0xd2, 0xad, 0xe7, 0xd3, 0x27, 0x5b, 
  167     0xe3, 0xa1, 0xe8, 0xe6, 0x7c, 0x2a, 0x55, 0x0c, 0x86, 0x39, 0xd7, 0x8d, 0xb8, 0x12, 0x6f, 0x28, 
  168     0xcd, 0x8a, 0x70, 0x56, 0x72, 0xf9, 0xbf, 0x4f, 0x73, 0xe9, 0xf7, 0x57, 0x16, 0xac, 0x50, 0xc0, 
  169     0x9d, 0xb7, 0x47, 0x71, 0x60, 0xc4, 0x74, 0x43, 0x6c, 0x1f, 0x93, 0x77, 0xdc, 0xce, 0x20, 0x8c, 
  170     0x99, 0x5f, 0x44, 0x01, 0xf5, 0x1e, 0x87, 0x5e, 0x61, 0x2c, 0x4b, 0x1d, 0x81, 0x15, 0xf4, 0x23, 
  171     0xd6, 0xea, 0xe1, 0x67, 0xf1, 0x7f, 0xfe, 0xda, 0x3c, 0x07, 0x53, 0x6a, 0x84, 0x9c, 0xcb, 0x02, 
  172     0x83, 0x33, 0xdd, 0x35, 0xe2, 0x59, 0x5a, 0x98, 0xa5, 0x92, 0x64, 0x04, 0x06, 0x10, 0x4d, 0x1c, 
  173     0x97, 0x08, 0x31, 0xee, 0xab, 0x05, 0xaf, 0x79, 0xa0, 0x18, 0x46, 0x6d, 0xfc, 0x89, 0xd4, 0xc7, 
  174     0xff, 0xf0, 0xcf, 0x42, 0x91, 0xf8, 0x68, 0x0a, 0x65, 0x8e, 0xb6, 0xfd, 0xc3, 0xef, 0x78, 0x4c, 
  175     0xcc, 0x9e, 0x30, 0x2e, 0xbc, 0x0b, 0x54, 0x1a, 0xa6, 0xbb, 0x26, 0x80, 0x48, 0x94, 0x32, 0x7d, 
  176     0xa7, 0x3f, 0xae, 0x22, 0x3d, 0x66, 0xaa, 0xf6, 0x00, 0x5d, 0xbd, 0x4a, 0xe0, 0x3b, 0xb4, 0x17, 
  177     0x8b, 0x9f, 0x76, 0xb0, 0x24, 0x9a, 0x25, 0x63, 0xdb, 0xeb, 0x7a, 0x3e, 0x5c, 0xb3, 0xb1, 0x29, 
  178     0xf2, 0xca, 0x58, 0x6e, 0xd8, 0xa8, 0x2f, 0x75, 0xdf, 0x14, 0xfb, 0x13, 0x49, 0x88, 0xb2, 0xec, 
  179     0xe4, 0x34, 0x2d, 0x96, 0xc6, 0x3a, 0xed, 0x95, 0x0e, 0xe5, 0x85, 0x6b, 0x40, 0x21, 0x9b, 0x09, 
  180     0x19, 0x2b, 0x52, 0xde, 0x45, 0xa3, 0xfa, 0x51, 0xc2, 0xb5, 0xd1, 0x90, 0xb9, 0xf3, 0x37, 0xc1, 
  181     0x0d, 0xba, 0x41, 0x11, 0x38, 0x7b, 0xbe, 0xd0, 0xd5, 0x69, 0x36, 0xc8, 0x62, 0x1b, 0x82, 0x8f
  182 }
  183 };

</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001014000000000000000">
mea.c</A>
</H2>
<SPAN CLASS="SMALL"></SPAN><TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*
    2  *  Projekt :   MEA
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   mea.c
    5  */
    6 
    7 #include &lt;stdint.h&gt;
    8 #include &lt;stdio.h&gt;
    9 #include &lt;stdlib.h&gt;
   10 #include &lt;string.h&gt;
   11 
   12 #include "mea.h"
   13 #include "tables.h"
   14 
   15 int mea_xorRoundKey(mea_t *mea_ctx, int round);
   16 
   17 uint64_t __reverseWord(uint64_t in) { return __builtin_bswap64(in); }
   18 
   19 uint8_t *__wordsToBytes(uint64_t *in) { return (uint8_t *)in; }
   20 
   21 uint64_t *__bytesToWords(uint8_t *in) { return (uint64_t *)in; }
   22 
   23 uint8_t __multiplyGF(uint8_t a, uint8_t b) {
   24   uint8_t res = 0, hbs = 0;
   25 
   26   for (int i = 0; i &lt; 0x08; i++) {
   27     if ((b &amp; 0x01) == 1) {
   28       res ^= a;
   29     }
   30 
   31     hbs = (a &amp; 0x80);
   32     a &lt;&lt;= 1;
   33 
   34     if (hbs == 0x80) {
   35       a ^= 0x11d; // m(x) = x8 + x4 + x3 + x2 +1
   36     }
   37     b &gt;&gt;= 1;
   38   }
   39 
   40   return res;
   41 }
   42 
   43 int __matrixMultiplywState(mea_t *mea_ctx, uint8_t in_matrix[8][8]) {
   44   int n_col, n_row, b;
   45   uint8_t pr;
   46   uint64_t res;
   47   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
   48 
   49   for (n_col = 0; n_col &lt; MEA_NW_STATE; n_col++) {
   50     res = 0;
   51     for (n_row = sizeof(uint64_t) - 1; n_row &gt;= 0; n_row--) {
   52       pr = 0;
   53       for (b = sizeof(uint64_t) - 1; b &gt;= 0; b--) {
   54         pr ^= __multiplyGF(BYTE_TO_M_STATE(pmstate, b, n_col),
   55                            in_matrix[n_row][b]);
   56       }
   57       res |= (uint64_t)pr &lt;&lt; (n_row * sizeof(uint64_t));
   58     }
   59     mea_ctx-&gt;m_state[n_col] = res;
   60   }
   61 
   62   return 0;
   63 }
   64 
   65 int __returnFncRnd(mea_t *mea_ctx, uint8_t *in, int i, int rKP, int dRP) {
   66   if (in[i] == MEA_FNC_HRSR)
   67     mea_horShiftRows(mea_ctx);
   68 
   69   else if (in[i] == MEA_FNC_SBB)
   70     mea_subBytes(mea_ctx);
   71 
   72   else if (in[i] == MEA_FNC_VRSC)
   73     mea_verShiftColumns(mea_ctx);
   74 
   75   else if (in[i] == MEA_FNC_MXCL)
   76     mea_mixColumns(mea_ctx);
   77 
   78   else if (in[i] == MEA_FNC_DRT)
   79     mea_dimRotate(mea_ctx, dRP);
   80 
   81   else if (in[i] == MEA_FNC_XRK)
   82     mea_xorRoundKey(mea_ctx, rKP);
   83 
   84   else
   85     return -1;
   86 
   87   return 1;
   88 }
   89 
   90 int __returnInvFncRnd(mea_t *mea_ctx, uint8_t *in, int i, int rKP, int dRP) {
   91   if (in[i] == MEA_FNC_HRSR)
   92     mea_invHorShiftRows(mea_ctx);
   93 
   94   else if (in[i] == MEA_FNC_SBB)
   95     mea_invSubBytes(mea_ctx);
   96 
   97   else if (in[i] == MEA_FNC_VRSC)
   98     mea_invVerShiftColumns(mea_ctx);
   99 
  100   else if (in[i] == MEA_FNC_MXCL)
  101     mea_invMixColumns(mea_ctx);
  102 
  103   else if (in[i] == MEA_FNC_DRT)
  104     mea_invDimRotate(mea_ctx, dRP);
  105 
  106   else if (in[i] == MEA_FNC_XRK)
  107     mea_xorRoundKey(mea_ctx, rKP);
  108 
  109   else
  110     return -1;
  111 
  112   return 1;
  113 }
  114 
  115 uint8_t __returnVInt(uint8_t in) {
  116   if (in &lt;= 0x2A) // 42
  117     return 0x00;
  118 
  119   else if (in &lt;= 0x54) // 84
  120     return 0x01;
  121 
  122   else if (in &lt;= 0x7E) // 126
  123     return 0x02;
  124 
  125   else if (in &lt;= 0xA8) // 168
  126     return 0x03;
  127 
  128   else if (in &lt;= 0xD2) // 210
  129     return 0x04;
  130 
  131   else if (in &lt;= 0xFC) // 252
  132     return 0x05;
  133   else
  134     return 0x05;
  135 }
  136 
  137 mea_t *mea_init() {
  138   mea_t *mea_ctx = (mea_t *)malloc(sizeof(mea_t));
  139 
  140   if (mea_ctx == NULL)
  141     return NULL;
  142 
  143   mea_ctx-&gt;m_state = (uint64_t *)calloc(MEA_NW_STATE, sizeof(uint64_t));
  144   if (mea_ctx-&gt;m_state == NULL)
  145     return NULL;
  146 
  147   mea_ctx-&gt;r_seq = calloc(MEA_SUB_ROUNDS * MEA_M_ROUNDS / 2, sizeof(uint8_t *));
  148   if (mea_ctx-&gt;r_seq == NULL)
  149     return NULL;
  150 
  151   for (int i = 0; i &lt; MEA_SUB_ROUNDS * MEA_M_ROUNDS / 2; i++) {
  152     mea_ctx-&gt;r_seq[i] = (uint8_t *)calloc(MEA_M_ROUNDS, sizeof(uint8_t));
  153 
  154     if (mea_ctx-&gt;r_seq[i] == NULL)
  155       return NULL;
  156   }
  157 
  158   mea_ctx-&gt;r_keys =
  159       (uint64_t **)calloc(MEA_SUB_ROUNDS * MEA_M_ROUNDS, sizeof(uint64_t **));
  160   if (mea_ctx-&gt;r_keys == NULL)
  161     return NULL;
  162 
  163   for (int i = 0; i &lt; MEA_SUB_ROUNDS * MEA_M_ROUNDS; i++) {
  164     mea_ctx-&gt;r_keys[i] = (uint64_t *)calloc(MEA_NW_KEY, sizeof(uint64_t));
  165 
  166     if (mea_ctx-&gt;r_keys[i] == NULL)
  167       return NULL;
  168   }
  169 
  170   return mea_ctx;
  171 }
  172 
  173 int mea_del(mea_t *mea_ctx) {
  174   free(mea_ctx-&gt;m_state);
  175 
  176   for (int i = 0; i &lt; MEA_SUB_ROUNDS * MEA_M_ROUNDS; i++) {
  177     free(mea_ctx-&gt;r_keys[i]);
  178   }
  179 
  180   for (int i = 0; i &lt; MEA_M_ROUNDS; i++) {
  181     free(mea_ctx-&gt;r_seq[i]);
  182   }
  183 
  184   free(mea_ctx-&gt;r_keys);
  185   free(mea_ctx-&gt;r_seq);
  186   free(mea_ctx);
  187 
  188   mea_ctx = NULL;
  189   return 0;
  190 }
  191 
  192 int mea_generateRKeys(mea_t *mea_ctx, uint64_t *mkey) {
  193   uint64_t *ntmp;
  194 
  195   for (int r = 0; r &lt; MEA_SUB_ROUNDS * MEA_M_ROUNDS; r++) {
  196     int tmp, tmp2;
  197     uint64_t *inpoi;
  198 
  199     ntmp = mea_ctx-&gt;r_keys[r];
  200     if (r == 0)
  201       inpoi = mkey;
  202 
  203     else
  204       inpoi = mea_ctx-&gt;r_keys[r - 1];
  205 
  206     for (int l = 0; l &lt; MEA_NW_KEY; l++) {
  207       ntmp[l] = inpoi[l] ^ RKCON;
  208     }
  209 
  210     for (int i = 0; i &lt; MEA_NW_KEY; i++) {
  211       ntmp[i] =
  212           mea_sbox[0x01][(ntmp[i] &amp; 0x00000000000000FF)] |
  213           ((uint64_t)mea_sbox[0x00][(ntmp[i] &amp; 0x000000000000FF00) &gt;&gt; 0x08]
  214            &lt;&lt; 0x08) |
  215           ((uint64_t)mea_sbox[0x03][(ntmp[i] &amp; 0x0000000000FF0000) &gt;&gt; 0x10]
  216            &lt;&lt; 0x10) |
  217           ((uint64_t)mea_sbox[0x02][(ntmp[i] &amp; 0x00000000FF000000) &gt;&gt; 0x18]
  218            &lt;&lt; 0x18) |
  219           ((uint64_t)mea_sbox[0x03][(ntmp[i] &amp; 0x000000FF00000000) &gt;&gt; 0x20]
  220            &lt;&lt; 0x20) |
  221           ((uint64_t)mea_sbox[0x00][(ntmp[i] &amp; 0x0000FF0000000000) &gt;&gt; 0x28]
  222            &lt;&lt; 0x28) |
  223           ((uint64_t)mea_sbox[0x01][(ntmp[i] &amp; 0x00FF000000000000) &gt;&gt; 0x30]
  224            &lt;&lt; 0x30) |
  225           ((uint64_t)mea_sbox[0x02][(ntmp[i] &amp; 0xFF00000000000000) &gt;&gt; 0x38]
  226            &lt;&lt; 0x38);
  227     }
  228 
  229     uint8_t *tmp_key = __wordsToBytes(ntmp);
  230     for (int z = 0; z &lt; MEA_MS_DIM + 1; z++) {
  231       for (int i = 1; i &lt; MEA_MS_ROW; i++) {
  232         int s = 0;
  233         while (s &lt; i) {
  234           tmp = tmp_key[MEA_MS_IN_DIM * z + i];
  235 
  236           for (int k = 1; k &lt; MEA_MS_ROW; k++) {
  237             tmp_key[MEA_MS_IN_DIM * z + (MEA_MS_ROW * (k - 1)) + i] =
  238                 tmp_key[MEA_MS_IN_DIM * z + MEA_MS_ROW * k + i];
  239           }
  240 
  241           tmp_key[MEA_MS_IN_DIM * z + (MEA_MS_ROW * (MEA_MS_ROW - 1)) + i] =
  242               tmp;
  243           s++;
  244         }
  245       }
  246     }
  247 
  248     for (int i = 0; i &lt; MEA_MS_ROW; i++) {
  249       for (int k = 0; k &lt; MEA_MS_ROW; k++) {
  250         tmp2 = tmp_key[MEA_MS_IN_DIM * 0x02 + MEA_MS_ROW * i + k];
  251         tmp_key[MEA_MS_IN_DIM * 0x02 + MEA_MS_ROW * i + k] =
  252             tmp_key[MEA_MS_IN_DIM * 0x03 + MEA_MS_ROW * i + k];
  253         tmp_key[MEA_MS_IN_DIM * 0x03 + MEA_MS_ROW * i + k] = tmp2;
  254       }
  255     }
  256 
  257     ntmp = __bytesToWords(tmp_key);
  258     for (int i = 0; i &lt; MEA_NW_KEY; i++) {
  259       ntmp[i] = ntmp[i] ^ inpoi[i];
  260     }
  261   }
  262 
  263   for (int i = 0; i &lt; MEA_M_ROUNDS * MEA_SUB_ROUNDS / 2; i++) {
  264     uint8_t *tmp = mea_ctx-&gt;r_seq[i];
  265 
  266     for (int j = 0; j &lt; MEA_SUB_ROUNDS; j++) {
  267       tmp[j] = j;
  268     }
  269   }
  270 
  271   mea_rSeqGen(mea_ctx);
  272   return 0;
  273 }
  274 
  275 int mea_rSeqGen(mea_t *mea_ctx) {
  276   for (int w = 0; w &lt; MEA_M_ROUNDS; w++) {
  277     for (int i = 0; i &lt; MEA_M_ROUNDS * MEA_SUB_ROUNDS / 2; i++) {
  278       uint8_t *tmp_key = (uint8_t *)mea_ctx-&gt;r_keys[i + w];
  279       uint8_t *tmp_nseq = mea_ctx-&gt;r_seq[i];
  280 
  281       for (int j = 0; j &lt; MEA_SUB_ROUNDS - 1; j++) {
  282         uint8_t tmp_p = __returnVInt(tmp_key[j]);
  283         uint8_t tmp_op;
  284 
  285         tmp_op = tmp_nseq[tmp_p];
  286         tmp_nseq[tmp_p] = tmp_nseq[__returnVInt(tmp_key[j + 1])];
  287         tmp_nseq[__returnVInt(tmp_key[j + 1])] = tmp_op;
  288       }
  289     }
  290   }
  291   return 0;
  292 }
  293 
  294 int mea_blockEncipher(mea_t *mea_ctx, uint64_t *plain, uint64_t *cipher) {
  295   memcpy(mea_ctx-&gt;m_state, plain, MEA_NW_STATE * sizeof(uint64_t));
  296 
  297   for (int i = 0; i &lt; MEA_M_ROUNDS; i++) {
  298     for (int j = 0; j &lt; MEA_SUB_ROUNDS; j++) {
  299       if (j % 2 == 0) {
  300         mea_horShiftRows(mea_ctx);
  301         mea_subBytes(mea_ctx);
  302 
  303         mea_verShiftColumns(mea_ctx);
  304         mea_mixColumns(mea_ctx);
  305 
  306         mea_dimRotate(mea_ctx, j / 2);
  307         mea_xorRoundKey(mea_ctx, i * MEA_M_ROUNDS + j);
  308       } else {
  309         uint8_t *tmp_seq = mea_ctx-&gt;r_seq[((i * MEA_M_ROUNDS + j + 1) / 2) - 1];
  310 
  311         for (int rndR = 0; rndR &lt; MEA_SUB_ROUNDS; rndR++) {
  312 
  313           __returnFncRnd(mea_ctx, tmp_seq, rndR, i * MEA_M_ROUNDS + j,
  314                          (j + 1) / 2);
  315         }
  316 
  317         mea_xorRoundKey(mea_ctx, i * MEA_M_ROUNDS + j);
  318       }
  319     }
  320   }
  321 
  322   memcpy(cipher, mea_ctx-&gt;m_state, MEA_NW_STATE * sizeof(uint64_t));
  323   return 0;
  324 }
  325 
  326 int mea_blockDecipher(mea_t *mea_ctx, uint64_t *cipher, uint64_t *plain) {
  327   memcpy(mea_ctx-&gt;m_state, cipher, MEA_NW_STATE * sizeof(uint64_t));
  328 
  329   for (int i = MEA_M_ROUNDS; i &gt; 0; i--) {
  330     for (int j = MEA_SUB_ROUNDS; j &gt; 0; j--) {
  331 
  332       if ((j - 1) % 2 == 0) {
  333         mea_xorRoundKey(mea_ctx, (i - 1) * MEA_M_ROUNDS + (j - 1));
  334         mea_invDimRotate(mea_ctx, ((j - 1) / 2));
  335 
  336         mea_invMixColumns(mea_ctx);
  337         mea_invVerShiftColumns(mea_ctx);
  338 
  339         mea_invSubBytes(mea_ctx);
  340         mea_invHorShiftRows(mea_ctx);
  341       } else {
  342         uint8_t *tmp_seq = mea_ctx-&gt;r_seq[((i - 1) * MEA_M_ROUNDS + j - 2) / 2];
  343 
  344         mea_xorRoundKey(mea_ctx, (i - 1) * MEA_M_ROUNDS + (j - 1));
  345         for (int rndR = MEA_SUB_ROUNDS; rndR &gt; 0; rndR--) {
  346 
  347           __returnInvFncRnd(mea_ctx, tmp_seq, rndR - 1,
  348                             (i - 1) * MEA_M_ROUNDS + (j - 1), j / 2);
  349         }
  350       }
  351     }
  352   }
  353 
  354   memcpy(plain, mea_ctx-&gt;m_state, MEA_NW_STATE * sizeof(uint64_t));
  355   return 0;
  356 }
  357 
  358 int mea_verShiftColumns(mea_t *mea_ctx) {
  359   uint8_t z, i, k, s, tmp;
  360   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  361 
  362   for (z = 0; z &lt; MEA_MS_DIM + 1; z++) {
  363     for (i = 1; i &lt; MEA_MS_ROW; i++) {
  364       s = 0;
  365       while (s &lt; i) {
  366         tmp = pmstate[MEA_MS_IN_DIM * z + (MEA_MS_ROW * (MEA_MS_ROW - 1)) + i];
  367 
  368         for (k = MEA_MS_ROW - 1; k &gt; 0; k--) {
  369           pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * k + i] =
  370               pmstate[MEA_MS_IN_DIM * z + (MEA_MS_ROW * (k - 1)) + i];
  371         }
  372 
  373         pmstate[MEA_MS_IN_DIM * z + i] = tmp;
  374         s++;
  375       }
  376     }
  377   }
  378 
  379   mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  380   return 0;
  381 }
  382 
  383 int mea_invVerShiftColumns(mea_t *mea_ctx) {
  384   uint8_t z, i, k, s, tmp;
  385   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  386 
  387   for (z = 0; z &lt; MEA_MS_DIM + 1; z++) {
  388     for (i = 1; i &lt; MEA_MS_ROW; i++) {
  389       s = 0;
  390       while (s &lt; i) {
  391         tmp = pmstate[MEA_MS_IN_DIM * z + i];
  392 
  393         for (k = 1; k &lt; MEA_MS_ROW; k++) {
  394           pmstate[MEA_MS_IN_DIM * z + (MEA_MS_ROW * (k - 1)) + i] =
  395               pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * k + i];
  396         }
  397 
  398         pmstate[MEA_MS_IN_DIM * z + (MEA_MS_ROW * (MEA_MS_ROW - 1)) + i] = tmp;
  399         s++;
  400       }
  401     }
  402   }
  403 
  404   mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  405   return 0;
  406 }
  407 
  408 int mea_horShiftRows(mea_t *mea_ctx) {
  409   uint8_t z, i, k, s, tmp;
  410   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  411 
  412   for (z = 0; z &lt; MEA_MS_DIM + 1; z++) {
  413     for (i = 1; i &lt; MEA_MS_ROW; i++) {
  414       s = 0;
  415       while (s &lt; i) {
  416         tmp = pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + MEA_MS_ROW - 1];
  417 
  418         for (k = MEA_MS_ROW - 1; k &gt; 0; k--) {
  419           pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + k] =
  420               pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + k - 1];
  421         }
  422 
  423         pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i] = tmp;
  424         s++;
  425       }
  426     }
  427   }
  428 
  429   mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  430   return 0;
  431 }
  432 
  433 int mea_invHorShiftRows(mea_t *mea_ctx) {
  434   uint8_t z, i, k, s, tmp;
  435   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  436 
  437   for (z = 0; z &lt; MEA_MS_DIM + 1; z++) {
  438     for (i = 1; i &lt; MEA_MS_ROW; i++) {
  439       s = 0;
  440       while (s &lt; i) {
  441         tmp = pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + 0];
  442 
  443         for (k = 1; k &lt; MEA_MS_ROW; k++) {
  444           pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + k - 1] =
  445               pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + k];
  446         }
  447 
  448         pmstate[MEA_MS_IN_DIM * z + MEA_MS_ROW * i + MEA_MS_ROW - 1] = tmp;
  449         s++;
  450       }
  451     }
  452   }
  453 
  454   mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  455   return 0;
  456 }
  457 
  458 int mea_subBytes(mea_t *mea_ctx) {
  459   for (int i = 0; i &lt; MEA_NW_STATE; i++) {
  460     mea_ctx-&gt;m_state[i] =
  461         mea_sbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x00000000000000FF)] |
  462         ((uint64_t)
  463              mea_sbox[0x01][(mea_ctx-&gt;m_state[i] &amp; 0x000000000000FF00) &gt;&gt; 0x08]
  464          &lt;&lt; 0x08) |
  465         ((uint64_t)
  466              mea_sbox[0x02][(mea_ctx-&gt;m_state[i] &amp; 0x0000000000FF0000) &gt;&gt; 0x10]
  467          &lt;&lt; 0x10) |
  468         ((uint64_t)
  469              mea_sbox[0x03][(mea_ctx-&gt;m_state[i] &amp; 0x00000000FF000000) &gt;&gt; 0x18]
  470          &lt;&lt; 0x18) |
  471         ((uint64_t)
  472              mea_sbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x000000FF00000000) &gt;&gt; 0x20]
  473          &lt;&lt; 0x20) |
  474         ((uint64_t)
  475              mea_sbox[0x01][(mea_ctx-&gt;m_state[i] &amp; 0x0000FF0000000000) &gt;&gt; 0x28]
  476          &lt;&lt; 0x28) |
  477         ((uint64_t)
  478              mea_sbox[0x02][(mea_ctx-&gt;m_state[i] &amp; 0x00FF000000000000) &gt;&gt; 0x30]
  479          &lt;&lt; 0x30) |
  480         ((uint64_t)
  481              mea_sbox[0x03][(mea_ctx-&gt;m_state[i] &amp; 0xFF00000000000000) &gt;&gt; 0x38]
  482          &lt;&lt; 0x38);
  483   }
  484 
  485   return 0;
  486 }
  487 
  488 int mea_invSubBytes(mea_t *mea_ctx) {
  489   for (int i = 0; i &lt; MEA_NW_STATE; i++) {
  490     mea_ctx-&gt;m_state[i] =
  491         mea_invSbox[0x00][(mea_ctx-&gt;m_state[i] &amp; 0x00000000000000FF)] |
  492         ((uint64_t)
  493              mea_invSbox[0x01]
  494                         [(mea_ctx-&gt;m_state[i] &amp; 0x000000000000FF00) &gt;&gt; 0x08]
  495          &lt;&lt; 0x08) |
  496         ((uint64_t)
  497              mea_invSbox[0x02]
  498                         [(mea_ctx-&gt;m_state[i] &amp; 0x0000000000FF0000) &gt;&gt; 0x10]
  499          &lt;&lt; 0x10) |
  500         ((uint64_t)
  501              mea_invSbox[0x03]
  502                         [(mea_ctx-&gt;m_state[i] &amp; 0x00000000FF000000) &gt;&gt; 0x18]
  503          &lt;&lt; 0x18) |
  504         ((uint64_t)
  505              mea_invSbox[0x00]
  506                         [(mea_ctx-&gt;m_state[i] &amp; 0x000000FF00000000) &gt;&gt; 0x20]
  507          &lt;&lt; 0x20) |
  508         ((uint64_t)
  509              mea_invSbox[0x01]
  510                         [(mea_ctx-&gt;m_state[i] &amp; 0x0000FF0000000000) &gt;&gt; 0x28]
  511          &lt;&lt; 0x28) |
  512         ((uint64_t)
  513              mea_invSbox[0x02]
  514                         [(mea_ctx-&gt;m_state[i] &amp; 0x00FF000000000000) &gt;&gt; 0x30]
  515          &lt;&lt; 0x30) |
  516         ((uint64_t)
  517              mea_invSbox[0x03]
  518                         [(mea_ctx-&gt;m_state[i] &amp; 0xFF00000000000000) &gt;&gt; 0x38]
  519          &lt;&lt; 0x38);
  520   }
  521 
  522   return 0;
  523 }
  524 
  525 int mea_dimRotate(mea_t *mea_ctx, uint8_t dim) {
  526   uint8_t i, s, k;
  527   uint8_t tmp[MEA_MS_IN_DIM];
  528   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  529 
  530   for (int l = 0; l &lt; MEA_MS_IN_DIM; l++) {
  531     tmp[l] = pmstate[MEA_MS_IN_DIM * dim + l];
  532   }
  533 
  534   for (i = 0; i &lt; MEA_MS_ROW; i++) {
  535     for (s = 0; s &lt; MEA_MS_ROW; s++) {
  536       k = s + 1;
  537       pmstate[MEA_MS_IN_DIM * dim + MEA_MS_ROW * (MEA_MS_ROW - k) + i] =
  538           tmp[MEA_MS_ROW * i + s];
  539     }
  540   }
  541 
  542   mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  543   return 0;
  544 }
  545 
  546 int mea_invDimRotate(mea_t *mea_ctx, uint8_t dim) {
  547   uint8_t i, s, k;
  548   uint8_t tmp[MEA_MS_IN_DIM];
  549   uint8_t *pmstate = __wordsToBytes(mea_ctx-&gt;m_state);
  550 
  551   for (int l = 0; l &lt; MEA_MS_IN_DIM; l++) {
  552     tmp[l] = pmstate[MEA_MS_IN_DIM * dim + l];
  553   }
  554 
  555   for (i = 0; i &lt; MEA_MS_ROW; i++) {
  556     for (s = 0; s &lt; MEA_MS_ROW; s++) {
  557       k = s + 1;
  558       pmstate[MEA_MS_IN_DIM * dim + MEA_MS_ROW * i + s] =
  559           tmp[MEA_MS_ROW * (MEA_MS_ROW - k) + i];
  560     }
  561   }
  562 
  563   mea_ctx-&gt;m_state = __bytesToWords(pmstate);
  564   return 0;
  565 }
  566 
  567 int mea_mixColumns(mea_t *mea_ctx) {
  568   __matrixMultiplywState(mea_ctx, mds_matrix);
  569   return 0;
  570 }
  571 
  572 int mea_invMixColumns(mea_t *mea_ctx) {
  573   __matrixMultiplywState(mea_ctx, mds_inv_matrix);
  574   return 0;
  575 }
  576 
  577 int mea_xorRoundKey(mea_t *mea_ctx, int round) {
  578   for (int i = 0; i &lt; MEA_NW_STATE; i++) {
  579     mea_ctx-&gt;m_state[i] = mea_ctx-&gt;m_state[i] ^ mea_ctx-&gt;r_keys[round][i];
  580   }
  581 
  582   return 0;
  583 }
</PRE>
</SPAN></TT>
</TD></TR></TABLE>
<SPAN CLASS="SMALL"></SPAN>

<P>

<H2><A ID="SECTION001015000000000000000">
main.c</A>
</H2>
<TABLE FRAME="VOID" CELLPADDING="4"><TR><TD>
<TT><SPAN CLASS="FOOTNOTESIZE">
<PRE  CLASS="verbatim">
    1 /*  
    2  *  Projekt :   MEA 
    3  *  Autor   :   Michael Engel
    4  *  Datei   :   main.c
    5 */  
    6 
    7 #include &lt;stdio.h&gt;
    8 #include &lt;stdint.h&gt;
    9 
   10 #include "mea.h"
   11 #include "tables.h"
   12 
   13 int print(uint64_t *input);
   14 
   15 int main(){
   16     uint64_t plain[8] = {0xd23412e140d67e3e, 0x09671b7823148bee, 0x0c2549512aed62fb, 0x033152cb267d449e,
   17                         0xff7a6618caa9e1b8, 0x4de9e7b02bfe66e8, 0x4313b4ed71bf8735, 0x35ea92cd2f442bfc};
   18 
   19     uint64_t key[8] = {0x8ff47276b13a6427, 0xf8c902c9acb386bb, 0x9d9be5eac2575ac1, 0x5ac16c57cb722825,
   20                         0x984f111a6a1c0cf4, 0x1c379112094de69a, 0xa573aa28564707b2, 0x263c23787ef5323d};
   21 
   22     uint64_t cipher[8];
   23     uint64_t dcipher[8];
   24 
   25     mea_t* ctxenc_mea = mea_init();
   26     mea_t* ctxdec_mea = mea_init();
   27     
   28     mea_generateRKeys(ctxenc_mea, key);
   29     mea_generateRKeys(ctxdec_mea, key);
   30 
   31     mea_blockEncipher(ctxenc_mea, plain, cipher);
   32     mea_blockDecipher(ctxdec_mea, cipher, dcipher);
   33 
   34     printf("%s\n", "Daten:");
   35     print(plain);
   36 
   37     printf("%s\n", "Verschluesselte Daten:");
   38     print(cipher);
   39 
   40     printf("%s\n", "Entschluesselte Daten:");
   41     print(dcipher);
   42     
   43     mea_del(ctxenc_mea);
   44     mea_del(ctxdec_mea);
   45 
   46     return 0;
   47 }
   48 
   49 int print(uint64_t *input){
   50     for(int i = 0; i &lt; MEA_NW_STATE; i++){
   51         printf("%llx", input[i]);
   52     }
   53 
   54     printf("\n\n");
   55     return 0;
   56 }
</PRE>
</SPAN></TT>
</TD></TR></TABLE>

<P>


<P>


<P>
<BR><HR>

</BODY>
</HTML>
